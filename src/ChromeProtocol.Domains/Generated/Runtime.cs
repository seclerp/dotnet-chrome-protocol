// <auto-generated />
#nullable enable

namespace ChromeProtocol.Domains
{
  /// <summary>
  /// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.<br/>
  /// Evaluation results are returned as mirror object that expose object type, string representation<br/>
  /// and unique identifier that can be used for further object reference. Original objects are<br/>
  /// maintained in memory unless they are either explicitly released or are released along with the<br/>
  /// other objects in their object group.<br/>
  /// </summary>
  public static partial class Runtime
  {
    /// <summary>Unique script identifier.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ScriptIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Represents options for serialization. Overrides `generatePreview` and `returnByValue`.</summary>
    /// <param name="MaxDepth">Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.</param>
    /// <param name="AdditionalParameters">
    /// Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM<br/>
    /// serialization via `maxNodeDepth: integer` and `includeShadowTree: &quot;none&quot; | &quot;open&quot; | &quot;all&quot;`.<br/>
    /// Values can be only of type string or integer.<br/>
    /// </param>
    public record SerializationOptionsType(
      [property: Newtonsoft.Json.JsonProperty("serialization")]
      string Serialization,
      [property: Newtonsoft.Json.JsonProperty("maxDepth")]
      int? MaxDepth = default,
      [property: Newtonsoft.Json.JsonProperty("additionalParameters")]
      Newtonsoft.Json.Linq.JObject? AdditionalParameters = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Represents deep serialized value.</summary>
    /// <param name="WeakLocalObjectReference">
    /// Set if value reference met more then once during serialization. In such<br/>
    /// case, value is provided only to one of the serialized values. Unique<br/>
    /// per value in the scope of one CDP call.<br/>
    /// </param>
    public record DeepSerializedValueType(
      [property: Newtonsoft.Json.JsonProperty("type")]
      string Type,
      [property: Newtonsoft.Json.JsonProperty("value")]
      Newtonsoft.Json.Linq.JToken? Value = default,
      [property: Newtonsoft.Json.JsonProperty("objectId")]
      string? ObjectId = default,
      [property: Newtonsoft.Json.JsonProperty("weakLocalObjectReference")]
      int? WeakLocalObjectReference = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Unique object identifier.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record RemoteObjectIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,<br/>
    /// `-Infinity`, and bigint literals.<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record UnserializableValueType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Mirror object referencing original JavaScript object.</summary>
    /// <param name="Type">Object type.</param>
    /// <param name="Subtype">
    /// Object subtype hint. Specified for `object` type values only.<br/>
    /// NOTE: If you change anything here, make sure to also update<br/>
    /// `subtype` in `ObjectPreview` and `PropertyPreview` below.<br/>
    /// </param>
    /// <param name="ClassName">Object class (constructor) name. Specified for `object` type values only.</param>
    /// <param name="Value">Remote object value in case of primitive values or JSON values (if it was requested).</param>
    /// <param name="UnserializableValue">
    /// Primitive value which can not be JSON-stringified does not have `value`, but gets this<br/>
    /// property.<br/>
    /// </param>
    /// <param name="Description">String representation of the object.</param>
    /// <param name="DeepSerializedValue">Deep serialized value.</param>
    /// <param name="ObjectId">Unique object identifier (for non-primitive values).</param>
    /// <param name="Preview">Preview containing abbreviated property values. Specified for `object` type values only.</param>
    public record RemoteObjectType(
      [property: Newtonsoft.Json.JsonProperty("type")]
      string Type,
      [property: Newtonsoft.Json.JsonProperty("subtype")]
      string? Subtype = default,
      [property: Newtonsoft.Json.JsonProperty("className")]
      string? ClassName = default,
      [property: Newtonsoft.Json.JsonProperty("value")]
      Newtonsoft.Json.Linq.JToken? Value = default,
      [property: Newtonsoft.Json.JsonProperty("unserializableValue")]
      ChromeProtocol.Domains.Runtime.UnserializableValueType? UnserializableValue = default,
      [property: Newtonsoft.Json.JsonProperty("description")]
      string? Description = default,
      [property: Newtonsoft.Json.JsonProperty("deepSerializedValue")]
      ChromeProtocol.Domains.Runtime.DeepSerializedValueType? DeepSerializedValue = default,
      [property: Newtonsoft.Json.JsonProperty("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default,
      [property: Newtonsoft.Json.JsonProperty("preview")]
      ChromeProtocol.Domains.Runtime.ObjectPreviewType? Preview = default,
      [property: Newtonsoft.Json.JsonProperty("customPreview")]
      ChromeProtocol.Domains.Runtime.CustomPreviewType? CustomPreview = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Header">
    /// The JSON-stringified result of formatter.header(object, config) call.<br/>
    /// It contains json ML array that represents RemoteObject.<br/>
    /// </param>
    /// <param name="BodyGetterId">
    /// If formatter returns true as a result of formatter.hasBody call then bodyGetterId will<br/>
    /// contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.<br/>
    /// The result value is json ML array.<br/>
    /// </param>
    public record CustomPreviewType(
      [property: Newtonsoft.Json.JsonProperty("header")]
      string Header,
      [property: Newtonsoft.Json.JsonProperty("bodyGetterId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? BodyGetterId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Object containing abbreviated remote object value.</summary>
    /// <param name="Type">Object type.</param>
    /// <param name="Overflow">True iff some of the properties or entries of the original object did not fit.</param>
    /// <param name="Properties">List of the properties.</param>
    /// <param name="Subtype">Object subtype hint. Specified for `object` type values only.</param>
    /// <param name="Description">String representation of the object.</param>
    /// <param name="Entries">List of the entries. Specified for `map` and `set` subtype values only.</param>
    public record ObjectPreviewType(
      [property: Newtonsoft.Json.JsonProperty("type")]
      string Type,
      [property: Newtonsoft.Json.JsonProperty("overflow")]
      bool Overflow,
      [property: Newtonsoft.Json.JsonProperty("properties")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.PropertyPreviewType> Properties,
      [property: Newtonsoft.Json.JsonProperty("subtype")]
      string? Subtype = default,
      [property: Newtonsoft.Json.JsonProperty("description")]
      string? Description = default,
      [property: Newtonsoft.Json.JsonProperty("entries")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.EntryPreviewType>? Entries = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Name">Property name.</param>
    /// <param name="Type">Object type. Accessor means that the property itself is an accessor property.</param>
    /// <param name="Value">User-friendly property value string.</param>
    /// <param name="ValuePreview">Nested value preview.</param>
    /// <param name="Subtype">Object subtype hint. Specified for `object` type values only.</param>
    public record PropertyPreviewType(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("type")]
      string Type,
      [property: Newtonsoft.Json.JsonProperty("value")]
      string? Value = default,
      [property: Newtonsoft.Json.JsonProperty("valuePreview")]
      ChromeProtocol.Domains.Runtime.ObjectPreviewType? ValuePreview = default,
      [property: Newtonsoft.Json.JsonProperty("subtype")]
      string? Subtype = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Value">Preview of the value.</param>
    /// <param name="Key">Preview of the key. Specified for map-like collection entries.</param>
    public record EntryPreviewType(
      [property: Newtonsoft.Json.JsonProperty("value")]
      ChromeProtocol.Domains.Runtime.ObjectPreviewType Value,
      [property: Newtonsoft.Json.JsonProperty("key")]
      ChromeProtocol.Domains.Runtime.ObjectPreviewType? Key = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Object property descriptor.</summary>
    /// <param name="Name">Property name or symbol description.</param>
    /// <param name="Configurable">
    /// True if the type of this property descriptor may be changed and if the property may be<br/>
    /// deleted from the corresponding object.<br/>
    /// </param>
    /// <param name="Enumerable">
    /// True if this property shows up during enumeration of the properties on the corresponding<br/>
    /// object.<br/>
    /// </param>
    /// <param name="Value">The value associated with the property.</param>
    /// <param name="Writable">True if the value associated with the property may be changed (data descriptors only).</param>
    /// <param name="Get">
    /// A function which serves as a getter for the property, or `undefined` if there is no getter<br/>
    /// (accessor descriptors only).<br/>
    /// </param>
    /// <param name="Set">
    /// A function which serves as a setter for the property, or `undefined` if there is no setter<br/>
    /// (accessor descriptors only).<br/>
    /// </param>
    /// <param name="WasThrown">True if the result was thrown during the evaluation.</param>
    /// <param name="IsOwn">True if the property is owned for the object.</param>
    /// <param name="Symbol">Property symbol object, if the property is of the `symbol` type.</param>
    public record PropertyDescriptorType(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("configurable")]
      bool Configurable,
      [property: Newtonsoft.Json.JsonProperty("enumerable")]
      bool Enumerable,
      [property: Newtonsoft.Json.JsonProperty("value")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Value = default,
      [property: Newtonsoft.Json.JsonProperty("writable")]
      bool? Writable = default,
      [property: Newtonsoft.Json.JsonProperty("get")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Get = default,
      [property: Newtonsoft.Json.JsonProperty("set")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Set = default,
      [property: Newtonsoft.Json.JsonProperty("wasThrown")]
      bool? WasThrown = default,
      [property: Newtonsoft.Json.JsonProperty("isOwn")]
      bool? IsOwn = default,
      [property: Newtonsoft.Json.JsonProperty("symbol")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Symbol = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Object internal property descriptor. This property isn&#39;t normally visible in JavaScript code.</summary>
    /// <param name="Name">Conventional property name.</param>
    /// <param name="Value">The value associated with the property.</param>
    public record InternalPropertyDescriptorType(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("value")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Value = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Object private field descriptor.</summary>
    /// <param name="Name">Private property name.</param>
    /// <param name="Value">The value associated with the private property.</param>
    /// <param name="Get">
    /// A function which serves as a getter for the private property,<br/>
    /// or `undefined` if there is no getter (accessor descriptors only).<br/>
    /// </param>
    /// <param name="Set">
    /// A function which serves as a setter for the private property,<br/>
    /// or `undefined` if there is no setter (accessor descriptors only).<br/>
    /// </param>
    public record PrivatePropertyDescriptorType(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("value")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Value = default,
      [property: Newtonsoft.Json.JsonProperty("get")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Get = default,
      [property: Newtonsoft.Json.JsonProperty("set")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Set = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Represents function call argument. Either remote object id `objectId`, primitive `value`,<br/>
    /// unserializable primitive value or neither of (for undefined) them should be specified.<br/>
    /// </summary>
    /// <param name="Value">Primitive value or serializable javascript object.</param>
    /// <param name="UnserializableValue">Primitive value which can not be JSON-stringified.</param>
    /// <param name="ObjectId">Remote object handle.</param>
    public record CallArgumentType(
      [property: Newtonsoft.Json.JsonProperty("value")]
      Newtonsoft.Json.Linq.JToken? Value = default,
      [property: Newtonsoft.Json.JsonProperty("unserializableValue")]
      ChromeProtocol.Domains.Runtime.UnserializableValueType? UnserializableValue = default,
      [property: Newtonsoft.Json.JsonProperty("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Id of an execution context.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ExecutionContextIdType(
      int Value
    ) : ChromeProtocol.Core.PrimitiveType<int>(Value)
    {
    }
    /// <summary>Description of an isolated world.</summary>
    /// <param name="Id">
    /// Unique id of the execution context. It can be used to specify in which execution context<br/>
    /// script evaluation should be performed.<br/>
    /// </param>
    /// <param name="Origin">Execution context origin.</param>
    /// <param name="Name">Human readable name describing given context.</param>
    /// <param name="UniqueId">
    /// A system-unique execution context identifier. Unlike the id, this is unique across<br/>
    /// multiple processes, so can be reliably used to identify specific context while backend<br/>
    /// performs a cross-process navigation.<br/>
    /// </param>
    /// <param name="AuxData">Embedder-specific auxiliary data likely matching {isDefault: boolean, type: &#39;default&#39;|&#39;isolated&#39;|&#39;worker&#39;, frameId: string}</param>
    public record ExecutionContextDescriptionType(
      [property: Newtonsoft.Json.JsonProperty("id")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType Id,
      [property: Newtonsoft.Json.JsonProperty("origin")]
      string Origin,
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("uniqueId")]
      string UniqueId,
      [property: Newtonsoft.Json.JsonProperty("auxData")]
      Newtonsoft.Json.Linq.JObject? AuxData = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Detailed information about exception (or error) that was thrown during script compilation or<br/>
    /// execution.<br/>
    /// </summary>
    /// <param name="ExceptionId">Exception id.</param>
    /// <param name="Text">Exception text, which should be used together with exception object when available.</param>
    /// <param name="LineNumber">Line number of the exception location (0-based).</param>
    /// <param name="ColumnNumber">Column number of the exception location (0-based).</param>
    /// <param name="ScriptId">Script ID of the exception location.</param>
    /// <param name="Url">URL of the exception location, to be used when the script was not reported.</param>
    /// <param name="StackTrace">JavaScript stack trace if available.</param>
    /// <param name="Exception">Exception object if available.</param>
    /// <param name="ExecutionContextId">Identifier of the context where exception happened.</param>
    /// <param name="ExceptionMetaData">
    /// Dictionary with entries of meta data that the client associated<br/>
    /// with this exception, such as information about associated network<br/>
    /// requests, etc.<br/>
    /// </param>
    public record ExceptionDetailsType(
      [property: Newtonsoft.Json.JsonProperty("exceptionId")]
      int ExceptionId,
      [property: Newtonsoft.Json.JsonProperty("text")]
      string Text,
      [property: Newtonsoft.Json.JsonProperty("lineNumber")]
      int LineNumber,
      [property: Newtonsoft.Json.JsonProperty("columnNumber")]
      int ColumnNumber,
      [property: Newtonsoft.Json.JsonProperty("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType? ScriptId = default,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string? Url = default,
      [property: Newtonsoft.Json.JsonProperty("stackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? StackTrace = default,
      [property: Newtonsoft.Json.JsonProperty("exception")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? Exception = default,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default,
      [property: Newtonsoft.Json.JsonProperty("exceptionMetaData")]
      Newtonsoft.Json.Linq.JObject? ExceptionMetaData = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Number of milliseconds since epoch.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record TimestampType(
      double Value
    ) : ChromeProtocol.Core.PrimitiveType<double>(Value)
    {
    }
    /// <summary>Number of milliseconds.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record TimeDeltaType(
      double Value
    ) : ChromeProtocol.Core.PrimitiveType<double>(Value)
    {
    }
    /// <summary>Stack entry for runtime errors and assertions.</summary>
    /// <param name="FunctionName">JavaScript function name.</param>
    /// <param name="ScriptId">JavaScript script id.</param>
    /// <param name="Url">JavaScript script name or url.</param>
    /// <param name="LineNumber">JavaScript script line number (0-based).</param>
    /// <param name="ColumnNumber">JavaScript script column number (0-based).</param>
    public record CallFrameType(
      [property: Newtonsoft.Json.JsonProperty("functionName")]
      string FunctionName,
      [property: Newtonsoft.Json.JsonProperty("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("lineNumber")]
      int LineNumber,
      [property: Newtonsoft.Json.JsonProperty("columnNumber")]
      int ColumnNumber
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Call frames for assertions or error messages.</summary>
    /// <param name="CallFrames">JavaScript function name.</param>
    /// <param name="Description">
    /// String label of this stack trace. For async traces this may be a name of the function that<br/>
    /// initiated the async call.<br/>
    /// </param>
    /// <param name="Parent">Asynchronous JavaScript stack trace that preceded this stack, if available.</param>
    /// <param name="ParentId">Asynchronous JavaScript stack trace that preceded this stack, if available.</param>
    public record StackTraceType(
      [property: Newtonsoft.Json.JsonProperty("callFrames")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.CallFrameType> CallFrames,
      [property: Newtonsoft.Json.JsonProperty("description")]
      string? Description = default,
      [property: Newtonsoft.Json.JsonProperty("parent")]
      ChromeProtocol.Domains.Runtime.StackTraceType? Parent = default,
      [property: Newtonsoft.Json.JsonProperty("parentId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType? ParentId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Unique identifier of current debugger.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record UniqueDebuggerIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This<br/>
    /// allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.<br/>
    /// </summary>
    public record StackTraceIdType(
      [property: Newtonsoft.Json.JsonProperty("id")]
      string Id,
      [property: Newtonsoft.Json.JsonProperty("debuggerId")]
      ChromeProtocol.Domains.Runtime.UniqueDebuggerIdType? DebuggerId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Notification is issued every time when binding is called.</summary>
    /// <param name="ExecutionContextId">Identifier of the context where the call was made.</param>
    [ChromeProtocol.Core.MethodName("Runtime.bindingCalled")]
    public record BindingCalled(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("payload")]
      string Payload,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType ExecutionContextId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when console API was called.</summary>
    /// <param name="Type">Type of the call.</param>
    /// <param name="Args">Call arguments.</param>
    /// <param name="ExecutionContextId">Identifier of the context where the call was made.</param>
    /// <param name="Timestamp">Call timestamp.</param>
    /// <param name="StackTrace">
    /// Stack trace captured when the call was made. The async stack chain is automatically reported for<br/>
    /// the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call<br/>
    /// chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.<br/>
    /// </param>
    /// <param name="Context">
    /// Console context descriptor for calls on non-default console context (not console.*):<br/>
    /// &#39;anonymous#unique-logger-id&#39; for call on unnamed context, &#39;name#unique-logger-id&#39; for call<br/>
    /// on named context.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.consoleAPICalled")]
    public record ConsoleAPICalled(
      [property: Newtonsoft.Json.JsonProperty("type")]
      string Type,
      [property: Newtonsoft.Json.JsonProperty("args")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.RemoteObjectType> Args,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType ExecutionContextId,
      [property: Newtonsoft.Json.JsonProperty("timestamp")]
      ChromeProtocol.Domains.Runtime.TimestampType Timestamp,
      [property: Newtonsoft.Json.JsonProperty("stackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? StackTrace = default,
      [property: Newtonsoft.Json.JsonProperty("context")]
      string? Context = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when unhandled exception was revoked.</summary>
    /// <param name="Reason">Reason describing why exception was revoked.</param>
    /// <param name="ExceptionId">The id of revoked exception, as reported in `exceptionThrown`.</param>
    [ChromeProtocol.Core.MethodName("Runtime.exceptionRevoked")]
    public record ExceptionRevoked(
      [property: Newtonsoft.Json.JsonProperty("reason")]
      string Reason,
      [property: Newtonsoft.Json.JsonProperty("exceptionId")]
      int ExceptionId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when exception was thrown and unhandled.</summary>
    /// <param name="Timestamp">Timestamp of the exception.</param>
    [ChromeProtocol.Core.MethodName("Runtime.exceptionThrown")]
    public record ExceptionThrown(
      [property: Newtonsoft.Json.JsonProperty("timestamp")]
      ChromeProtocol.Domains.Runtime.TimestampType Timestamp,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType ExceptionDetails
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when new execution context is created.</summary>
    /// <param name="Context">A newly created execution context.</param>
    [ChromeProtocol.Core.MethodName("Runtime.executionContextCreated")]
    public record ExecutionContextCreated(
      [property: Newtonsoft.Json.JsonProperty("context")]
      ChromeProtocol.Domains.Runtime.ExecutionContextDescriptionType Context
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when execution context is destroyed.</summary>
    /// <param name="ExecutionContextId">Id of the destroyed context</param>
    /// <param name="ExecutionContextUniqueId">Unique Id of the destroyed context</param>
    [ChromeProtocol.Core.MethodName("Runtime.executionContextDestroyed")]
    public record ExecutionContextDestroyed(
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType ExecutionContextId,
      [property: Newtonsoft.Json.JsonProperty("executionContextUniqueId")]
      string ExecutionContextUniqueId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when all executionContexts were cleared in browser</summary>
    [ChromeProtocol.Core.MethodName("Runtime.executionContextsCleared")]
    public record ExecutionContextsCleared() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Issued when object should be inspected (for example, as a result of inspect() command line API<br/>
    /// call).<br/>
    /// </summary>
    /// <param name="ExecutionContextId">Identifier of the context where the call was made.</param>
    [ChromeProtocol.Core.MethodName("Runtime.inspectRequested")]
    public record InspectRequested(
      [property: Newtonsoft.Json.JsonProperty("object")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Object,
      [property: Newtonsoft.Json.JsonProperty("hints")]
      Newtonsoft.Json.Linq.JObject Hints,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Add handler to promise with given promise object id.</summary>
    /// <param name="PromiseObjectId">Identifier of the promise.</param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    public static ChromeProtocol.Domains.Runtime.AwaitPromiseRequest AwaitPromise(ChromeProtocol.Domains.Runtime.RemoteObjectIdType PromiseObjectId, bool? ReturnByValue = default, bool? GeneratePreview = default)    
    {
      return new ChromeProtocol.Domains.Runtime.AwaitPromiseRequest(PromiseObjectId, ReturnByValue, GeneratePreview);
    }
    /// <summary>Add handler to promise with given promise object id.</summary>
    /// <param name="PromiseObjectId">Identifier of the promise.</param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    [ChromeProtocol.Core.MethodName("Runtime.awaitPromise")]
    public record AwaitPromiseRequest(
      [property: Newtonsoft.Json.JsonProperty("promiseObjectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType PromiseObjectId,
      [property: Newtonsoft.Json.JsonProperty("returnByValue")]
      bool? ReturnByValue = default,
      [property: Newtonsoft.Json.JsonProperty("generatePreview")]
      bool? GeneratePreview = default
    ) : ChromeProtocol.Core.ICommand<AwaitPromiseRequestResult>
    {
    }
    /// <param name="Result">Promise result. Will contain rejected value if promise was rejected.</param>
    /// <param name="ExceptionDetails">Exception details if stack strace is available.</param>
    public record AwaitPromiseRequestResult(
      [property: Newtonsoft.Json.JsonProperty("result")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Result,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Calls function with given declaration on the given object. Object group of the result is<br/>
    /// inherited from the target object.<br/>
    /// </summary>
    /// <param name="FunctionDeclaration">Declaration of the function to call.</param>
    /// <param name="ObjectId">
    /// Identifier of the object to call function on. Either objectId or executionContextId should<br/>
    /// be specified.<br/>
    /// </param>
    /// <param name="Arguments">
    /// Call arguments. All call arguments must belong to the same JavaScript world as the target<br/>
    /// object.<br/>
    /// </param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="ReturnByValue">
    /// Whether the result is expected to be a JSON object which should be sent by value.<br/>
    /// Can be overriden by `serializationOptions`.<br/>
    /// </param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="UserGesture">Whether execution should be treated as initiated by user in the UI.</param>
    /// <param name="AwaitPromise">
    /// Whether execution should `await` for resulting value and return once awaited promise is<br/>
    /// resolved.<br/>
    /// </param>
    /// <param name="ExecutionContextId">
    /// Specifies execution context which global object will be used to call function on. Either<br/>
    /// executionContextId or objectId should be specified.<br/>
    /// </param>
    /// <param name="ObjectGroup">
    /// Symbolic group name that can be used to release multiple objects. If objectGroup is not<br/>
    /// specified and objectId is, objectGroup will be inherited from object.<br/>
    /// </param>
    /// <param name="ThrowOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
    /// <param name="UniqueContextId">
    /// An alternative way to specify the execution context to call function on.<br/>
    /// Compared to contextId that may be reused across processes, this is guaranteed to be<br/>
    /// system-unique, so it can be used to prevent accidental function call<br/>
    /// in context different than intended (e.g. as a result of navigation across process<br/>
    /// boundaries).<br/>
    /// This is mutually exclusive with `executionContextId`.<br/>
    /// </param>
    /// <param name="SerializationOptions">
    /// Specifies the result serialization. If provided, overrides<br/>
    /// `generatePreview` and `returnByValue`.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Runtime.CallFunctionOnRequest CallFunctionOn(string FunctionDeclaration, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default, System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.CallArgumentType>? Arguments = default, bool? Silent = default, bool? ReturnByValue = default, bool? GeneratePreview = default, bool? UserGesture = default, bool? AwaitPromise = default, ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default, string? ObjectGroup = default, bool? ThrowOnSideEffect = default, string? UniqueContextId = default, ChromeProtocol.Domains.Runtime.SerializationOptionsType? SerializationOptions = default)    
    {
      return new ChromeProtocol.Domains.Runtime.CallFunctionOnRequest(FunctionDeclaration, ObjectId, Arguments, Silent, ReturnByValue, GeneratePreview, UserGesture, AwaitPromise, ExecutionContextId, ObjectGroup, ThrowOnSideEffect, UniqueContextId, SerializationOptions);
    }
    /// <summary>
    /// Calls function with given declaration on the given object. Object group of the result is<br/>
    /// inherited from the target object.<br/>
    /// </summary>
    /// <param name="FunctionDeclaration">Declaration of the function to call.</param>
    /// <param name="ObjectId">
    /// Identifier of the object to call function on. Either objectId or executionContextId should<br/>
    /// be specified.<br/>
    /// </param>
    /// <param name="Arguments">
    /// Call arguments. All call arguments must belong to the same JavaScript world as the target<br/>
    /// object.<br/>
    /// </param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="ReturnByValue">
    /// Whether the result is expected to be a JSON object which should be sent by value.<br/>
    /// Can be overriden by `serializationOptions`.<br/>
    /// </param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="UserGesture">Whether execution should be treated as initiated by user in the UI.</param>
    /// <param name="AwaitPromise">
    /// Whether execution should `await` for resulting value and return once awaited promise is<br/>
    /// resolved.<br/>
    /// </param>
    /// <param name="ExecutionContextId">
    /// Specifies execution context which global object will be used to call function on. Either<br/>
    /// executionContextId or objectId should be specified.<br/>
    /// </param>
    /// <param name="ObjectGroup">
    /// Symbolic group name that can be used to release multiple objects. If objectGroup is not<br/>
    /// specified and objectId is, objectGroup will be inherited from object.<br/>
    /// </param>
    /// <param name="ThrowOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
    /// <param name="UniqueContextId">
    /// An alternative way to specify the execution context to call function on.<br/>
    /// Compared to contextId that may be reused across processes, this is guaranteed to be<br/>
    /// system-unique, so it can be used to prevent accidental function call<br/>
    /// in context different than intended (e.g. as a result of navigation across process<br/>
    /// boundaries).<br/>
    /// This is mutually exclusive with `executionContextId`.<br/>
    /// </param>
    /// <param name="SerializationOptions">
    /// Specifies the result serialization. If provided, overrides<br/>
    /// `generatePreview` and `returnByValue`.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.callFunctionOn")]
    public record CallFunctionOnRequest(
      [property: Newtonsoft.Json.JsonProperty("functionDeclaration")]
      string FunctionDeclaration,
      [property: Newtonsoft.Json.JsonProperty("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default,
      [property: Newtonsoft.Json.JsonProperty("arguments")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.CallArgumentType>? Arguments = default,
      [property: Newtonsoft.Json.JsonProperty("silent")]
      bool? Silent = default,
      [property: Newtonsoft.Json.JsonProperty("returnByValue")]
      bool? ReturnByValue = default,
      [property: Newtonsoft.Json.JsonProperty("generatePreview")]
      bool? GeneratePreview = default,
      [property: Newtonsoft.Json.JsonProperty("userGesture")]
      bool? UserGesture = default,
      [property: Newtonsoft.Json.JsonProperty("awaitPromise")]
      bool? AwaitPromise = default,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default,
      [property: Newtonsoft.Json.JsonProperty("objectGroup")]
      string? ObjectGroup = default,
      [property: Newtonsoft.Json.JsonProperty("throwOnSideEffect")]
      bool? ThrowOnSideEffect = default,
      [property: Newtonsoft.Json.JsonProperty("uniqueContextId")]
      string? UniqueContextId = default,
      [property: Newtonsoft.Json.JsonProperty("serializationOptions")]
      ChromeProtocol.Domains.Runtime.SerializationOptionsType? SerializationOptions = default
    ) : ChromeProtocol.Core.ICommand<CallFunctionOnRequestResult>
    {
    }
    /// <param name="Result">Call result.</param>
    /// <param name="ExceptionDetails">Exception details.</param>
    public record CallFunctionOnRequestResult(
      [property: Newtonsoft.Json.JsonProperty("result")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Result,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Compiles expression.</summary>
    /// <param name="Expression">Expression to compile.</param>
    /// <param name="SourceURL">Source url to be set for the script.</param>
    /// <param name="PersistScript">Specifies whether the compiled script should be persisted.</param>
    /// <param name="ExecutionContextId">
    /// Specifies in which execution context to perform script run. If the parameter is omitted the<br/>
    /// evaluation will be performed in the context of the inspected page.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Runtime.CompileScriptRequest CompileScript(string Expression, string SourceURL, bool PersistScript, ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default)    
    {
      return new ChromeProtocol.Domains.Runtime.CompileScriptRequest(Expression, SourceURL, PersistScript, ExecutionContextId);
    }
    /// <summary>Compiles expression.</summary>
    /// <param name="Expression">Expression to compile.</param>
    /// <param name="SourceURL">Source url to be set for the script.</param>
    /// <param name="PersistScript">Specifies whether the compiled script should be persisted.</param>
    /// <param name="ExecutionContextId">
    /// Specifies in which execution context to perform script run. If the parameter is omitted the<br/>
    /// evaluation will be performed in the context of the inspected page.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.compileScript")]
    public record CompileScriptRequest(
      [property: Newtonsoft.Json.JsonProperty("expression")]
      string Expression,
      [property: Newtonsoft.Json.JsonProperty("sourceURL")]
      string SourceURL,
      [property: Newtonsoft.Json.JsonProperty("persistScript")]
      bool PersistScript,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default
    ) : ChromeProtocol.Core.ICommand<CompileScriptRequestResult>
    {
    }
    /// <param name="ScriptId">Id of the script.</param>
    /// <param name="ExceptionDetails">Exception details.</param>
    public record CompileScriptRequestResult(
      [property: Newtonsoft.Json.JsonProperty("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType? ScriptId = default,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Disables reporting of execution contexts creation.</summary>
    public static ChromeProtocol.Domains.Runtime.DisableRequest Disable()    
    {
      return new ChromeProtocol.Domains.Runtime.DisableRequest();
    }
    /// <summary>Disables reporting of execution contexts creation.</summary>
    [ChromeProtocol.Core.MethodName("Runtime.disable")]
    public record DisableRequest() : ChromeProtocol.Core.ICommand<DisableRequestResult>
    {
    }
    public record DisableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Discards collected exceptions and console API calls.</summary>
    public static ChromeProtocol.Domains.Runtime.DiscardConsoleEntriesRequest DiscardConsoleEntries()    
    {
      return new ChromeProtocol.Domains.Runtime.DiscardConsoleEntriesRequest();
    }
    /// <summary>Discards collected exceptions and console API calls.</summary>
    [ChromeProtocol.Core.MethodName("Runtime.discardConsoleEntries")]
    public record DiscardConsoleEntriesRequest() : ChromeProtocol.Core.ICommand<DiscardConsoleEntriesRequestResult>
    {
    }
    public record DiscardConsoleEntriesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enables reporting of execution contexts creation by means of `executionContextCreated` event.<br/>
    /// When the reporting gets enabled the event will be sent immediately for each existing execution<br/>
    /// context.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Runtime.EnableRequest Enable()    
    {
      return new ChromeProtocol.Domains.Runtime.EnableRequest();
    }
    /// <summary>
    /// Enables reporting of execution contexts creation by means of `executionContextCreated` event.<br/>
    /// When the reporting gets enabled the event will be sent immediately for each existing execution<br/>
    /// context.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Runtime.enable")]
    public record EnableRequest() : ChromeProtocol.Core.ICommand<EnableRequestResult>
    {
    }
    public record EnableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Evaluates expression on global object.</summary>
    /// <param name="Expression">Expression to evaluate.</param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release multiple objects.</param>
    /// <param name="IncludeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="ContextId">
    /// Specifies in which execution context to perform evaluation. If the parameter is omitted the<br/>
    /// evaluation will be performed in the context of the inspected page.<br/>
    /// This is mutually exclusive with `uniqueContextId`, which offers an<br/>
    /// alternative way to identify the execution context that is more reliable<br/>
    /// in a multi-process environment.<br/>
    /// </param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="UserGesture">Whether execution should be treated as initiated by user in the UI.</param>
    /// <param name="AwaitPromise">
    /// Whether execution should `await` for resulting value and return once awaited promise is<br/>
    /// resolved.<br/>
    /// </param>
    /// <param name="ThrowOnSideEffect">
    /// Whether to throw an exception if side effect cannot be ruled out during evaluation.<br/>
    /// This implies `disableBreaks` below.<br/>
    /// </param>
    /// <param name="Timeout">Terminate execution after timing out (number of milliseconds).</param>
    /// <param name="DisableBreaks">Disable breakpoints during execution.</param>
    /// <param name="ReplMode">
    /// Setting this flag to true enables `let` re-declaration and top-level `await`.<br/>
    /// Note that `let` variables can only be re-declared if they originate from<br/>
    /// `replMode` themselves.<br/>
    /// </param>
    /// <param name="AllowUnsafeEvalBlockedByCSP">
    /// The Content Security Policy (CSP) for the target might block &#39;unsafe-eval&#39;<br/>
    /// which includes eval(), Function(), setTimeout() and setInterval()<br/>
    /// when called with non-callable arguments. This flag bypasses CSP for this<br/>
    /// evaluation and allows unsafe-eval. Defaults to true.<br/>
    /// </param>
    /// <param name="UniqueContextId">
    /// An alternative way to specify the execution context to evaluate in.<br/>
    /// Compared to contextId that may be reused across processes, this is guaranteed to be<br/>
    /// system-unique, so it can be used to prevent accidental evaluation of the expression<br/>
    /// in context different than intended (e.g. as a result of navigation across process<br/>
    /// boundaries).<br/>
    /// This is mutually exclusive with `contextId`.<br/>
    /// </param>
    /// <param name="SerializationOptions">
    /// Specifies the result serialization. If provided, overrides<br/>
    /// `generatePreview` and `returnByValue`.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Runtime.EvaluateRequest Evaluate(string Expression, string? ObjectGroup = default, bool? IncludeCommandLineAPI = default, bool? Silent = default, ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ContextId = default, bool? ReturnByValue = default, bool? GeneratePreview = default, bool? UserGesture = default, bool? AwaitPromise = default, bool? ThrowOnSideEffect = default, ChromeProtocol.Domains.Runtime.TimeDeltaType? Timeout = default, bool? DisableBreaks = default, bool? ReplMode = default, bool? AllowUnsafeEvalBlockedByCSP = default, string? UniqueContextId = default, ChromeProtocol.Domains.Runtime.SerializationOptionsType? SerializationOptions = default)    
    {
      return new ChromeProtocol.Domains.Runtime.EvaluateRequest(Expression, ObjectGroup, IncludeCommandLineAPI, Silent, ContextId, ReturnByValue, GeneratePreview, UserGesture, AwaitPromise, ThrowOnSideEffect, Timeout, DisableBreaks, ReplMode, AllowUnsafeEvalBlockedByCSP, UniqueContextId, SerializationOptions);
    }
    /// <summary>Evaluates expression on global object.</summary>
    /// <param name="Expression">Expression to evaluate.</param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release multiple objects.</param>
    /// <param name="IncludeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="ContextId">
    /// Specifies in which execution context to perform evaluation. If the parameter is omitted the<br/>
    /// evaluation will be performed in the context of the inspected page.<br/>
    /// This is mutually exclusive with `uniqueContextId`, which offers an<br/>
    /// alternative way to identify the execution context that is more reliable<br/>
    /// in a multi-process environment.<br/>
    /// </param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="UserGesture">Whether execution should be treated as initiated by user in the UI.</param>
    /// <param name="AwaitPromise">
    /// Whether execution should `await` for resulting value and return once awaited promise is<br/>
    /// resolved.<br/>
    /// </param>
    /// <param name="ThrowOnSideEffect">
    /// Whether to throw an exception if side effect cannot be ruled out during evaluation.<br/>
    /// This implies `disableBreaks` below.<br/>
    /// </param>
    /// <param name="Timeout">Terminate execution after timing out (number of milliseconds).</param>
    /// <param name="DisableBreaks">Disable breakpoints during execution.</param>
    /// <param name="ReplMode">
    /// Setting this flag to true enables `let` re-declaration and top-level `await`.<br/>
    /// Note that `let` variables can only be re-declared if they originate from<br/>
    /// `replMode` themselves.<br/>
    /// </param>
    /// <param name="AllowUnsafeEvalBlockedByCSP">
    /// The Content Security Policy (CSP) for the target might block &#39;unsafe-eval&#39;<br/>
    /// which includes eval(), Function(), setTimeout() and setInterval()<br/>
    /// when called with non-callable arguments. This flag bypasses CSP for this<br/>
    /// evaluation and allows unsafe-eval. Defaults to true.<br/>
    /// </param>
    /// <param name="UniqueContextId">
    /// An alternative way to specify the execution context to evaluate in.<br/>
    /// Compared to contextId that may be reused across processes, this is guaranteed to be<br/>
    /// system-unique, so it can be used to prevent accidental evaluation of the expression<br/>
    /// in context different than intended (e.g. as a result of navigation across process<br/>
    /// boundaries).<br/>
    /// This is mutually exclusive with `contextId`.<br/>
    /// </param>
    /// <param name="SerializationOptions">
    /// Specifies the result serialization. If provided, overrides<br/>
    /// `generatePreview` and `returnByValue`.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.evaluate")]
    public record EvaluateRequest(
      [property: Newtonsoft.Json.JsonProperty("expression")]
      string Expression,
      [property: Newtonsoft.Json.JsonProperty("objectGroup")]
      string? ObjectGroup = default,
      [property: Newtonsoft.Json.JsonProperty("includeCommandLineAPI")]
      bool? IncludeCommandLineAPI = default,
      [property: Newtonsoft.Json.JsonProperty("silent")]
      bool? Silent = default,
      [property: Newtonsoft.Json.JsonProperty("contextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ContextId = default,
      [property: Newtonsoft.Json.JsonProperty("returnByValue")]
      bool? ReturnByValue = default,
      [property: Newtonsoft.Json.JsonProperty("generatePreview")]
      bool? GeneratePreview = default,
      [property: Newtonsoft.Json.JsonProperty("userGesture")]
      bool? UserGesture = default,
      [property: Newtonsoft.Json.JsonProperty("awaitPromise")]
      bool? AwaitPromise = default,
      [property: Newtonsoft.Json.JsonProperty("throwOnSideEffect")]
      bool? ThrowOnSideEffect = default,
      [property: Newtonsoft.Json.JsonProperty("timeout")]
      ChromeProtocol.Domains.Runtime.TimeDeltaType? Timeout = default,
      [property: Newtonsoft.Json.JsonProperty("disableBreaks")]
      bool? DisableBreaks = default,
      [property: Newtonsoft.Json.JsonProperty("replMode")]
      bool? ReplMode = default,
      [property: Newtonsoft.Json.JsonProperty("allowUnsafeEvalBlockedByCSP")]
      bool? AllowUnsafeEvalBlockedByCSP = default,
      [property: Newtonsoft.Json.JsonProperty("uniqueContextId")]
      string? UniqueContextId = default,
      [property: Newtonsoft.Json.JsonProperty("serializationOptions")]
      ChromeProtocol.Domains.Runtime.SerializationOptionsType? SerializationOptions = default
    ) : ChromeProtocol.Core.ICommand<EvaluateRequestResult>
    {
    }
    /// <param name="Result">Evaluation result.</param>
    /// <param name="ExceptionDetails">Exception details.</param>
    public record EvaluateRequestResult(
      [property: Newtonsoft.Json.JsonProperty("result")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Result,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns the isolate id.</summary>
    public static ChromeProtocol.Domains.Runtime.GetIsolateIdRequest GetIsolateId()    
    {
      return new ChromeProtocol.Domains.Runtime.GetIsolateIdRequest();
    }
    /// <summary>Returns the isolate id.</summary>
    [ChromeProtocol.Core.MethodName("Runtime.getIsolateId")]
    public record GetIsolateIdRequest() : ChromeProtocol.Core.ICommand<GetIsolateIdRequestResult>
    {
    }
    /// <param name="Id">The isolate id.</param>
    public record GetIsolateIdRequestResult(
      [property: Newtonsoft.Json.JsonProperty("id")]
      string Id
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the JavaScript heap usage.<br/>
    /// It is the total usage of the corresponding isolate not scoped to a particular Runtime.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Runtime.GetHeapUsageRequest GetHeapUsage()    
    {
      return new ChromeProtocol.Domains.Runtime.GetHeapUsageRequest();
    }
    /// <summary>
    /// Returns the JavaScript heap usage.<br/>
    /// It is the total usage of the corresponding isolate not scoped to a particular Runtime.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Runtime.getHeapUsage")]
    public record GetHeapUsageRequest() : ChromeProtocol.Core.ICommand<GetHeapUsageRequestResult>
    {
    }
    /// <param name="UsedSize">Used heap size in bytes.</param>
    /// <param name="TotalSize">Allocated heap size in bytes.</param>
    public record GetHeapUsageRequestResult(
      [property: Newtonsoft.Json.JsonProperty("usedSize")]
      double UsedSize,
      [property: Newtonsoft.Json.JsonProperty("totalSize")]
      double TotalSize
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns properties of a given object. Object group of the result is inherited from the target<br/>
    /// object.<br/>
    /// </summary>
    /// <param name="ObjectId">Identifier of the object to return properties for.</param>
    /// <param name="OwnProperties">
    /// If true, returns properties belonging only to the element itself, not to its prototype<br/>
    /// chain.<br/>
    /// </param>
    /// <param name="AccessorPropertiesOnly">
    /// If true, returns accessor properties (with getter/setter) only; internal properties are not<br/>
    /// returned either.<br/>
    /// </param>
    /// <param name="GeneratePreview">Whether preview should be generated for the results.</param>
    /// <param name="NonIndexedPropertiesOnly">If true, returns non-indexed properties only.</param>
    public static ChromeProtocol.Domains.Runtime.GetPropertiesRequest GetProperties(ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId, bool? OwnProperties = default, bool? AccessorPropertiesOnly = default, bool? GeneratePreview = default, bool? NonIndexedPropertiesOnly = default)    
    {
      return new ChromeProtocol.Domains.Runtime.GetPropertiesRequest(ObjectId, OwnProperties, AccessorPropertiesOnly, GeneratePreview, NonIndexedPropertiesOnly);
    }
    /// <summary>
    /// Returns properties of a given object. Object group of the result is inherited from the target<br/>
    /// object.<br/>
    /// </summary>
    /// <param name="ObjectId">Identifier of the object to return properties for.</param>
    /// <param name="OwnProperties">
    /// If true, returns properties belonging only to the element itself, not to its prototype<br/>
    /// chain.<br/>
    /// </param>
    /// <param name="AccessorPropertiesOnly">
    /// If true, returns accessor properties (with getter/setter) only; internal properties are not<br/>
    /// returned either.<br/>
    /// </param>
    /// <param name="GeneratePreview">Whether preview should be generated for the results.</param>
    /// <param name="NonIndexedPropertiesOnly">If true, returns non-indexed properties only.</param>
    [ChromeProtocol.Core.MethodName("Runtime.getProperties")]
    public record GetPropertiesRequest(
      [property: Newtonsoft.Json.JsonProperty("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId,
      [property: Newtonsoft.Json.JsonProperty("ownProperties")]
      bool? OwnProperties = default,
      [property: Newtonsoft.Json.JsonProperty("accessorPropertiesOnly")]
      bool? AccessorPropertiesOnly = default,
      [property: Newtonsoft.Json.JsonProperty("generatePreview")]
      bool? GeneratePreview = default,
      [property: Newtonsoft.Json.JsonProperty("nonIndexedPropertiesOnly")]
      bool? NonIndexedPropertiesOnly = default
    ) : ChromeProtocol.Core.ICommand<GetPropertiesRequestResult>
    {
    }
    /// <param name="Result">Object properties.</param>
    /// <param name="InternalProperties">Internal object properties (only of the element itself).</param>
    /// <param name="PrivateProperties">Object private properties.</param>
    /// <param name="ExceptionDetails">Exception details.</param>
    public record GetPropertiesRequestResult(
      [property: Newtonsoft.Json.JsonProperty("result")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.PropertyDescriptorType> Result,
      [property: Newtonsoft.Json.JsonProperty("internalProperties")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.InternalPropertyDescriptorType>? InternalProperties = default,
      [property: Newtonsoft.Json.JsonProperty("privateProperties")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Runtime.PrivatePropertyDescriptorType>? PrivateProperties = default,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns all let, const and class variables from global scope.</summary>
    /// <param name="ExecutionContextId">Specifies in which execution context to lookup global scope variables.</param>
    public static ChromeProtocol.Domains.Runtime.GlobalLexicalScopeNamesRequest GlobalLexicalScopeNames(ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default)    
    {
      return new ChromeProtocol.Domains.Runtime.GlobalLexicalScopeNamesRequest(ExecutionContextId);
    }
    /// <summary>Returns all let, const and class variables from global scope.</summary>
    /// <param name="ExecutionContextId">Specifies in which execution context to lookup global scope variables.</param>
    [ChromeProtocol.Core.MethodName("Runtime.globalLexicalScopeNames")]
    public record GlobalLexicalScopeNamesRequest(
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default
    ) : ChromeProtocol.Core.ICommand<GlobalLexicalScopeNamesRequestResult>
    {
    }
    public record GlobalLexicalScopeNamesRequestResult(
      [property: Newtonsoft.Json.JsonProperty("names")]
      System.Collections.Generic.IReadOnlyList<string> Names
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="PrototypeObjectId">Identifier of the prototype to return objects for.</param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release the results.</param>
    public static ChromeProtocol.Domains.Runtime.QueryObjectsRequest QueryObjects(ChromeProtocol.Domains.Runtime.RemoteObjectIdType PrototypeObjectId, string? ObjectGroup = default)    
    {
      return new ChromeProtocol.Domains.Runtime.QueryObjectsRequest(PrototypeObjectId, ObjectGroup);
    }
    /// <param name="PrototypeObjectId">Identifier of the prototype to return objects for.</param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release the results.</param>
    [ChromeProtocol.Core.MethodName("Runtime.queryObjects")]
    public record QueryObjectsRequest(
      [property: Newtonsoft.Json.JsonProperty("prototypeObjectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType PrototypeObjectId,
      [property: Newtonsoft.Json.JsonProperty("objectGroup")]
      string? ObjectGroup = default
    ) : ChromeProtocol.Core.ICommand<QueryObjectsRequestResult>
    {
    }
    /// <param name="Objects">Array with objects.</param>
    public record QueryObjectsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("objects")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Objects
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Releases remote object with given id.</summary>
    /// <param name="ObjectId">Identifier of the object to release.</param>
    public static ChromeProtocol.Domains.Runtime.ReleaseObjectRequest ReleaseObject(ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId)    
    {
      return new ChromeProtocol.Domains.Runtime.ReleaseObjectRequest(ObjectId);
    }
    /// <summary>Releases remote object with given id.</summary>
    /// <param name="ObjectId">Identifier of the object to release.</param>
    [ChromeProtocol.Core.MethodName("Runtime.releaseObject")]
    public record ReleaseObjectRequest(
      [property: Newtonsoft.Json.JsonProperty("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId
    ) : ChromeProtocol.Core.ICommand<ReleaseObjectRequestResult>
    {
    }
    public record ReleaseObjectRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Releases all remote objects that belong to a given group.</summary>
    /// <param name="ObjectGroup">Symbolic object group name.</param>
    public static ChromeProtocol.Domains.Runtime.ReleaseObjectGroupRequest ReleaseObjectGroup(string ObjectGroup)    
    {
      return new ChromeProtocol.Domains.Runtime.ReleaseObjectGroupRequest(ObjectGroup);
    }
    /// <summary>Releases all remote objects that belong to a given group.</summary>
    /// <param name="ObjectGroup">Symbolic object group name.</param>
    [ChromeProtocol.Core.MethodName("Runtime.releaseObjectGroup")]
    public record ReleaseObjectGroupRequest(
      [property: Newtonsoft.Json.JsonProperty("objectGroup")]
      string ObjectGroup
    ) : ChromeProtocol.Core.ICommand<ReleaseObjectGroupRequestResult>
    {
    }
    public record ReleaseObjectGroupRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Tells inspected instance to run if it was waiting for debugger to attach.</summary>
    public static ChromeProtocol.Domains.Runtime.RunIfWaitingForDebuggerRequest RunIfWaitingForDebugger()    
    {
      return new ChromeProtocol.Domains.Runtime.RunIfWaitingForDebuggerRequest();
    }
    /// <summary>Tells inspected instance to run if it was waiting for debugger to attach.</summary>
    [ChromeProtocol.Core.MethodName("Runtime.runIfWaitingForDebugger")]
    public record RunIfWaitingForDebuggerRequest() : ChromeProtocol.Core.ICommand<RunIfWaitingForDebuggerRequestResult>
    {
    }
    public record RunIfWaitingForDebuggerRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Runs script with given id in a given context.</summary>
    /// <param name="ScriptId">Id of the script to run.</param>
    /// <param name="ExecutionContextId">
    /// Specifies in which execution context to perform script run. If the parameter is omitted the<br/>
    /// evaluation will be performed in the context of the inspected page.<br/>
    /// </param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release multiple objects.</param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="IncludeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object which should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="AwaitPromise">
    /// Whether execution should `await` for resulting value and return once awaited promise is<br/>
    /// resolved.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Runtime.RunScriptRequest RunScript(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId, ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default, string? ObjectGroup = default, bool? Silent = default, bool? IncludeCommandLineAPI = default, bool? ReturnByValue = default, bool? GeneratePreview = default, bool? AwaitPromise = default)    
    {
      return new ChromeProtocol.Domains.Runtime.RunScriptRequest(ScriptId, ExecutionContextId, ObjectGroup, Silent, IncludeCommandLineAPI, ReturnByValue, GeneratePreview, AwaitPromise);
    }
    /// <summary>Runs script with given id in a given context.</summary>
    /// <param name="ScriptId">Id of the script to run.</param>
    /// <param name="ExecutionContextId">
    /// Specifies in which execution context to perform script run. If the parameter is omitted the<br/>
    /// evaluation will be performed in the context of the inspected page.<br/>
    /// </param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release multiple objects.</param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="IncludeCommandLineAPI">Determines whether Command Line API should be available during the evaluation.</param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object which should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="AwaitPromise">
    /// Whether execution should `await` for resulting value and return once awaited promise is<br/>
    /// resolved.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.runScript")]
    public record RunScriptRequest(
      [property: Newtonsoft.Json.JsonProperty("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default,
      [property: Newtonsoft.Json.JsonProperty("objectGroup")]
      string? ObjectGroup = default,
      [property: Newtonsoft.Json.JsonProperty("silent")]
      bool? Silent = default,
      [property: Newtonsoft.Json.JsonProperty("includeCommandLineAPI")]
      bool? IncludeCommandLineAPI = default,
      [property: Newtonsoft.Json.JsonProperty("returnByValue")]
      bool? ReturnByValue = default,
      [property: Newtonsoft.Json.JsonProperty("generatePreview")]
      bool? GeneratePreview = default,
      [property: Newtonsoft.Json.JsonProperty("awaitPromise")]
      bool? AwaitPromise = default
    ) : ChromeProtocol.Core.ICommand<RunScriptRequestResult>
    {
    }
    /// <param name="Result">Run result.</param>
    /// <param name="ExceptionDetails">Exception details.</param>
    public record RunScriptRequestResult(
      [property: Newtonsoft.Json.JsonProperty("result")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Result,
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enables or disables async call stacks tracking.</summary>
    /// <param name="MaxDepth">
    /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async<br/>
    /// call stacks (default).<br/>
    /// </param>
    public static ChromeProtocol.Domains.Runtime.SetAsyncCallStackDepthRequest SetAsyncCallStackDepth(int MaxDepth)    
    {
      return new ChromeProtocol.Domains.Runtime.SetAsyncCallStackDepthRequest(MaxDepth);
    }
    /// <summary>Enables or disables async call stacks tracking.</summary>
    /// <param name="MaxDepth">
    /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async<br/>
    /// call stacks (default).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.setAsyncCallStackDepth")]
    public record SetAsyncCallStackDepthRequest(
      [property: Newtonsoft.Json.JsonProperty("maxDepth")]
      int MaxDepth
    ) : ChromeProtocol.Core.ICommand<SetAsyncCallStackDepthRequestResult>
    {
    }
    public record SetAsyncCallStackDepthRequestResult() : ChromeProtocol.Core.IType
    {
    }
    public static ChromeProtocol.Domains.Runtime.SetCustomObjectFormatterEnabledRequest SetCustomObjectFormatterEnabled(bool Enabled)    
    {
      return new ChromeProtocol.Domains.Runtime.SetCustomObjectFormatterEnabledRequest(Enabled);
    }
    [ChromeProtocol.Core.MethodName("Runtime.setCustomObjectFormatterEnabled")]
    public record SetCustomObjectFormatterEnabledRequest(
      [property: Newtonsoft.Json.JsonProperty("enabled")]
      bool Enabled
    ) : ChromeProtocol.Core.ICommand<SetCustomObjectFormatterEnabledRequestResult>
    {
    }
    public record SetCustomObjectFormatterEnabledRequestResult() : ChromeProtocol.Core.IType
    {
    }
    public static ChromeProtocol.Domains.Runtime.SetMaxCallStackSizeToCaptureRequest SetMaxCallStackSizeToCapture(int Size)    
    {
      return new ChromeProtocol.Domains.Runtime.SetMaxCallStackSizeToCaptureRequest(Size);
    }
    [ChromeProtocol.Core.MethodName("Runtime.setMaxCallStackSizeToCapture")]
    public record SetMaxCallStackSizeToCaptureRequest(
      [property: Newtonsoft.Json.JsonProperty("size")]
      int Size
    ) : ChromeProtocol.Core.ICommand<SetMaxCallStackSizeToCaptureRequestResult>
    {
    }
    public record SetMaxCallStackSizeToCaptureRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Terminate current or next JavaScript execution.<br/>
    /// Will cancel the termination when the outer-most script execution ends.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Runtime.TerminateExecutionRequest TerminateExecution()    
    {
      return new ChromeProtocol.Domains.Runtime.TerminateExecutionRequest();
    }
    /// <summary>
    /// Terminate current or next JavaScript execution.<br/>
    /// Will cancel the termination when the outer-most script execution ends.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Runtime.terminateExecution")]
    public record TerminateExecutionRequest() : ChromeProtocol.Core.ICommand<TerminateExecutionRequestResult>
    {
    }
    public record TerminateExecutionRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// If executionContextId is empty, adds binding with the given name on the<br/>
    /// global objects of all inspected contexts, including those created later,<br/>
    /// bindings survive reloads.<br/>
    /// Binding function takes exactly one argument, this argument should be string,<br/>
    /// in case of any other input, function throws an exception.<br/>
    /// Each binding function call produces Runtime.bindingCalled notification.<br/>
    /// </summary>
    /// <param name="ExecutionContextId">
    /// If specified, the binding would only be exposed to the specified<br/>
    /// execution context. If omitted and `executionContextName` is not set,<br/>
    /// the binding is exposed to all execution contexts of the target.<br/>
    /// This parameter is mutually exclusive with `executionContextName`.<br/>
    /// Deprecated in favor of `executionContextName` due to an unclear use case<br/>
    /// and bugs in implementation (crbug.com/1169639). `executionContextId` will be<br/>
    /// removed in the future.<br/>
    /// </param>
    /// <param name="ExecutionContextName">
    /// If specified, the binding is exposed to the executionContext with<br/>
    /// matching name, even for contexts created after the binding is added.<br/>
    /// See also `ExecutionContext.name` and `worldName` parameter to<br/>
    /// `Page.addScriptToEvaluateOnNewDocument`.<br/>
    /// This parameter is mutually exclusive with `executionContextId`.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Runtime.AddBindingRequest AddBinding(string Name, ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default, string? ExecutionContextName = default)    
    {
      return new ChromeProtocol.Domains.Runtime.AddBindingRequest(Name, ExecutionContextId, ExecutionContextName);
    }
    /// <summary>
    /// If executionContextId is empty, adds binding with the given name on the<br/>
    /// global objects of all inspected contexts, including those created later,<br/>
    /// bindings survive reloads.<br/>
    /// Binding function takes exactly one argument, this argument should be string,<br/>
    /// in case of any other input, function throws an exception.<br/>
    /// Each binding function call produces Runtime.bindingCalled notification.<br/>
    /// </summary>
    /// <param name="ExecutionContextId">
    /// If specified, the binding would only be exposed to the specified<br/>
    /// execution context. If omitted and `executionContextName` is not set,<br/>
    /// the binding is exposed to all execution contexts of the target.<br/>
    /// This parameter is mutually exclusive with `executionContextName`.<br/>
    /// Deprecated in favor of `executionContextName` due to an unclear use case<br/>
    /// and bugs in implementation (crbug.com/1169639). `executionContextId` will be<br/>
    /// removed in the future.<br/>
    /// </param>
    /// <param name="ExecutionContextName">
    /// If specified, the binding is exposed to the executionContext with<br/>
    /// matching name, even for contexts created after the binding is added.<br/>
    /// See also `ExecutionContext.name` and `worldName` parameter to<br/>
    /// `Page.addScriptToEvaluateOnNewDocument`.<br/>
    /// This parameter is mutually exclusive with `executionContextId`.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Runtime.addBinding")]
    public record AddBindingRequest(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default,
      [property: Newtonsoft.Json.JsonProperty("executionContextName")]
      string? ExecutionContextName = default
    ) : ChromeProtocol.Core.ICommand<AddBindingRequestResult>
    {
    }
    public record AddBindingRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// This method does not remove binding function from global object but<br/>
    /// unsubscribes current runtime agent from Runtime.bindingCalled notifications.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Runtime.RemoveBindingRequest RemoveBinding(string Name)    
    {
      return new ChromeProtocol.Domains.Runtime.RemoveBindingRequest(Name);
    }
    /// <summary>
    /// This method does not remove binding function from global object but<br/>
    /// unsubscribes current runtime agent from Runtime.bindingCalled notifications.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Runtime.removeBinding")]
    public record RemoveBindingRequest(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name
    ) : ChromeProtocol.Core.ICommand<RemoveBindingRequestResult>
    {
    }
    public record RemoveBindingRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// This method tries to lookup and populate exception details for a<br/>
    /// JavaScript Error object.<br/>
    /// Note that the stackTrace portion of the resulting exceptionDetails will<br/>
    /// only be populated if the Runtime domain was enabled at the time when the<br/>
    /// Error was thrown.<br/>
    /// </summary>
    /// <param name="ErrorObjectId">The error object for which to resolve the exception details.</param>
    public static ChromeProtocol.Domains.Runtime.GetExceptionDetailsRequest GetExceptionDetails(ChromeProtocol.Domains.Runtime.RemoteObjectIdType ErrorObjectId)    
    {
      return new ChromeProtocol.Domains.Runtime.GetExceptionDetailsRequest(ErrorObjectId);
    }
    /// <summary>
    /// This method tries to lookup and populate exception details for a<br/>
    /// JavaScript Error object.<br/>
    /// Note that the stackTrace portion of the resulting exceptionDetails will<br/>
    /// only be populated if the Runtime domain was enabled at the time when the<br/>
    /// Error was thrown.<br/>
    /// </summary>
    /// <param name="ErrorObjectId">The error object for which to resolve the exception details.</param>
    [ChromeProtocol.Core.MethodName("Runtime.getExceptionDetails")]
    public record GetExceptionDetailsRequest(
      [property: Newtonsoft.Json.JsonProperty("errorObjectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType ErrorObjectId
    ) : ChromeProtocol.Core.ICommand<GetExceptionDetailsRequestResult>
    {
    }
    public record GetExceptionDetailsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
  }
}
