// <auto-generated />
#nullable enable

namespace ChromeProtocol.Domains
{
  /// <summary>Actions and events related to the inspected page belong to the page domain.</summary>
  public static partial class Page
  {
    /// <summary>Unique frame identifier.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record FrameIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Indicates whether a frame has been identified as an ad.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record AdFrameTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record AdFrameExplanationType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Indicates whether a frame has been identified as an ad and why.</summary>
    public record AdFrameStatusType(
      [property: Newtonsoft.Json.JsonProperty("adFrameType")]
      ChromeProtocol.Domains.Page.AdFrameTypeType AdFrameType,
      [property: Newtonsoft.Json.JsonProperty("explanations")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.AdFrameExplanationType>? Explanations = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Identifies the bottom-most script which caused the frame to be labelled<br/>
    /// as an ad.<br/>
    /// </summary>
    /// <param name="ScriptId">
    /// Script Id of the bottom-most script which caused the frame to be labelled<br/>
    /// as an ad.<br/>
    /// </param>
    /// <param name="DebuggerId">Id of adScriptId&#39;s debugger.</param>
    public record AdScriptIdType(
      [property: Newtonsoft.Json.JsonProperty("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: Newtonsoft.Json.JsonProperty("debuggerId")]
      ChromeProtocol.Domains.Runtime.UniqueDebuggerIdType DebuggerId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Indicates whether the frame is a secure context and why it is the case.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record SecureContextTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Indicates whether the frame is cross-origin isolated and why it is the case.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CrossOriginIsolatedContextTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record GatedAPIFeaturesType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// All Permissions Policy features. This enum should match the one defined<br/>
    /// in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record PermissionsPolicyFeatureType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Reason for a permissions policy feature to be disabled.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record PermissionsPolicyBlockReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    public record PermissionsPolicyBlockLocatorType(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("blockReason")]
      ChromeProtocol.Domains.Page.PermissionsPolicyBlockReasonType BlockReason
    ) : ChromeProtocol.Core.IType
    {
    }
    public record PermissionsPolicyFeatureStateType(
      [property: Newtonsoft.Json.JsonProperty("feature")]
      ChromeProtocol.Domains.Page.PermissionsPolicyFeatureType Feature,
      [property: Newtonsoft.Json.JsonProperty("allowed")]
      bool Allowed,
      [property: Newtonsoft.Json.JsonProperty("locator")]
      ChromeProtocol.Domains.Page.PermissionsPolicyBlockLocatorType? Locator = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Origin Trial(https://www.chromium.org/blink/origin-trials) support.<br/>
    /// Status for an Origin Trial token.<br/>
    /// </summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record OriginTrialTokenStatusType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Status for an Origin Trial.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record OriginTrialStatusType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record OriginTrialUsageRestrictionType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    public record OriginTrialTokenType(
      [property: Newtonsoft.Json.JsonProperty("origin")]
      string Origin,
      [property: Newtonsoft.Json.JsonProperty("matchSubDomains")]
      bool MatchSubDomains,
      [property: Newtonsoft.Json.JsonProperty("trialName")]
      string TrialName,
      [property: Newtonsoft.Json.JsonProperty("expiryTime")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType ExpiryTime,
      [property: Newtonsoft.Json.JsonProperty("isThirdParty")]
      bool IsThirdParty,
      [property: Newtonsoft.Json.JsonProperty("usageRestriction")]
      ChromeProtocol.Domains.Page.OriginTrialUsageRestrictionType UsageRestriction
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="ParsedToken">
    /// `parsedToken` is present only when the token is extractable and<br/>
    /// parsable.<br/>
    /// </param>
    public record OriginTrialTokenWithStatusType(
      [property: Newtonsoft.Json.JsonProperty("rawTokenText")]
      string RawTokenText,
      [property: Newtonsoft.Json.JsonProperty("status")]
      ChromeProtocol.Domains.Page.OriginTrialTokenStatusType Status,
      [property: Newtonsoft.Json.JsonProperty("parsedToken")]
      ChromeProtocol.Domains.Page.OriginTrialTokenType? ParsedToken = default
    ) : ChromeProtocol.Core.IType
    {
    }
    public record OriginTrialType(
      [property: Newtonsoft.Json.JsonProperty("trialName")]
      string TrialName,
      [property: Newtonsoft.Json.JsonProperty("status")]
      ChromeProtocol.Domains.Page.OriginTrialStatusType Status,
      [property: Newtonsoft.Json.JsonProperty("tokensWithStatus")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.OriginTrialTokenWithStatusType> TokensWithStatus
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about the Frame on the page.</summary>
    /// <param name="Id">Frame unique identifier.</param>
    /// <param name="LoaderId">Identifier of the loader associated with this frame.</param>
    /// <param name="Url">Frame document&#39;s URL without fragment.</param>
    /// <param name="DomainAndRegistry">
    /// Frame document&#39;s registered domain, taking the public suffixes list into account.<br/>
    /// Extracted from the Frame&#39;s url.<br/>
    /// Example URLs: http://www.google.com/file.html -&gt; &quot;google.com&quot;<br/>
    /// http://a.b.co.uk/file.html      -&gt; &quot;b.co.uk&quot;<br/>
    /// </param>
    /// <param name="SecurityOrigin">Frame document&#39;s security origin.</param>
    /// <param name="MimeType">Frame document&#39;s mimeType as determined by the browser.</param>
    /// <param name="SecureContextType">Indicates whether the main document is a secure context and explains why that is the case.</param>
    /// <param name="CrossOriginIsolatedContextType">Indicates whether this is a cross origin isolated context.</param>
    /// <param name="GatedAPIFeatures">Indicated which gated APIs / features are available.</param>
    /// <param name="ParentId">Parent frame identifier.</param>
    /// <param name="Name">Frame&#39;s name as specified in the tag.</param>
    /// <param name="UrlFragment">Frame document&#39;s URL fragment including the &#39;#&#39;.</param>
    /// <param name="UnreachableUrl">If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.</param>
    /// <param name="AdFrameStatus">Indicates whether this frame was tagged as an ad and why.</param>
    public record FrameType(
      [property: Newtonsoft.Json.JsonProperty("id")]
      ChromeProtocol.Domains.Page.FrameIdType Id,
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("domainAndRegistry")]
      string DomainAndRegistry,
      [property: Newtonsoft.Json.JsonProperty("securityOrigin")]
      string SecurityOrigin,
      [property: Newtonsoft.Json.JsonProperty("mimeType")]
      string MimeType,
      [property: Newtonsoft.Json.JsonProperty("secureContextType")]
      ChromeProtocol.Domains.Page.SecureContextTypeType SecureContextType,
      [property: Newtonsoft.Json.JsonProperty("crossOriginIsolatedContextType")]
      ChromeProtocol.Domains.Page.CrossOriginIsolatedContextTypeType CrossOriginIsolatedContextType,
      [property: Newtonsoft.Json.JsonProperty("gatedAPIFeatures")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.GatedAPIFeaturesType> GatedAPIFeatures,
      [property: Newtonsoft.Json.JsonProperty("parentId")]
      ChromeProtocol.Domains.Page.FrameIdType? ParentId = default,
      [property: Newtonsoft.Json.JsonProperty("name")]
      string? Name = default,
      [property: Newtonsoft.Json.JsonProperty("urlFragment")]
      string? UrlFragment = default,
      [property: Newtonsoft.Json.JsonProperty("unreachableUrl")]
      string? UnreachableUrl = default,
      [property: Newtonsoft.Json.JsonProperty("adFrameStatus")]
      ChromeProtocol.Domains.Page.AdFrameStatusType? AdFrameStatus = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about the Resource on the page.</summary>
    /// <param name="Url">Resource URL.</param>
    /// <param name="Type">Type of this resource.</param>
    /// <param name="MimeType">Resource mimeType as determined by the browser.</param>
    /// <param name="LastModified">last-modified timestamp as reported by server.</param>
    /// <param name="ContentSize">Resource content size.</param>
    /// <param name="Failed">True if the resource failed to load.</param>
    /// <param name="Canceled">True if the resource was canceled during loading.</param>
    public record FrameResourceType(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("type")]
      ChromeProtocol.Domains.Network.ResourceTypeType Type,
      [property: Newtonsoft.Json.JsonProperty("mimeType")]
      string MimeType,
      [property: Newtonsoft.Json.JsonProperty("lastModified")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType? LastModified = default,
      [property: Newtonsoft.Json.JsonProperty("contentSize")]
      double? ContentSize = default,
      [property: Newtonsoft.Json.JsonProperty("failed")]
      bool? Failed = default,
      [property: Newtonsoft.Json.JsonProperty("canceled")]
      bool? Canceled = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about the Frame hierarchy along with their cached resources.</summary>
    /// <param name="Frame">Frame information for this tree item.</param>
    /// <param name="Resources">Information about frame resources.</param>
    /// <param name="ChildFrames">Child frames.</param>
    public record FrameResourceTreeType(
      [property: Newtonsoft.Json.JsonProperty("frame")]
      ChromeProtocol.Domains.Page.FrameType Frame,
      [property: Newtonsoft.Json.JsonProperty("resources")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.FrameResourceType> Resources,
      [property: Newtonsoft.Json.JsonProperty("childFrames")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.FrameResourceTreeType>? ChildFrames = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about the Frame hierarchy.</summary>
    /// <param name="Frame">Frame information for this tree item.</param>
    /// <param name="ChildFrames">Child frames.</param>
    public record FrameTreeType(
      [property: Newtonsoft.Json.JsonProperty("frame")]
      ChromeProtocol.Domains.Page.FrameType Frame,
      [property: Newtonsoft.Json.JsonProperty("childFrames")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.FrameTreeType>? ChildFrames = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Unique script identifier.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ScriptIdentifierType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Transition type.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record TransitionTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Navigation history entry.</summary>
    /// <param name="Id">Unique id of the navigation history entry.</param>
    /// <param name="Url">URL of the navigation history entry.</param>
    /// <param name="UserTypedURL">URL that the user typed in the url bar.</param>
    /// <param name="Title">Title of the navigation history entry.</param>
    /// <param name="TransitionType">Transition type.</param>
    public record NavigationEntryType(
      [property: Newtonsoft.Json.JsonProperty("id")]
      int Id,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("userTypedURL")]
      string UserTypedURL,
      [property: Newtonsoft.Json.JsonProperty("title")]
      string Title,
      [property: Newtonsoft.Json.JsonProperty("transitionType")]
      ChromeProtocol.Domains.Page.TransitionTypeType TransitionType
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Screencast frame metadata.</summary>
    /// <param name="OffsetTop">Top offset in DIP.</param>
    /// <param name="PageScaleFactor">Page scale factor.</param>
    /// <param name="DeviceWidth">Device screen width in DIP.</param>
    /// <param name="DeviceHeight">Device screen height in DIP.</param>
    /// <param name="ScrollOffsetX">Position of horizontal scroll in CSS pixels.</param>
    /// <param name="ScrollOffsetY">Position of vertical scroll in CSS pixels.</param>
    /// <param name="Timestamp">Frame swap timestamp.</param>
    public record ScreencastFrameMetadataType(
      [property: Newtonsoft.Json.JsonProperty("offsetTop")]
      double OffsetTop,
      [property: Newtonsoft.Json.JsonProperty("pageScaleFactor")]
      double PageScaleFactor,
      [property: Newtonsoft.Json.JsonProperty("deviceWidth")]
      double DeviceWidth,
      [property: Newtonsoft.Json.JsonProperty("deviceHeight")]
      double DeviceHeight,
      [property: Newtonsoft.Json.JsonProperty("scrollOffsetX")]
      double ScrollOffsetX,
      [property: Newtonsoft.Json.JsonProperty("scrollOffsetY")]
      double ScrollOffsetY,
      [property: Newtonsoft.Json.JsonProperty("timestamp")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType? Timestamp = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Javascript dialog type.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record DialogTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Error while paring app manifest.</summary>
    /// <param name="Message">Error message.</param>
    /// <param name="Critical">If critical, this is a non-recoverable parse error.</param>
    /// <param name="Line">Error line.</param>
    /// <param name="Column">Error column.</param>
    public record AppManifestErrorType(
      [property: Newtonsoft.Json.JsonProperty("message")]
      string Message,
      [property: Newtonsoft.Json.JsonProperty("critical")]
      int Critical,
      [property: Newtonsoft.Json.JsonProperty("line")]
      int Line,
      [property: Newtonsoft.Json.JsonProperty("column")]
      int Column
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Parsed app manifest properties.</summary>
    /// <param name="Scope">Computed scope value</param>
    public record AppManifestParsedPropertiesType(
      [property: Newtonsoft.Json.JsonProperty("scope")]
      string Scope
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Layout viewport position and dimensions.</summary>
    /// <param name="PageX">Horizontal offset relative to the document (CSS pixels).</param>
    /// <param name="PageY">Vertical offset relative to the document (CSS pixels).</param>
    /// <param name="ClientWidth">Width (CSS pixels), excludes scrollbar if present.</param>
    /// <param name="ClientHeight">Height (CSS pixels), excludes scrollbar if present.</param>
    public record LayoutViewportType(
      [property: Newtonsoft.Json.JsonProperty("pageX")]
      int PageX,
      [property: Newtonsoft.Json.JsonProperty("pageY")]
      int PageY,
      [property: Newtonsoft.Json.JsonProperty("clientWidth")]
      int ClientWidth,
      [property: Newtonsoft.Json.JsonProperty("clientHeight")]
      int ClientHeight
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Visual viewport position, dimensions, and scale.</summary>
    /// <param name="OffsetX">Horizontal offset relative to the layout viewport (CSS pixels).</param>
    /// <param name="OffsetY">Vertical offset relative to the layout viewport (CSS pixels).</param>
    /// <param name="PageX">Horizontal offset relative to the document (CSS pixels).</param>
    /// <param name="PageY">Vertical offset relative to the document (CSS pixels).</param>
    /// <param name="ClientWidth">Width (CSS pixels), excludes scrollbar if present.</param>
    /// <param name="ClientHeight">Height (CSS pixels), excludes scrollbar if present.</param>
    /// <param name="Scale">Scale relative to the ideal viewport (size at width=device-width).</param>
    /// <param name="Zoom">Page zoom factor (CSS to device independent pixels ratio).</param>
    public record VisualViewportType(
      [property: Newtonsoft.Json.JsonProperty("offsetX")]
      double OffsetX,
      [property: Newtonsoft.Json.JsonProperty("offsetY")]
      double OffsetY,
      [property: Newtonsoft.Json.JsonProperty("pageX")]
      double PageX,
      [property: Newtonsoft.Json.JsonProperty("pageY")]
      double PageY,
      [property: Newtonsoft.Json.JsonProperty("clientWidth")]
      double ClientWidth,
      [property: Newtonsoft.Json.JsonProperty("clientHeight")]
      double ClientHeight,
      [property: Newtonsoft.Json.JsonProperty("scale")]
      double Scale,
      [property: Newtonsoft.Json.JsonProperty("zoom")]
      double? Zoom = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Viewport for capturing screenshot.</summary>
    /// <param name="X">X offset in device independent pixels (dip).</param>
    /// <param name="Y">Y offset in device independent pixels (dip).</param>
    /// <param name="Width">Rectangle width in device independent pixels (dip).</param>
    /// <param name="Height">Rectangle height in device independent pixels (dip).</param>
    /// <param name="Scale">Page scale factor.</param>
    public record ViewportType(
      [property: Newtonsoft.Json.JsonProperty("x")]
      double X,
      [property: Newtonsoft.Json.JsonProperty("y")]
      double Y,
      [property: Newtonsoft.Json.JsonProperty("width")]
      double Width,
      [property: Newtonsoft.Json.JsonProperty("height")]
      double Height,
      [property: Newtonsoft.Json.JsonProperty("scale")]
      double Scale
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Generic font families collection.</summary>
    /// <param name="Standard">The standard font-family.</param>
    /// <param name="Fixed">The fixed font-family.</param>
    /// <param name="Serif">The serif font-family.</param>
    /// <param name="SansSerif">The sansSerif font-family.</param>
    /// <param name="Cursive">The cursive font-family.</param>
    /// <param name="Fantasy">The fantasy font-family.</param>
    /// <param name="Math">The math font-family.</param>
    public record FontFamiliesType(
      [property: Newtonsoft.Json.JsonProperty("standard")]
      string? Standard = default,
      [property: Newtonsoft.Json.JsonProperty("fixed")]
      string? Fixed = default,
      [property: Newtonsoft.Json.JsonProperty("serif")]
      string? Serif = default,
      [property: Newtonsoft.Json.JsonProperty("sansSerif")]
      string? SansSerif = default,
      [property: Newtonsoft.Json.JsonProperty("cursive")]
      string? Cursive = default,
      [property: Newtonsoft.Json.JsonProperty("fantasy")]
      string? Fantasy = default,
      [property: Newtonsoft.Json.JsonProperty("math")]
      string? Math = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Font families collection for a script.</summary>
    /// <param name="Script">Name of the script which these font families are defined for.</param>
    /// <param name="FontFamilies">Generic font families collection for the script.</param>
    public record ScriptFontFamiliesType(
      [property: Newtonsoft.Json.JsonProperty("script")]
      string Script,
      [property: Newtonsoft.Json.JsonProperty("fontFamilies")]
      ChromeProtocol.Domains.Page.FontFamiliesType FontFamilies
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Default font sizes.</summary>
    /// <param name="Standard">Default standard font size.</param>
    /// <param name="Fixed">Default fixed font size.</param>
    public record FontSizesType(
      [property: Newtonsoft.Json.JsonProperty("standard")]
      int? Standard = default,
      [property: Newtonsoft.Json.JsonProperty("fixed")]
      int? Fixed = default
    ) : ChromeProtocol.Core.IType
    {
    }
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ClientNavigationReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ClientNavigationDispositionType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <param name="Name">Argument name (e.g. name:&#39;minimum-icon-size-in-pixels&#39;).</param>
    /// <param name="Value">Argument value (e.g. value:&#39;64&#39;).</param>
    public record InstallabilityErrorArgumentType(
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("value")]
      string Value
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>The installability error</summary>
    /// <param name="ErrorId">The error id (e.g. &#39;manifest-missing-suitable-icon&#39;).</param>
    /// <param name="ErrorArguments">The list of error arguments (e.g. {name:&#39;minimum-icon-size-in-pixels&#39;, value:&#39;64&#39;}).</param>
    public record InstallabilityErrorType(
      [property: Newtonsoft.Json.JsonProperty("errorId")]
      string ErrorId,
      [property: Newtonsoft.Json.JsonProperty("errorArguments")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.InstallabilityErrorArgumentType> ErrorArguments
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>The referring-policy used for the navigation.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ReferrerPolicyType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Per-script compilation cache parameters for `Page.produceCompilationCache`</summary>
    /// <param name="Url">The URL of the script to produce a compilation cache entry for.</param>
    /// <param name="Eager">
    /// A hint to the backend whether eager compilation is recommended.<br/>
    /// (the actual compilation mode used is upon backend discretion).<br/>
    /// </param>
    public record CompilationCacheParamsType(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("eager")]
      bool? Eager = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enum of possible auto-response for permission / prompt dialogs.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record AutoResponseModeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>The type of a frameNavigated event.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record NavigationTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>List of not restored reasons for back-forward cache.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record BackForwardCacheNotRestoredReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Types of not restored reasons for back-forward cache.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record BackForwardCacheNotRestoredReasonTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <param name="LineNumber">Line number in the script (0-based).</param>
    /// <param name="ColumnNumber">Column number in the script (0-based).</param>
    /// <param name="Url">Url of the file where blockage happened. Optional because of tests.</param>
    /// <param name="Function">Function name where blockage happened. Optional because of anonymous functions and tests.</param>
    public record BackForwardCacheBlockingDetailsType(
      [property: Newtonsoft.Json.JsonProperty("lineNumber")]
      int LineNumber,
      [property: Newtonsoft.Json.JsonProperty("columnNumber")]
      int ColumnNumber,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string? Url = default,
      [property: Newtonsoft.Json.JsonProperty("function")]
      string? Function = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Type">Type of the reason</param>
    /// <param name="Reason">Not restored reason</param>
    /// <param name="Context">
    /// Context associated with the reason. The meaning of this context is<br/>
    /// dependent on the reason:<br/>
    /// - EmbedderExtensionSentMessageToCachedFrame: the extension ID.<br/>
    /// </param>
    public record BackForwardCacheNotRestoredExplanationType(
      [property: Newtonsoft.Json.JsonProperty("type")]
      ChromeProtocol.Domains.Page.BackForwardCacheNotRestoredReasonTypeType Type,
      [property: Newtonsoft.Json.JsonProperty("reason")]
      ChromeProtocol.Domains.Page.BackForwardCacheNotRestoredReasonType Reason,
      [property: Newtonsoft.Json.JsonProperty("context")]
      string? Context = default,
      [property: Newtonsoft.Json.JsonProperty("details")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.BackForwardCacheBlockingDetailsType>? Details = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Url">URL of each frame</param>
    /// <param name="Explanations">Not restored reasons of each frame</param>
    /// <param name="Children">Array of children frame</param>
    public record BackForwardCacheNotRestoredExplanationTreeType(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("explanations")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.BackForwardCacheNotRestoredExplanationType> Explanations,
      [property: Newtonsoft.Json.JsonProperty("children")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.BackForwardCacheNotRestoredExplanationTreeType> Children
    ) : ChromeProtocol.Core.IType
    {
    }
    [ChromeProtocol.Core.MethodName("Page.domContentEventFired")]
    public record DomContentEventFired(
      [property: Newtonsoft.Json.JsonProperty("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Emitted only when `page.interceptFileChooser` is enabled.</summary>
    /// <param name="FrameId">Id of the frame containing input node.</param>
    /// <param name="Mode">Input mode.</param>
    /// <param name="BackendNodeId">Input node id. Only present for file choosers opened via an `&lt;input type=&quot;file&quot;&gt;` element.</param>
    [ChromeProtocol.Core.MethodName("Page.fileChooserOpened")]
    public record FileChooserOpened(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("mode")]
      string Mode,
      [property: Newtonsoft.Json.JsonProperty("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when frame has been attached to its parent.</summary>
    /// <param name="FrameId">Id of the frame that has been attached.</param>
    /// <param name="ParentFrameId">Parent frame identifier.</param>
    /// <param name="Stack">JavaScript stack trace of when frame was attached, only set if frame initiated from script.</param>
    [ChromeProtocol.Core.MethodName("Page.frameAttached")]
    public record FrameAttached(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("parentFrameId")]
      ChromeProtocol.Domains.Page.FrameIdType ParentFrameId,
      [property: Newtonsoft.Json.JsonProperty("stack")]
      ChromeProtocol.Domains.Runtime.StackTraceType? Stack = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when frame no longer has a scheduled navigation.</summary>
    /// <param name="FrameId">Id of the frame that has cleared its scheduled navigation.</param>
    [ChromeProtocol.Core.MethodName("Page.frameClearedScheduledNavigation")]
    [System.Obsolete("This event marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record FrameClearedScheduledNavigation(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when frame has been detached from its parent.</summary>
    /// <param name="FrameId">Id of the frame that has been detached.</param>
    [ChromeProtocol.Core.MethodName("Page.frameDetached")]
    public record FrameDetached(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("reason")]
      string Reason
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired once navigation of the frame has completed. Frame is now associated with the new loader.</summary>
    /// <param name="Frame">Frame object.</param>
    [ChromeProtocol.Core.MethodName("Page.frameNavigated")]
    public record FrameNavigated(
      [property: Newtonsoft.Json.JsonProperty("frame")]
      ChromeProtocol.Domains.Page.FrameType Frame,
      [property: Newtonsoft.Json.JsonProperty("type")]
      ChromeProtocol.Domains.Page.NavigationTypeType Type
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when opening document to write to.</summary>
    /// <param name="Frame">Frame object.</param>
    [ChromeProtocol.Core.MethodName("Page.documentOpened")]
    public record DocumentOpened(
      [property: Newtonsoft.Json.JsonProperty("frame")]
      ChromeProtocol.Domains.Page.FrameType Frame
    ) : ChromeProtocol.Core.IEvent
    {
    }
    [ChromeProtocol.Core.MethodName("Page.frameResized")]
    public record FrameResized() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when a renderer-initiated navigation is requested.<br/>
    /// Navigation may still be cancelled after the event is issued.<br/>
    /// </summary>
    /// <param name="FrameId">Id of the frame that is being navigated.</param>
    /// <param name="Reason">The reason for the navigation.</param>
    /// <param name="Url">The destination URL for the requested navigation.</param>
    /// <param name="Disposition">The disposition for the navigation.</param>
    [ChromeProtocol.Core.MethodName("Page.frameRequestedNavigation")]
    public record FrameRequestedNavigation(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("reason")]
      ChromeProtocol.Domains.Page.ClientNavigationReasonType Reason,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("disposition")]
      ChromeProtocol.Domains.Page.ClientNavigationDispositionType Disposition
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when frame schedules a potential navigation.</summary>
    /// <param name="FrameId">Id of the frame that has scheduled a navigation.</param>
    /// <param name="Delay">
    /// Delay (in seconds) until the navigation is scheduled to begin. The navigation is not<br/>
    /// guaranteed to start.<br/>
    /// </param>
    /// <param name="Reason">The reason for the navigation.</param>
    /// <param name="Url">The destination URL for the scheduled navigation.</param>
    [ChromeProtocol.Core.MethodName("Page.frameScheduledNavigation")]
    [System.Obsolete("This event marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record FrameScheduledNavigation(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("delay")]
      double Delay,
      [property: Newtonsoft.Json.JsonProperty("reason")]
      ChromeProtocol.Domains.Page.ClientNavigationReasonType Reason,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when frame has started loading.</summary>
    /// <param name="FrameId">Id of the frame that has started loading.</param>
    [ChromeProtocol.Core.MethodName("Page.frameStartedLoading")]
    public record FrameStartedLoading(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when frame has stopped loading.</summary>
    /// <param name="FrameId">Id of the frame that has stopped loading.</param>
    [ChromeProtocol.Core.MethodName("Page.frameStoppedLoading")]
    public record FrameStoppedLoading(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when page is about to start a download.<br/>
    /// Deprecated. Use Browser.downloadWillBegin instead.<br/>
    /// </summary>
    /// <param name="FrameId">Id of the frame that caused download to begin.</param>
    /// <param name="Guid">Global unique identifier of the download.</param>
    /// <param name="Url">URL of the resource being downloaded.</param>
    /// <param name="SuggestedFilename">Suggested file name of the resource (the actual name of the file saved on disk may differ).</param>
    [ChromeProtocol.Core.MethodName("Page.downloadWillBegin")]
    [System.Obsolete("This event marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record DownloadWillBegin(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("guid")]
      string Guid,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("suggestedFilename")]
      string SuggestedFilename
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when download makes progress. Last call has |done| == true.<br/>
    /// Deprecated. Use Browser.downloadProgress instead.<br/>
    /// </summary>
    /// <param name="Guid">Global unique identifier of the download.</param>
    /// <param name="TotalBytes">Total expected bytes to download.</param>
    /// <param name="ReceivedBytes">Total bytes received.</param>
    /// <param name="State">Download status.</param>
    [ChromeProtocol.Core.MethodName("Page.downloadProgress")]
    [System.Obsolete("This event marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record DownloadProgress(
      [property: Newtonsoft.Json.JsonProperty("guid")]
      string Guid,
      [property: Newtonsoft.Json.JsonProperty("totalBytes")]
      double TotalBytes,
      [property: Newtonsoft.Json.JsonProperty("receivedBytes")]
      double ReceivedBytes,
      [property: Newtonsoft.Json.JsonProperty("state")]
      string State
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when interstitial page was hidden</summary>
    [ChromeProtocol.Core.MethodName("Page.interstitialHidden")]
    public record InterstitialHidden() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when interstitial page was shown</summary>
    [ChromeProtocol.Core.MethodName("Page.interstitialShown")]
    public record InterstitialShown() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been<br/>
    /// closed.<br/>
    /// </summary>
    /// <param name="Result">Whether dialog was confirmed.</param>
    /// <param name="UserInput">User input in case of prompt.</param>
    [ChromeProtocol.Core.MethodName("Page.javascriptDialogClosed")]
    public record JavascriptDialogClosed(
      [property: Newtonsoft.Json.JsonProperty("result")]
      bool Result,
      [property: Newtonsoft.Json.JsonProperty("userInput")]
      string UserInput
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to<br/>
    /// open.<br/>
    /// </summary>
    /// <param name="Url">Frame url.</param>
    /// <param name="Message">Message that will be displayed by the dialog.</param>
    /// <param name="Type">Dialog type.</param>
    /// <param name="HasBrowserHandler">
    /// True iff browser is capable showing or acting on the given dialog. When browser has no<br/>
    /// dialog handler for given target, calling alert while Page domain is engaged will stall<br/>
    /// the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.<br/>
    /// </param>
    /// <param name="DefaultPrompt">Default dialog prompt.</param>
    [ChromeProtocol.Core.MethodName("Page.javascriptDialogOpening")]
    public record JavascriptDialogOpening(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("message")]
      string Message,
      [property: Newtonsoft.Json.JsonProperty("type")]
      ChromeProtocol.Domains.Page.DialogTypeType Type,
      [property: Newtonsoft.Json.JsonProperty("hasBrowserHandler")]
      bool HasBrowserHandler,
      [property: Newtonsoft.Json.JsonProperty("defaultPrompt")]
      string? DefaultPrompt = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired for top level page lifecycle events such as navigation, load, paint, etc.</summary>
    /// <param name="FrameId">Id of the frame.</param>
    /// <param name="LoaderId">Loader identifier. Empty string if the request is fetched from worker.</param>
    [ChromeProtocol.Core.MethodName("Page.lifecycleEvent")]
    public record LifecycleEvent(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: Newtonsoft.Json.JsonProperty("name")]
      string Name,
      [property: Newtonsoft.Json.JsonProperty("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do<br/>
    /// not assume any ordering with the Page.frameNavigated event. This event is fired only for<br/>
    /// main-frame history navigation where the document changes (non-same-document navigations),<br/>
    /// when bfcache navigation fails.<br/>
    /// </summary>
    /// <param name="LoaderId">The loader id for the associated navigation.</param>
    /// <param name="FrameId">The frame id of the associated frame.</param>
    /// <param name="NotRestoredExplanations">Array of reasons why the page could not be cached. This must not be empty.</param>
    /// <param name="NotRestoredExplanationsTree">Tree structure of reasons why the page could not be cached for each frame.</param>
    [ChromeProtocol.Core.MethodName("Page.backForwardCacheNotUsed")]
    public record BackForwardCacheNotUsed(
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("notRestoredExplanations")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.BackForwardCacheNotRestoredExplanationType> NotRestoredExplanations,
      [property: Newtonsoft.Json.JsonProperty("notRestoredExplanationsTree")]
      ChromeProtocol.Domains.Page.BackForwardCacheNotRestoredExplanationTreeType? NotRestoredExplanationsTree = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    [ChromeProtocol.Core.MethodName("Page.loadEventFired")]
    public record LoadEventFired(
      [property: Newtonsoft.Json.JsonProperty("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.</summary>
    /// <param name="FrameId">Id of the frame.</param>
    /// <param name="Url">Frame&#39;s new url.</param>
    [ChromeProtocol.Core.MethodName("Page.navigatedWithinDocument")]
    public record NavigatedWithinDocument(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Compressed image data requested by the `startScreencast`.</summary>
    /// <param name="Data">Base64-encoded compressed image. (Encoded as a base64 string when passed over JSON)</param>
    /// <param name="Metadata">Screencast frame metadata.</param>
    /// <param name="SessionId">Frame number.</param>
    [ChromeProtocol.Core.MethodName("Page.screencastFrame")]
    public record ScreencastFrame(
      [property: Newtonsoft.Json.JsonProperty("data")]
      string Data,
      [property: Newtonsoft.Json.JsonProperty("metadata")]
      ChromeProtocol.Domains.Page.ScreencastFrameMetadataType Metadata,
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      int SessionId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when the page with currently enabled screencast was shown or hidden `.</summary>
    /// <param name="Visible">True if the page is visible.</param>
    [ChromeProtocol.Core.MethodName("Page.screencastVisibilityChanged")]
    public record ScreencastVisibilityChanged(
      [property: Newtonsoft.Json.JsonProperty("visible")]
      bool Visible
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when a new window is going to be opened, via window.open(), link click, form submission,<br/>
    /// etc.<br/>
    /// </summary>
    /// <param name="Url">The URL for the new window.</param>
    /// <param name="WindowName">Window name.</param>
    /// <param name="WindowFeatures">An array of enabled window features.</param>
    /// <param name="UserGesture">Whether or not it was triggered by user gesture.</param>
    [ChromeProtocol.Core.MethodName("Page.windowOpen")]
    public record WindowOpen(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("windowName")]
      string WindowName,
      [property: Newtonsoft.Json.JsonProperty("windowFeatures")]
      System.Collections.Generic.IReadOnlyList<string> WindowFeatures,
      [property: Newtonsoft.Json.JsonProperty("userGesture")]
      bool UserGesture
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Issued for every compilation cache generated. Is only available<br/>
    /// if Page.setGenerateCompilationCache is enabled.<br/>
    /// </summary>
    /// <param name="Data">Base64-encoded data (Encoded as a base64 string when passed over JSON)</param>
    [ChromeProtocol.Core.MethodName("Page.compilationCacheProduced")]
    public record CompilationCacheProduced(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("data")]
      string Data
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Deprecated, please use addScriptToEvaluateOnNewDocument instead.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.AddScriptToEvaluateOnLoadRequest AddScriptToEvaluateOnLoad(string ScriptSource)    
    {
      return new ChromeProtocol.Domains.Page.AddScriptToEvaluateOnLoadRequest(ScriptSource);
    }
    /// <summary>Deprecated, please use addScriptToEvaluateOnNewDocument instead.</summary>
    [ChromeProtocol.Core.MethodName("Page.addScriptToEvaluateOnLoad")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record AddScriptToEvaluateOnLoadRequest(
      [property: Newtonsoft.Json.JsonProperty("scriptSource")]
      string ScriptSource
    ) : ChromeProtocol.Core.ICommand<AddScriptToEvaluateOnLoadRequestResult>
    {
    }
    /// <param name="Identifier">Identifier of the added script.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record AddScriptToEvaluateOnLoadRequestResult(
      [property: Newtonsoft.Json.JsonProperty("identifier")]
      ChromeProtocol.Domains.Page.ScriptIdentifierType Identifier
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Evaluates given script in every frame upon creation (before loading frame&#39;s scripts).</summary>
    /// <param name="WorldName">
    /// If specified, creates an isolated world with the given name and evaluates given script in it.<br/>
    /// This world name will be used as the ExecutionContextDescription::name when the corresponding<br/>
    /// event is emitted.<br/>
    /// </param>
    /// <param name="IncludeCommandLineAPI">
    /// Specifies whether command line API should be available to the script, defaults<br/>
    /// to false.<br/>
    /// </param>
    /// <param name="RunImmediately">
    /// If true, runs the script immediately on existing execution contexts or worlds.<br/>
    /// Default: false.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Page.AddScriptToEvaluateOnNewDocumentRequest AddScriptToEvaluateOnNewDocument(string Source, string? WorldName = default, bool? IncludeCommandLineAPI = default, bool? RunImmediately = default)    
    {
      return new ChromeProtocol.Domains.Page.AddScriptToEvaluateOnNewDocumentRequest(Source, WorldName, IncludeCommandLineAPI, RunImmediately);
    }
    /// <summary>Evaluates given script in every frame upon creation (before loading frame&#39;s scripts).</summary>
    /// <param name="WorldName">
    /// If specified, creates an isolated world with the given name and evaluates given script in it.<br/>
    /// This world name will be used as the ExecutionContextDescription::name when the corresponding<br/>
    /// event is emitted.<br/>
    /// </param>
    /// <param name="IncludeCommandLineAPI">
    /// Specifies whether command line API should be available to the script, defaults<br/>
    /// to false.<br/>
    /// </param>
    /// <param name="RunImmediately">
    /// If true, runs the script immediately on existing execution contexts or worlds.<br/>
    /// Default: false.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Page.addScriptToEvaluateOnNewDocument")]
    public record AddScriptToEvaluateOnNewDocumentRequest(
      [property: Newtonsoft.Json.JsonProperty("source")]
      string Source,
      [property: Newtonsoft.Json.JsonProperty("worldName")]
      string? WorldName = default,
      [property: Newtonsoft.Json.JsonProperty("includeCommandLineAPI")]
      bool? IncludeCommandLineAPI = default,
      [property: Newtonsoft.Json.JsonProperty("runImmediately")]
      bool? RunImmediately = default
    ) : ChromeProtocol.Core.ICommand<AddScriptToEvaluateOnNewDocumentRequestResult>
    {
    }
    /// <param name="Identifier">Identifier of the added script.</param>
    public record AddScriptToEvaluateOnNewDocumentRequestResult(
      [property: Newtonsoft.Json.JsonProperty("identifier")]
      ChromeProtocol.Domains.Page.ScriptIdentifierType Identifier
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Brings page to front (activates tab).</summary>
    public static ChromeProtocol.Domains.Page.BringToFrontRequest BringToFront()    
    {
      return new ChromeProtocol.Domains.Page.BringToFrontRequest();
    }
    /// <summary>Brings page to front (activates tab).</summary>
    [ChromeProtocol.Core.MethodName("Page.bringToFront")]
    public record BringToFrontRequest() : ChromeProtocol.Core.ICommand<BringToFrontRequestResult>
    {
    }
    public record BringToFrontRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Capture page screenshot.</summary>
    /// <param name="Format">Image compression format (defaults to png).</param>
    /// <param name="Quality">Compression quality from range [0..100] (jpeg only).</param>
    /// <param name="Clip">Capture the screenshot of a given region only.</param>
    /// <param name="FromSurface">Capture the screenshot from the surface, rather than the view. Defaults to true.</param>
    /// <param name="CaptureBeyondViewport">Capture the screenshot beyond the viewport. Defaults to false.</param>
    /// <param name="OptimizeForSpeed">Optimize image encoding for speed, not for resulting size (defaults to false)</param>
    public static ChromeProtocol.Domains.Page.CaptureScreenshotRequest CaptureScreenshot(string? Format = default, int? Quality = default, ChromeProtocol.Domains.Page.ViewportType? Clip = default, bool? FromSurface = default, bool? CaptureBeyondViewport = default, bool? OptimizeForSpeed = default)    
    {
      return new ChromeProtocol.Domains.Page.CaptureScreenshotRequest(Format, Quality, Clip, FromSurface, CaptureBeyondViewport, OptimizeForSpeed);
    }
    /// <summary>Capture page screenshot.</summary>
    /// <param name="Format">Image compression format (defaults to png).</param>
    /// <param name="Quality">Compression quality from range [0..100] (jpeg only).</param>
    /// <param name="Clip">Capture the screenshot of a given region only.</param>
    /// <param name="FromSurface">Capture the screenshot from the surface, rather than the view. Defaults to true.</param>
    /// <param name="CaptureBeyondViewport">Capture the screenshot beyond the viewport. Defaults to false.</param>
    /// <param name="OptimizeForSpeed">Optimize image encoding for speed, not for resulting size (defaults to false)</param>
    [ChromeProtocol.Core.MethodName("Page.captureScreenshot")]
    public record CaptureScreenshotRequest(
      [property: Newtonsoft.Json.JsonProperty("format")]
      string? Format = default,
      [property: Newtonsoft.Json.JsonProperty("quality")]
      int? Quality = default,
      [property: Newtonsoft.Json.JsonProperty("clip")]
      ChromeProtocol.Domains.Page.ViewportType? Clip = default,
      [property: Newtonsoft.Json.JsonProperty("fromSurface")]
      bool? FromSurface = default,
      [property: Newtonsoft.Json.JsonProperty("captureBeyondViewport")]
      bool? CaptureBeyondViewport = default,
      [property: Newtonsoft.Json.JsonProperty("optimizeForSpeed")]
      bool? OptimizeForSpeed = default
    ) : ChromeProtocol.Core.ICommand<CaptureScreenshotRequestResult>
    {
    }
    /// <param name="Data">Base64-encoded image data. (Encoded as a base64 string when passed over JSON)</param>
    public record CaptureScreenshotRequestResult(
      [property: Newtonsoft.Json.JsonProperty("data")]
      string Data
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns a snapshot of the page as a string. For MHTML format, the serialization includes<br/>
    /// iframes, shadow DOM, external resources, and element-inline styles.<br/>
    /// </summary>
    /// <param name="Format">Format (defaults to mhtml).</param>
    public static ChromeProtocol.Domains.Page.CaptureSnapshotRequest CaptureSnapshot(string? Format = default)    
    {
      return new ChromeProtocol.Domains.Page.CaptureSnapshotRequest(Format);
    }
    /// <summary>
    /// Returns a snapshot of the page as a string. For MHTML format, the serialization includes<br/>
    /// iframes, shadow DOM, external resources, and element-inline styles.<br/>
    /// </summary>
    /// <param name="Format">Format (defaults to mhtml).</param>
    [ChromeProtocol.Core.MethodName("Page.captureSnapshot")]
    public record CaptureSnapshotRequest(
      [property: Newtonsoft.Json.JsonProperty("format")]
      string? Format = default
    ) : ChromeProtocol.Core.ICommand<CaptureSnapshotRequestResult>
    {
    }
    /// <param name="Data">Serialized page data.</param>
    public record CaptureSnapshotRequestResult(
      [property: Newtonsoft.Json.JsonProperty("data")]
      string Data
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears the overridden device metrics.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.ClearDeviceMetricsOverrideRequest ClearDeviceMetricsOverride()    
    {
      return new ChromeProtocol.Domains.Page.ClearDeviceMetricsOverrideRequest();
    }
    /// <summary>Clears the overridden device metrics.</summary>
    [ChromeProtocol.Core.MethodName("Page.clearDeviceMetricsOverride")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ClearDeviceMetricsOverrideRequest() : ChromeProtocol.Core.ICommand<ClearDeviceMetricsOverrideRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ClearDeviceMetricsOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears the overridden Device Orientation.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.ClearDeviceOrientationOverrideRequest ClearDeviceOrientationOverride()    
    {
      return new ChromeProtocol.Domains.Page.ClearDeviceOrientationOverrideRequest();
    }
    /// <summary>Clears the overridden Device Orientation.</summary>
    [ChromeProtocol.Core.MethodName("Page.clearDeviceOrientationOverride")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ClearDeviceOrientationOverrideRequest() : ChromeProtocol.Core.ICommand<ClearDeviceOrientationOverrideRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ClearDeviceOrientationOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears the overridden Geolocation Position and Error.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.ClearGeolocationOverrideRequest ClearGeolocationOverride()    
    {
      return new ChromeProtocol.Domains.Page.ClearGeolocationOverrideRequest();
    }
    /// <summary>Clears the overridden Geolocation Position and Error.</summary>
    [ChromeProtocol.Core.MethodName("Page.clearGeolocationOverride")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ClearGeolocationOverrideRequest() : ChromeProtocol.Core.ICommand<ClearGeolocationOverrideRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ClearGeolocationOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Creates an isolated world for the given frame.</summary>
    /// <param name="FrameId">Id of the frame in which the isolated world should be created.</param>
    /// <param name="WorldName">An optional name which is reported in the Execution Context.</param>
    /// <param name="GrantUniveralAccess">
    /// Whether or not universal access should be granted to the isolated world. This is a powerful<br/>
    /// option, use with caution.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Page.CreateIsolatedWorldRequest CreateIsolatedWorld(ChromeProtocol.Domains.Page.FrameIdType FrameId, string? WorldName = default, bool? GrantUniveralAccess = default)    
    {
      return new ChromeProtocol.Domains.Page.CreateIsolatedWorldRequest(FrameId, WorldName, GrantUniveralAccess);
    }
    /// <summary>Creates an isolated world for the given frame.</summary>
    /// <param name="FrameId">Id of the frame in which the isolated world should be created.</param>
    /// <param name="WorldName">An optional name which is reported in the Execution Context.</param>
    /// <param name="GrantUniveralAccess">
    /// Whether or not universal access should be granted to the isolated world. This is a powerful<br/>
    /// option, use with caution.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Page.createIsolatedWorld")]
    public record CreateIsolatedWorldRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("worldName")]
      string? WorldName = default,
      [property: Newtonsoft.Json.JsonProperty("grantUniveralAccess")]
      bool? GrantUniveralAccess = default
    ) : ChromeProtocol.Core.ICommand<CreateIsolatedWorldRequestResult>
    {
    }
    /// <param name="ExecutionContextId">Execution context of the isolated world.</param>
    public record CreateIsolatedWorldRequestResult(
      [property: Newtonsoft.Json.JsonProperty("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType ExecutionContextId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Deletes browser cookie with given name, domain and path.</summary>
    /// <param name="CookieName">Name of the cookie to remove.</param>
    /// <param name="Url">URL to match cooke domain and path.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.DeleteCookieRequest DeleteCookie(string CookieName, string Url)    
    {
      return new ChromeProtocol.Domains.Page.DeleteCookieRequest(CookieName, Url);
    }
    /// <summary>Deletes browser cookie with given name, domain and path.</summary>
    /// <param name="CookieName">Name of the cookie to remove.</param>
    /// <param name="Url">URL to match cooke domain and path.</param>
    [ChromeProtocol.Core.MethodName("Page.deleteCookie")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record DeleteCookieRequest(
      [property: Newtonsoft.Json.JsonProperty("cookieName")]
      string CookieName,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url
    ) : ChromeProtocol.Core.ICommand<DeleteCookieRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record DeleteCookieRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Disables page domain notifications.</summary>
    public static ChromeProtocol.Domains.Page.DisableRequest Disable()    
    {
      return new ChromeProtocol.Domains.Page.DisableRequest();
    }
    /// <summary>Disables page domain notifications.</summary>
    [ChromeProtocol.Core.MethodName("Page.disable")]
    public record DisableRequest() : ChromeProtocol.Core.ICommand<DisableRequestResult>
    {
    }
    public record DisableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enables page domain notifications.</summary>
    public static ChromeProtocol.Domains.Page.EnableRequest Enable()    
    {
      return new ChromeProtocol.Domains.Page.EnableRequest();
    }
    /// <summary>Enables page domain notifications.</summary>
    [ChromeProtocol.Core.MethodName("Page.enable")]
    public record EnableRequest() : ChromeProtocol.Core.ICommand<EnableRequestResult>
    {
    }
    public record EnableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    public static ChromeProtocol.Domains.Page.GetAppManifestRequest GetAppManifest()    
    {
      return new ChromeProtocol.Domains.Page.GetAppManifestRequest();
    }
    [ChromeProtocol.Core.MethodName("Page.getAppManifest")]
    public record GetAppManifestRequest() : ChromeProtocol.Core.ICommand<GetAppManifestRequestResult>
    {
    }
    /// <param name="Url">Manifest location.</param>
    /// <param name="Data">Manifest content.</param>
    /// <param name="Parsed">Parsed manifest properties</param>
    public record GetAppManifestRequestResult(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("errors")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.AppManifestErrorType> Errors,
      [property: Newtonsoft.Json.JsonProperty("data")]
      string? Data = default,
      [property: Newtonsoft.Json.JsonProperty("parsed")]
      ChromeProtocol.Domains.Page.AppManifestParsedPropertiesType? Parsed = default
    ) : ChromeProtocol.Core.IType
    {
    }
    public static ChromeProtocol.Domains.Page.GetInstallabilityErrorsRequest GetInstallabilityErrors()    
    {
      return new ChromeProtocol.Domains.Page.GetInstallabilityErrorsRequest();
    }
    [ChromeProtocol.Core.MethodName("Page.getInstallabilityErrors")]
    public record GetInstallabilityErrorsRequest() : ChromeProtocol.Core.ICommand<GetInstallabilityErrorsRequestResult>
    {
    }
    public record GetInstallabilityErrorsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("installabilityErrors")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.InstallabilityErrorType> InstallabilityErrors
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Deprecated because it&#39;s not guaranteed that the returned icon is in fact the one used for PWA installation.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.GetManifestIconsRequest GetManifestIcons()    
    {
      return new ChromeProtocol.Domains.Page.GetManifestIconsRequest();
    }
    /// <summary>Deprecated because it&#39;s not guaranteed that the returned icon is in fact the one used for PWA installation.</summary>
    [ChromeProtocol.Core.MethodName("Page.getManifestIcons")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetManifestIconsRequest() : ChromeProtocol.Core.ICommand<GetManifestIconsRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetManifestIconsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("primaryIcon")]
      string? PrimaryIcon = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the unique (PWA) app id.<br/>
    /// Only returns values if the feature flag &#39;WebAppEnableManifestId&#39; is enabled<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Page.GetAppIdRequest GetAppId()    
    {
      return new ChromeProtocol.Domains.Page.GetAppIdRequest();
    }
    /// <summary>
    /// Returns the unique (PWA) app id.<br/>
    /// Only returns values if the feature flag &#39;WebAppEnableManifestId&#39; is enabled<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Page.getAppId")]
    public record GetAppIdRequest() : ChromeProtocol.Core.ICommand<GetAppIdRequestResult>
    {
    }
    /// <param name="AppId">App id, either from manifest&#39;s id attribute or computed from start_url</param>
    /// <param name="RecommendedId">Recommendation for manifest&#39;s id attribute to match current id computed from start_url</param>
    public record GetAppIdRequestResult(
      [property: Newtonsoft.Json.JsonProperty("appId")]
      string? AppId = default,
      [property: Newtonsoft.Json.JsonProperty("recommendedId")]
      string? RecommendedId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    public static ChromeProtocol.Domains.Page.GetAdScriptIdRequest GetAdScriptId(ChromeProtocol.Domains.Page.FrameIdType FrameId)    
    {
      return new ChromeProtocol.Domains.Page.GetAdScriptIdRequest(FrameId);
    }
    [ChromeProtocol.Core.MethodName("Page.getAdScriptId")]
    public record GetAdScriptIdRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.ICommand<GetAdScriptIdRequestResult>
    {
    }
    /// <param name="AdScriptId">
    /// Identifies the bottom-most script which caused the frame to be labelled<br/>
    /// as an ad. Only sent if frame is labelled as an ad and id is available.<br/>
    /// </param>
    public record GetAdScriptIdRequestResult(
      [property: Newtonsoft.Json.JsonProperty("adScriptId")]
      ChromeProtocol.Domains.Page.AdScriptIdType? AdScriptId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns present frame tree structure.</summary>
    public static ChromeProtocol.Domains.Page.GetFrameTreeRequest GetFrameTree()    
    {
      return new ChromeProtocol.Domains.Page.GetFrameTreeRequest();
    }
    /// <summary>Returns present frame tree structure.</summary>
    [ChromeProtocol.Core.MethodName("Page.getFrameTree")]
    public record GetFrameTreeRequest() : ChromeProtocol.Core.ICommand<GetFrameTreeRequestResult>
    {
    }
    /// <param name="FrameTree">Present frame tree structure.</param>
    public record GetFrameTreeRequestResult(
      [property: Newtonsoft.Json.JsonProperty("frameTree")]
      ChromeProtocol.Domains.Page.FrameTreeType FrameTree
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns metrics relating to the layouting of the page, such as viewport bounds/scale.</summary>
    public static ChromeProtocol.Domains.Page.GetLayoutMetricsRequest GetLayoutMetrics()    
    {
      return new ChromeProtocol.Domains.Page.GetLayoutMetricsRequest();
    }
    /// <summary>Returns metrics relating to the layouting of the page, such as viewport bounds/scale.</summary>
    [ChromeProtocol.Core.MethodName("Page.getLayoutMetrics")]
    public record GetLayoutMetricsRequest() : ChromeProtocol.Core.ICommand<GetLayoutMetricsRequestResult>
    {
    }
    /// <param name="LayoutViewport">Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.</param>
    /// <param name="VisualViewport">Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.</param>
    /// <param name="ContentSize">Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.</param>
    /// <param name="CssLayoutViewport">Metrics relating to the layout viewport in CSS pixels.</param>
    /// <param name="CssVisualViewport">Metrics relating to the visual viewport in CSS pixels.</param>
    /// <param name="CssContentSize">Size of scrollable area in CSS pixels.</param>
    public record GetLayoutMetricsRequestResult(
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("layoutViewport")]
      ChromeProtocol.Domains.Page.LayoutViewportType LayoutViewport,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("visualViewport")]
      ChromeProtocol.Domains.Page.VisualViewportType VisualViewport,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("contentSize")]
      ChromeProtocol.Domains.DOM.RectType ContentSize,
      [property: Newtonsoft.Json.JsonProperty("cssLayoutViewport")]
      ChromeProtocol.Domains.Page.LayoutViewportType CssLayoutViewport,
      [property: Newtonsoft.Json.JsonProperty("cssVisualViewport")]
      ChromeProtocol.Domains.Page.VisualViewportType CssVisualViewport,
      [property: Newtonsoft.Json.JsonProperty("cssContentSize")]
      ChromeProtocol.Domains.DOM.RectType CssContentSize
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns navigation history for the current page.</summary>
    public static ChromeProtocol.Domains.Page.GetNavigationHistoryRequest GetNavigationHistory()    
    {
      return new ChromeProtocol.Domains.Page.GetNavigationHistoryRequest();
    }
    /// <summary>Returns navigation history for the current page.</summary>
    [ChromeProtocol.Core.MethodName("Page.getNavigationHistory")]
    public record GetNavigationHistoryRequest() : ChromeProtocol.Core.ICommand<GetNavigationHistoryRequestResult>
    {
    }
    /// <param name="CurrentIndex">Index of the current navigation history entry.</param>
    /// <param name="Entries">Array of navigation history entries.</param>
    public record GetNavigationHistoryRequestResult(
      [property: Newtonsoft.Json.JsonProperty("currentIndex")]
      int CurrentIndex,
      [property: Newtonsoft.Json.JsonProperty("entries")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.NavigationEntryType> Entries
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Resets navigation history for the current page.</summary>
    public static ChromeProtocol.Domains.Page.ResetNavigationHistoryRequest ResetNavigationHistory()    
    {
      return new ChromeProtocol.Domains.Page.ResetNavigationHistoryRequest();
    }
    /// <summary>Resets navigation history for the current page.</summary>
    [ChromeProtocol.Core.MethodName("Page.resetNavigationHistory")]
    public record ResetNavigationHistoryRequest() : ChromeProtocol.Core.ICommand<ResetNavigationHistoryRequestResult>
    {
    }
    public record ResetNavigationHistoryRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns content of the given resource.</summary>
    /// <param name="FrameId">Frame id to get resource for.</param>
    /// <param name="Url">URL of the resource to get content for.</param>
    public static ChromeProtocol.Domains.Page.GetResourceContentRequest GetResourceContent(ChromeProtocol.Domains.Page.FrameIdType FrameId, string Url)    
    {
      return new ChromeProtocol.Domains.Page.GetResourceContentRequest(FrameId, Url);
    }
    /// <summary>Returns content of the given resource.</summary>
    /// <param name="FrameId">Frame id to get resource for.</param>
    /// <param name="Url">URL of the resource to get content for.</param>
    [ChromeProtocol.Core.MethodName("Page.getResourceContent")]
    public record GetResourceContentRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url
    ) : ChromeProtocol.Core.ICommand<GetResourceContentRequestResult>
    {
    }
    /// <param name="Content">Resource content.</param>
    /// <param name="Base64Encoded">True, if content was served as base64.</param>
    public record GetResourceContentRequestResult(
      [property: Newtonsoft.Json.JsonProperty("content")]
      string Content,
      [property: Newtonsoft.Json.JsonProperty("base64Encoded")]
      bool Base64Encoded
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns present frame / resource tree structure.</summary>
    public static ChromeProtocol.Domains.Page.GetResourceTreeRequest GetResourceTree()    
    {
      return new ChromeProtocol.Domains.Page.GetResourceTreeRequest();
    }
    /// <summary>Returns present frame / resource tree structure.</summary>
    [ChromeProtocol.Core.MethodName("Page.getResourceTree")]
    public record GetResourceTreeRequest() : ChromeProtocol.Core.ICommand<GetResourceTreeRequestResult>
    {
    }
    /// <param name="FrameTree">Present frame / resource tree structure.</param>
    public record GetResourceTreeRequestResult(
      [property: Newtonsoft.Json.JsonProperty("frameTree")]
      ChromeProtocol.Domains.Page.FrameResourceTreeType FrameTree
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).</summary>
    /// <param name="Accept">Whether to accept or dismiss the dialog.</param>
    /// <param name="PromptText">
    /// The text to enter into the dialog prompt before accepting. Used only if this is a prompt<br/>
    /// dialog.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Page.HandleJavaScriptDialogRequest HandleJavaScriptDialog(bool Accept, string? PromptText = default)    
    {
      return new ChromeProtocol.Domains.Page.HandleJavaScriptDialogRequest(Accept, PromptText);
    }
    /// <summary>Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).</summary>
    /// <param name="Accept">Whether to accept or dismiss the dialog.</param>
    /// <param name="PromptText">
    /// The text to enter into the dialog prompt before accepting. Used only if this is a prompt<br/>
    /// dialog.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Page.handleJavaScriptDialog")]
    public record HandleJavaScriptDialogRequest(
      [property: Newtonsoft.Json.JsonProperty("accept")]
      bool Accept,
      [property: Newtonsoft.Json.JsonProperty("promptText")]
      string? PromptText = default
    ) : ChromeProtocol.Core.ICommand<HandleJavaScriptDialogRequestResult>
    {
    }
    public record HandleJavaScriptDialogRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Navigates current page to the given URL.</summary>
    /// <param name="Url">URL to navigate the page to.</param>
    /// <param name="Referrer">Referrer URL.</param>
    /// <param name="TransitionType">Intended transition type.</param>
    /// <param name="FrameId">Frame id to navigate, if not specified navigates the top frame.</param>
    /// <param name="ReferrerPolicy">Referrer-policy used for the navigation.</param>
    public static ChromeProtocol.Domains.Page.NavigateRequest Navigate(string Url, string? Referrer = default, ChromeProtocol.Domains.Page.TransitionTypeType? TransitionType = default, ChromeProtocol.Domains.Page.FrameIdType? FrameId = default, ChromeProtocol.Domains.Page.ReferrerPolicyType? ReferrerPolicy = default)    
    {
      return new ChromeProtocol.Domains.Page.NavigateRequest(Url, Referrer, TransitionType, FrameId, ReferrerPolicy);
    }
    /// <summary>Navigates current page to the given URL.</summary>
    /// <param name="Url">URL to navigate the page to.</param>
    /// <param name="Referrer">Referrer URL.</param>
    /// <param name="TransitionType">Intended transition type.</param>
    /// <param name="FrameId">Frame id to navigate, if not specified navigates the top frame.</param>
    /// <param name="ReferrerPolicy">Referrer-policy used for the navigation.</param>
    [ChromeProtocol.Core.MethodName("Page.navigate")]
    public record NavigateRequest(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("referrer")]
      string? Referrer = default,
      [property: Newtonsoft.Json.JsonProperty("transitionType")]
      ChromeProtocol.Domains.Page.TransitionTypeType? TransitionType = default,
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType? FrameId = default,
      [property: Newtonsoft.Json.JsonProperty("referrerPolicy")]
      ChromeProtocol.Domains.Page.ReferrerPolicyType? ReferrerPolicy = default
    ) : ChromeProtocol.Core.ICommand<NavigateRequestResult>
    {
    }
    /// <param name="FrameId">Frame id that has navigated (or failed to navigate)</param>
    /// <param name="LoaderId">
    /// Loader identifier. This is omitted in case of same-document navigation,<br/>
    /// as the previously committed loaderId would not change.<br/>
    /// </param>
    /// <param name="ErrorText">User friendly error message, present if and only if navigation has failed.</param>
    public record NavigateRequestResult(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType? LoaderId = default,
      [property: Newtonsoft.Json.JsonProperty("errorText")]
      string? ErrorText = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Navigates current page to the given history entry.</summary>
    /// <param name="EntryId">Unique id of the entry to navigate to.</param>
    public static ChromeProtocol.Domains.Page.NavigateToHistoryEntryRequest NavigateToHistoryEntry(int EntryId)    
    {
      return new ChromeProtocol.Domains.Page.NavigateToHistoryEntryRequest(EntryId);
    }
    /// <summary>Navigates current page to the given history entry.</summary>
    /// <param name="EntryId">Unique id of the entry to navigate to.</param>
    [ChromeProtocol.Core.MethodName("Page.navigateToHistoryEntry")]
    public record NavigateToHistoryEntryRequest(
      [property: Newtonsoft.Json.JsonProperty("entryId")]
      int EntryId
    ) : ChromeProtocol.Core.ICommand<NavigateToHistoryEntryRequestResult>
    {
    }
    public record NavigateToHistoryEntryRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Print page as PDF.</summary>
    /// <param name="Landscape">Paper orientation. Defaults to false.</param>
    /// <param name="DisplayHeaderFooter">Display header and footer. Defaults to false.</param>
    /// <param name="PrintBackground">Print background graphics. Defaults to false.</param>
    /// <param name="Scale">Scale of the webpage rendering. Defaults to 1.</param>
    /// <param name="PaperWidth">Paper width in inches. Defaults to 8.5 inches.</param>
    /// <param name="PaperHeight">Paper height in inches. Defaults to 11 inches.</param>
    /// <param name="MarginTop">Top margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="MarginBottom">Bottom margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="MarginLeft">Left margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="MarginRight">Right margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="PageRanges">
    /// Paper ranges to print, one based, e.g., &#39;1-5, 8, 11-13&#39;. Pages are<br/>
    /// printed in the document order, not in the order specified, and no<br/>
    /// more than once.<br/>
    /// Defaults to empty string, which implies the entire document is printed.<br/>
    /// The page numbers are quietly capped to actual page count of the<br/>
    /// document, and ranges beyond the end of the document are ignored.<br/>
    /// If this results in no pages to print, an error is reported.<br/>
    /// It is an error to specify a range with start greater than end.<br/>
    /// </param>
    /// <param name="HeaderTemplate">
    /// HTML template for the print header. Should be valid HTML markup with following<br/>
    /// classes used to inject printing values into them:<br/>
    /// - `date`: formatted print date<br/>
    /// - `title`: document title<br/>
    /// - `url`: document location<br/>
    /// - `pageNumber`: current page number<br/>
    /// - `totalPages`: total pages in the document<br/>
    /// For example, `&lt;span class=title&gt;&lt;/span&gt;` would generate span containing the title.<br/>
    /// </param>
    /// <param name="FooterTemplate">HTML template for the print footer. Should use the same format as the `headerTemplate`.</param>
    /// <param name="PreferCSSPageSize">
    /// Whether or not to prefer page size as defined by css. Defaults to false,<br/>
    /// in which case the content will be scaled to fit the paper size.<br/>
    /// </param>
    /// <param name="TransferMode">return as stream</param>
    /// <param name="GenerateTaggedPDF">Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.</param>
    /// <param name="GenerateDocumentOutline">Whether or not to embed the document outline into the PDF.</param>
    public static ChromeProtocol.Domains.Page.PrintToPDFRequest PrintToPDF(bool? Landscape = default, bool? DisplayHeaderFooter = default, bool? PrintBackground = default, double? Scale = default, double? PaperWidth = default, double? PaperHeight = default, double? MarginTop = default, double? MarginBottom = default, double? MarginLeft = default, double? MarginRight = default, string? PageRanges = default, string? HeaderTemplate = default, string? FooterTemplate = default, bool? PreferCSSPageSize = default, string? TransferMode = default, bool? GenerateTaggedPDF = default, bool? GenerateDocumentOutline = default)    
    {
      return new ChromeProtocol.Domains.Page.PrintToPDFRequest(Landscape, DisplayHeaderFooter, PrintBackground, Scale, PaperWidth, PaperHeight, MarginTop, MarginBottom, MarginLeft, MarginRight, PageRanges, HeaderTemplate, FooterTemplate, PreferCSSPageSize, TransferMode, GenerateTaggedPDF, GenerateDocumentOutline);
    }
    /// <summary>Print page as PDF.</summary>
    /// <param name="Landscape">Paper orientation. Defaults to false.</param>
    /// <param name="DisplayHeaderFooter">Display header and footer. Defaults to false.</param>
    /// <param name="PrintBackground">Print background graphics. Defaults to false.</param>
    /// <param name="Scale">Scale of the webpage rendering. Defaults to 1.</param>
    /// <param name="PaperWidth">Paper width in inches. Defaults to 8.5 inches.</param>
    /// <param name="PaperHeight">Paper height in inches. Defaults to 11 inches.</param>
    /// <param name="MarginTop">Top margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="MarginBottom">Bottom margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="MarginLeft">Left margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="MarginRight">Right margin in inches. Defaults to 1cm (~0.4 inches).</param>
    /// <param name="PageRanges">
    /// Paper ranges to print, one based, e.g., &#39;1-5, 8, 11-13&#39;. Pages are<br/>
    /// printed in the document order, not in the order specified, and no<br/>
    /// more than once.<br/>
    /// Defaults to empty string, which implies the entire document is printed.<br/>
    /// The page numbers are quietly capped to actual page count of the<br/>
    /// document, and ranges beyond the end of the document are ignored.<br/>
    /// If this results in no pages to print, an error is reported.<br/>
    /// It is an error to specify a range with start greater than end.<br/>
    /// </param>
    /// <param name="HeaderTemplate">
    /// HTML template for the print header. Should be valid HTML markup with following<br/>
    /// classes used to inject printing values into them:<br/>
    /// - `date`: formatted print date<br/>
    /// - `title`: document title<br/>
    /// - `url`: document location<br/>
    /// - `pageNumber`: current page number<br/>
    /// - `totalPages`: total pages in the document<br/>
    /// For example, `&lt;span class=title&gt;&lt;/span&gt;` would generate span containing the title.<br/>
    /// </param>
    /// <param name="FooterTemplate">HTML template for the print footer. Should use the same format as the `headerTemplate`.</param>
    /// <param name="PreferCSSPageSize">
    /// Whether or not to prefer page size as defined by css. Defaults to false,<br/>
    /// in which case the content will be scaled to fit the paper size.<br/>
    /// </param>
    /// <param name="TransferMode">return as stream</param>
    /// <param name="GenerateTaggedPDF">Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.</param>
    /// <param name="GenerateDocumentOutline">Whether or not to embed the document outline into the PDF.</param>
    [ChromeProtocol.Core.MethodName("Page.printToPDF")]
    public record PrintToPDFRequest(
      [property: Newtonsoft.Json.JsonProperty("landscape")]
      bool? Landscape = default,
      [property: Newtonsoft.Json.JsonProperty("displayHeaderFooter")]
      bool? DisplayHeaderFooter = default,
      [property: Newtonsoft.Json.JsonProperty("printBackground")]
      bool? PrintBackground = default,
      [property: Newtonsoft.Json.JsonProperty("scale")]
      double? Scale = default,
      [property: Newtonsoft.Json.JsonProperty("paperWidth")]
      double? PaperWidth = default,
      [property: Newtonsoft.Json.JsonProperty("paperHeight")]
      double? PaperHeight = default,
      [property: Newtonsoft.Json.JsonProperty("marginTop")]
      double? MarginTop = default,
      [property: Newtonsoft.Json.JsonProperty("marginBottom")]
      double? MarginBottom = default,
      [property: Newtonsoft.Json.JsonProperty("marginLeft")]
      double? MarginLeft = default,
      [property: Newtonsoft.Json.JsonProperty("marginRight")]
      double? MarginRight = default,
      [property: Newtonsoft.Json.JsonProperty("pageRanges")]
      string? PageRanges = default,
      [property: Newtonsoft.Json.JsonProperty("headerTemplate")]
      string? HeaderTemplate = default,
      [property: Newtonsoft.Json.JsonProperty("footerTemplate")]
      string? FooterTemplate = default,
      [property: Newtonsoft.Json.JsonProperty("preferCSSPageSize")]
      bool? PreferCSSPageSize = default,
      [property: Newtonsoft.Json.JsonProperty("transferMode")]
      string? TransferMode = default,
      [property: Newtonsoft.Json.JsonProperty("generateTaggedPDF")]
      bool? GenerateTaggedPDF = default,
      [property: Newtonsoft.Json.JsonProperty("generateDocumentOutline")]
      bool? GenerateDocumentOutline = default
    ) : ChromeProtocol.Core.ICommand<PrintToPDFRequestResult>
    {
    }
    /// <param name="Data">Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)</param>
    /// <param name="Stream">A handle of the stream that holds resulting PDF data.</param>
    public record PrintToPDFRequestResult(
      [property: Newtonsoft.Json.JsonProperty("data")]
      string Data,
      [property: Newtonsoft.Json.JsonProperty("stream")]
      ChromeProtocol.Domains.IO.StreamHandleType? Stream = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Reloads given page optionally ignoring the cache.</summary>
    /// <param name="IgnoreCache">If true, browser cache is ignored (as if the user pressed Shift+refresh).</param>
    /// <param name="ScriptToEvaluateOnLoad">
    /// If set, the script will be injected into all frames of the inspected page after reload.<br/>
    /// Argument will be ignored if reloading dataURL origin.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Page.ReloadRequest Reload(bool? IgnoreCache = default, string? ScriptToEvaluateOnLoad = default)    
    {
      return new ChromeProtocol.Domains.Page.ReloadRequest(IgnoreCache, ScriptToEvaluateOnLoad);
    }
    /// <summary>Reloads given page optionally ignoring the cache.</summary>
    /// <param name="IgnoreCache">If true, browser cache is ignored (as if the user pressed Shift+refresh).</param>
    /// <param name="ScriptToEvaluateOnLoad">
    /// If set, the script will be injected into all frames of the inspected page after reload.<br/>
    /// Argument will be ignored if reloading dataURL origin.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Page.reload")]
    public record ReloadRequest(
      [property: Newtonsoft.Json.JsonProperty("ignoreCache")]
      bool? IgnoreCache = default,
      [property: Newtonsoft.Json.JsonProperty("scriptToEvaluateOnLoad")]
      string? ScriptToEvaluateOnLoad = default
    ) : ChromeProtocol.Core.ICommand<ReloadRequestResult>
    {
    }
    public record ReloadRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Deprecated, please use removeScriptToEvaluateOnNewDocument instead.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.RemoveScriptToEvaluateOnLoadRequest RemoveScriptToEvaluateOnLoad(ChromeProtocol.Domains.Page.ScriptIdentifierType Identifier)    
    {
      return new ChromeProtocol.Domains.Page.RemoveScriptToEvaluateOnLoadRequest(Identifier);
    }
    /// <summary>Deprecated, please use removeScriptToEvaluateOnNewDocument instead.</summary>
    [ChromeProtocol.Core.MethodName("Page.removeScriptToEvaluateOnLoad")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record RemoveScriptToEvaluateOnLoadRequest(
      [property: Newtonsoft.Json.JsonProperty("identifier")]
      ChromeProtocol.Domains.Page.ScriptIdentifierType Identifier
    ) : ChromeProtocol.Core.ICommand<RemoveScriptToEvaluateOnLoadRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record RemoveScriptToEvaluateOnLoadRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Removes given script from the list.</summary>
    public static ChromeProtocol.Domains.Page.RemoveScriptToEvaluateOnNewDocumentRequest RemoveScriptToEvaluateOnNewDocument(ChromeProtocol.Domains.Page.ScriptIdentifierType Identifier)    
    {
      return new ChromeProtocol.Domains.Page.RemoveScriptToEvaluateOnNewDocumentRequest(Identifier);
    }
    /// <summary>Removes given script from the list.</summary>
    [ChromeProtocol.Core.MethodName("Page.removeScriptToEvaluateOnNewDocument")]
    public record RemoveScriptToEvaluateOnNewDocumentRequest(
      [property: Newtonsoft.Json.JsonProperty("identifier")]
      ChromeProtocol.Domains.Page.ScriptIdentifierType Identifier
    ) : ChromeProtocol.Core.ICommand<RemoveScriptToEvaluateOnNewDocumentRequestResult>
    {
    }
    public record RemoveScriptToEvaluateOnNewDocumentRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Acknowledges that a screencast frame has been received by the frontend.</summary>
    /// <param name="SessionId">Frame number.</param>
    public static ChromeProtocol.Domains.Page.ScreencastFrameAckRequest ScreencastFrameAck(int SessionId)    
    {
      return new ChromeProtocol.Domains.Page.ScreencastFrameAckRequest(SessionId);
    }
    /// <summary>Acknowledges that a screencast frame has been received by the frontend.</summary>
    /// <param name="SessionId">Frame number.</param>
    [ChromeProtocol.Core.MethodName("Page.screencastFrameAck")]
    public record ScreencastFrameAckRequest(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      int SessionId
    ) : ChromeProtocol.Core.ICommand<ScreencastFrameAckRequestResult>
    {
    }
    public record ScreencastFrameAckRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Searches for given string in resource content.</summary>
    /// <param name="FrameId">Frame id for resource to search in.</param>
    /// <param name="Url">URL of the resource to search in.</param>
    /// <param name="Query">String to search for.</param>
    /// <param name="CaseSensitive">If true, search is case sensitive.</param>
    /// <param name="IsRegex">If true, treats string parameter as regex.</param>
    public static ChromeProtocol.Domains.Page.SearchInResourceRequest SearchInResource(ChromeProtocol.Domains.Page.FrameIdType FrameId, string Url, string Query, bool? CaseSensitive = default, bool? IsRegex = default)    
    {
      return new ChromeProtocol.Domains.Page.SearchInResourceRequest(FrameId, Url, Query, CaseSensitive, IsRegex);
    }
    /// <summary>Searches for given string in resource content.</summary>
    /// <param name="FrameId">Frame id for resource to search in.</param>
    /// <param name="Url">URL of the resource to search in.</param>
    /// <param name="Query">String to search for.</param>
    /// <param name="CaseSensitive">If true, search is case sensitive.</param>
    /// <param name="IsRegex">If true, treats string parameter as regex.</param>
    [ChromeProtocol.Core.MethodName("Page.searchInResource")]
    public record SearchInResourceRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("query")]
      string Query,
      [property: Newtonsoft.Json.JsonProperty("caseSensitive")]
      bool? CaseSensitive = default,
      [property: Newtonsoft.Json.JsonProperty("isRegex")]
      bool? IsRegex = default
    ) : ChromeProtocol.Core.ICommand<SearchInResourceRequestResult>
    {
    }
    /// <param name="Result">List of search matches.</param>
    public record SearchInResourceRequestResult(
      [property: Newtonsoft.Json.JsonProperty("result")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.SearchMatchType> Result
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enable Chrome&#39;s experimental ad filter on all sites.</summary>
    /// <param name="Enabled">Whether to block ads.</param>
    public static ChromeProtocol.Domains.Page.SetAdBlockingEnabledRequest SetAdBlockingEnabled(bool Enabled)    
    {
      return new ChromeProtocol.Domains.Page.SetAdBlockingEnabledRequest(Enabled);
    }
    /// <summary>Enable Chrome&#39;s experimental ad filter on all sites.</summary>
    /// <param name="Enabled">Whether to block ads.</param>
    [ChromeProtocol.Core.MethodName("Page.setAdBlockingEnabled")]
    public record SetAdBlockingEnabledRequest(
      [property: Newtonsoft.Json.JsonProperty("enabled")]
      bool Enabled
    ) : ChromeProtocol.Core.ICommand<SetAdBlockingEnabledRequestResult>
    {
    }
    public record SetAdBlockingEnabledRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enable page Content Security Policy by-passing.</summary>
    /// <param name="Enabled">Whether to bypass page CSP.</param>
    public static ChromeProtocol.Domains.Page.SetBypassCSPRequest SetBypassCSP(bool Enabled)    
    {
      return new ChromeProtocol.Domains.Page.SetBypassCSPRequest(Enabled);
    }
    /// <summary>Enable page Content Security Policy by-passing.</summary>
    /// <param name="Enabled">Whether to bypass page CSP.</param>
    [ChromeProtocol.Core.MethodName("Page.setBypassCSP")]
    public record SetBypassCSPRequest(
      [property: Newtonsoft.Json.JsonProperty("enabled")]
      bool Enabled
    ) : ChromeProtocol.Core.ICommand<SetBypassCSPRequestResult>
    {
    }
    public record SetBypassCSPRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Get Permissions Policy state on given frame.</summary>
    public static ChromeProtocol.Domains.Page.GetPermissionsPolicyStateRequest GetPermissionsPolicyState(ChromeProtocol.Domains.Page.FrameIdType FrameId)    
    {
      return new ChromeProtocol.Domains.Page.GetPermissionsPolicyStateRequest(FrameId);
    }
    /// <summary>Get Permissions Policy state on given frame.</summary>
    [ChromeProtocol.Core.MethodName("Page.getPermissionsPolicyState")]
    public record GetPermissionsPolicyStateRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.ICommand<GetPermissionsPolicyStateRequestResult>
    {
    }
    public record GetPermissionsPolicyStateRequestResult(
      [property: Newtonsoft.Json.JsonProperty("states")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.PermissionsPolicyFeatureStateType> States
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Get Origin Trials on given frame.</summary>
    public static ChromeProtocol.Domains.Page.GetOriginTrialsRequest GetOriginTrials(ChromeProtocol.Domains.Page.FrameIdType FrameId)    
    {
      return new ChromeProtocol.Domains.Page.GetOriginTrialsRequest(FrameId);
    }
    /// <summary>Get Origin Trials on given frame.</summary>
    [ChromeProtocol.Core.MethodName("Page.getOriginTrials")]
    public record GetOriginTrialsRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.ICommand<GetOriginTrialsRequestResult>
    {
    }
    public record GetOriginTrialsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("originTrials")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.OriginTrialType> OriginTrials
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,<br/>
    /// window.innerWidth, window.innerHeight, and &quot;device-width&quot;/&quot;device-height&quot;-related CSS media<br/>
    /// query results).<br/>
    /// </summary>
    /// <param name="Width">Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
    /// <param name="Height">Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
    /// <param name="DeviceScaleFactor">Overriding device scale factor value. 0 disables the override.</param>
    /// <param name="Mobile">
    /// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text<br/>
    /// autosizing and more.<br/>
    /// </param>
    /// <param name="Scale">Scale to apply to resulting view image.</param>
    /// <param name="ScreenWidth">Overriding screen width value in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="ScreenHeight">Overriding screen height value in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="PositionX">Overriding view X position on screen in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="PositionY">Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="DontSetVisibleSize">Do not set visible view size, rely upon explicit setVisibleSize call.</param>
    /// <param name="ScreenOrientation">Screen orientation override.</param>
    /// <param name="Viewport">The viewport dimensions and scale. If not set, the override is cleared.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.SetDeviceMetricsOverrideRequest SetDeviceMetricsOverride(int Width, int Height, double DeviceScaleFactor, bool Mobile, double? Scale = default, int? ScreenWidth = default, int? ScreenHeight = default, int? PositionX = default, int? PositionY = default, bool? DontSetVisibleSize = default, ChromeProtocol.Domains.Emulation.ScreenOrientationType? ScreenOrientation = default, ChromeProtocol.Domains.Page.ViewportType? Viewport = default)    
    {
      return new ChromeProtocol.Domains.Page.SetDeviceMetricsOverrideRequest(Width, Height, DeviceScaleFactor, Mobile, Scale, ScreenWidth, ScreenHeight, PositionX, PositionY, DontSetVisibleSize, ScreenOrientation, Viewport);
    }
    /// <summary>
    /// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,<br/>
    /// window.innerWidth, window.innerHeight, and &quot;device-width&quot;/&quot;device-height&quot;-related CSS media<br/>
    /// query results).<br/>
    /// </summary>
    /// <param name="Width">Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
    /// <param name="Height">Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.</param>
    /// <param name="DeviceScaleFactor">Overriding device scale factor value. 0 disables the override.</param>
    /// <param name="Mobile">
    /// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text<br/>
    /// autosizing and more.<br/>
    /// </param>
    /// <param name="Scale">Scale to apply to resulting view image.</param>
    /// <param name="ScreenWidth">Overriding screen width value in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="ScreenHeight">Overriding screen height value in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="PositionX">Overriding view X position on screen in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="PositionY">Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).</param>
    /// <param name="DontSetVisibleSize">Do not set visible view size, rely upon explicit setVisibleSize call.</param>
    /// <param name="ScreenOrientation">Screen orientation override.</param>
    /// <param name="Viewport">The viewport dimensions and scale. If not set, the override is cleared.</param>
    [ChromeProtocol.Core.MethodName("Page.setDeviceMetricsOverride")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetDeviceMetricsOverrideRequest(
      [property: Newtonsoft.Json.JsonProperty("width")]
      int Width,
      [property: Newtonsoft.Json.JsonProperty("height")]
      int Height,
      [property: Newtonsoft.Json.JsonProperty("deviceScaleFactor")]
      double DeviceScaleFactor,
      [property: Newtonsoft.Json.JsonProperty("mobile")]
      bool Mobile,
      [property: Newtonsoft.Json.JsonProperty("scale")]
      double? Scale = default,
      [property: Newtonsoft.Json.JsonProperty("screenWidth")]
      int? ScreenWidth = default,
      [property: Newtonsoft.Json.JsonProperty("screenHeight")]
      int? ScreenHeight = default,
      [property: Newtonsoft.Json.JsonProperty("positionX")]
      int? PositionX = default,
      [property: Newtonsoft.Json.JsonProperty("positionY")]
      int? PositionY = default,
      [property: Newtonsoft.Json.JsonProperty("dontSetVisibleSize")]
      bool? DontSetVisibleSize = default,
      [property: Newtonsoft.Json.JsonProperty("screenOrientation")]
      ChromeProtocol.Domains.Emulation.ScreenOrientationType? ScreenOrientation = default,
      [property: Newtonsoft.Json.JsonProperty("viewport")]
      ChromeProtocol.Domains.Page.ViewportType? Viewport = default
    ) : ChromeProtocol.Core.ICommand<SetDeviceMetricsOverrideRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetDeviceMetricsOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Overrides the Device Orientation.</summary>
    /// <param name="Alpha">Mock alpha</param>
    /// <param name="Beta">Mock beta</param>
    /// <param name="Gamma">Mock gamma</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.SetDeviceOrientationOverrideRequest SetDeviceOrientationOverride(double Alpha, double Beta, double Gamma)    
    {
      return new ChromeProtocol.Domains.Page.SetDeviceOrientationOverrideRequest(Alpha, Beta, Gamma);
    }
    /// <summary>Overrides the Device Orientation.</summary>
    /// <param name="Alpha">Mock alpha</param>
    /// <param name="Beta">Mock beta</param>
    /// <param name="Gamma">Mock gamma</param>
    [ChromeProtocol.Core.MethodName("Page.setDeviceOrientationOverride")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetDeviceOrientationOverrideRequest(
      [property: Newtonsoft.Json.JsonProperty("alpha")]
      double Alpha,
      [property: Newtonsoft.Json.JsonProperty("beta")]
      double Beta,
      [property: Newtonsoft.Json.JsonProperty("gamma")]
      double Gamma
    ) : ChromeProtocol.Core.ICommand<SetDeviceOrientationOverrideRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetDeviceOrientationOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Set generic font families.</summary>
    /// <param name="FontFamilies">Specifies font families to set. If a font family is not specified, it won&#39;t be changed.</param>
    /// <param name="ForScripts">Specifies font families to set for individual scripts.</param>
    public static ChromeProtocol.Domains.Page.SetFontFamiliesRequest SetFontFamilies(ChromeProtocol.Domains.Page.FontFamiliesType FontFamilies, System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.ScriptFontFamiliesType>? ForScripts = default)    
    {
      return new ChromeProtocol.Domains.Page.SetFontFamiliesRequest(FontFamilies, ForScripts);
    }
    /// <summary>Set generic font families.</summary>
    /// <param name="FontFamilies">Specifies font families to set. If a font family is not specified, it won&#39;t be changed.</param>
    /// <param name="ForScripts">Specifies font families to set for individual scripts.</param>
    [ChromeProtocol.Core.MethodName("Page.setFontFamilies")]
    public record SetFontFamiliesRequest(
      [property: Newtonsoft.Json.JsonProperty("fontFamilies")]
      ChromeProtocol.Domains.Page.FontFamiliesType FontFamilies,
      [property: Newtonsoft.Json.JsonProperty("forScripts")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.ScriptFontFamiliesType>? ForScripts = default
    ) : ChromeProtocol.Core.ICommand<SetFontFamiliesRequestResult>
    {
    }
    public record SetFontFamiliesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Set default font sizes.</summary>
    /// <param name="FontSizes">Specifies font sizes to set. If a font size is not specified, it won&#39;t be changed.</param>
    public static ChromeProtocol.Domains.Page.SetFontSizesRequest SetFontSizes(ChromeProtocol.Domains.Page.FontSizesType FontSizes)    
    {
      return new ChromeProtocol.Domains.Page.SetFontSizesRequest(FontSizes);
    }
    /// <summary>Set default font sizes.</summary>
    /// <param name="FontSizes">Specifies font sizes to set. If a font size is not specified, it won&#39;t be changed.</param>
    [ChromeProtocol.Core.MethodName("Page.setFontSizes")]
    public record SetFontSizesRequest(
      [property: Newtonsoft.Json.JsonProperty("fontSizes")]
      ChromeProtocol.Domains.Page.FontSizesType FontSizes
    ) : ChromeProtocol.Core.ICommand<SetFontSizesRequestResult>
    {
    }
    public record SetFontSizesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets given markup as the document&#39;s HTML.</summary>
    /// <param name="FrameId">Frame id to set HTML for.</param>
    /// <param name="Html">HTML content to set.</param>
    public static ChromeProtocol.Domains.Page.SetDocumentContentRequest SetDocumentContent(ChromeProtocol.Domains.Page.FrameIdType FrameId, string Html)    
    {
      return new ChromeProtocol.Domains.Page.SetDocumentContentRequest(FrameId, Html);
    }
    /// <summary>Sets given markup as the document&#39;s HTML.</summary>
    /// <param name="FrameId">Frame id to set HTML for.</param>
    /// <param name="Html">HTML content to set.</param>
    [ChromeProtocol.Core.MethodName("Page.setDocumentContent")]
    public record SetDocumentContentRequest(
      [property: Newtonsoft.Json.JsonProperty("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: Newtonsoft.Json.JsonProperty("html")]
      string Html
    ) : ChromeProtocol.Core.ICommand<SetDocumentContentRequestResult>
    {
    }
    public record SetDocumentContentRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Set the behavior when downloading a file.</summary>
    /// <param name="Behavior">
    /// Whether to allow all or deny all download requests, or use default Chrome behavior if<br/>
    /// available (otherwise deny).<br/>
    /// </param>
    /// <param name="DownloadPath">The default path to save downloaded files to. This is required if behavior is set to &#39;allow&#39;</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.SetDownloadBehaviorRequest SetDownloadBehavior(string Behavior, string? DownloadPath = default)    
    {
      return new ChromeProtocol.Domains.Page.SetDownloadBehaviorRequest(Behavior, DownloadPath);
    }
    /// <summary>Set the behavior when downloading a file.</summary>
    /// <param name="Behavior">
    /// Whether to allow all or deny all download requests, or use default Chrome behavior if<br/>
    /// available (otherwise deny).<br/>
    /// </param>
    /// <param name="DownloadPath">The default path to save downloaded files to. This is required if behavior is set to &#39;allow&#39;</param>
    [ChromeProtocol.Core.MethodName("Page.setDownloadBehavior")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetDownloadBehaviorRequest(
      [property: Newtonsoft.Json.JsonProperty("behavior")]
      string Behavior,
      [property: Newtonsoft.Json.JsonProperty("downloadPath")]
      string? DownloadPath = default
    ) : ChromeProtocol.Core.ICommand<SetDownloadBehaviorRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetDownloadBehaviorRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position<br/>
    /// unavailable.<br/>
    /// </summary>
    /// <param name="Latitude">Mock latitude</param>
    /// <param name="Longitude">Mock longitude</param>
    /// <param name="Accuracy">Mock accuracy</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.SetGeolocationOverrideRequest SetGeolocationOverride(double? Latitude = default, double? Longitude = default, double? Accuracy = default)    
    {
      return new ChromeProtocol.Domains.Page.SetGeolocationOverrideRequest(Latitude, Longitude, Accuracy);
    }
    /// <summary>
    /// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position<br/>
    /// unavailable.<br/>
    /// </summary>
    /// <param name="Latitude">Mock latitude</param>
    /// <param name="Longitude">Mock longitude</param>
    /// <param name="Accuracy">Mock accuracy</param>
    [ChromeProtocol.Core.MethodName("Page.setGeolocationOverride")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetGeolocationOverrideRequest(
      [property: Newtonsoft.Json.JsonProperty("latitude")]
      double? Latitude = default,
      [property: Newtonsoft.Json.JsonProperty("longitude")]
      double? Longitude = default,
      [property: Newtonsoft.Json.JsonProperty("accuracy")]
      double? Accuracy = default
    ) : ChromeProtocol.Core.ICommand<SetGeolocationOverrideRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetGeolocationOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Controls whether page will emit lifecycle events.</summary>
    /// <param name="Enabled">If true, starts emitting lifecycle events.</param>
    public static ChromeProtocol.Domains.Page.SetLifecycleEventsEnabledRequest SetLifecycleEventsEnabled(bool Enabled)    
    {
      return new ChromeProtocol.Domains.Page.SetLifecycleEventsEnabledRequest(Enabled);
    }
    /// <summary>Controls whether page will emit lifecycle events.</summary>
    /// <param name="Enabled">If true, starts emitting lifecycle events.</param>
    [ChromeProtocol.Core.MethodName("Page.setLifecycleEventsEnabled")]
    public record SetLifecycleEventsEnabledRequest(
      [property: Newtonsoft.Json.JsonProperty("enabled")]
      bool Enabled
    ) : ChromeProtocol.Core.ICommand<SetLifecycleEventsEnabledRequestResult>
    {
    }
    public record SetLifecycleEventsEnabledRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Toggles mouse event-based touch event emulation.</summary>
    /// <param name="Enabled">Whether the touch event emulation should be enabled.</param>
    /// <param name="Configuration">Touch/gesture events configuration. Default: current platform.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Page.SetTouchEmulationEnabledRequest SetTouchEmulationEnabled(bool Enabled, string? Configuration = default)    
    {
      return new ChromeProtocol.Domains.Page.SetTouchEmulationEnabledRequest(Enabled, Configuration);
    }
    /// <summary>Toggles mouse event-based touch event emulation.</summary>
    /// <param name="Enabled">Whether the touch event emulation should be enabled.</param>
    /// <param name="Configuration">Touch/gesture events configuration. Default: current platform.</param>
    [ChromeProtocol.Core.MethodName("Page.setTouchEmulationEnabled")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetTouchEmulationEnabledRequest(
      [property: Newtonsoft.Json.JsonProperty("enabled")]
      bool Enabled,
      [property: Newtonsoft.Json.JsonProperty("configuration")]
      string? Configuration = default
    ) : ChromeProtocol.Core.ICommand<SetTouchEmulationEnabledRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetTouchEmulationEnabledRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Starts sending each frame using the `screencastFrame` event.</summary>
    /// <param name="Format">Image compression format.</param>
    /// <param name="Quality">Compression quality from range [0..100].</param>
    /// <param name="MaxWidth">Maximum screenshot width.</param>
    /// <param name="MaxHeight">Maximum screenshot height.</param>
    /// <param name="EveryNthFrame">Send every n-th frame.</param>
    public static ChromeProtocol.Domains.Page.StartScreencastRequest StartScreencast(string? Format = default, int? Quality = default, int? MaxWidth = default, int? MaxHeight = default, int? EveryNthFrame = default)    
    {
      return new ChromeProtocol.Domains.Page.StartScreencastRequest(Format, Quality, MaxWidth, MaxHeight, EveryNthFrame);
    }
    /// <summary>Starts sending each frame using the `screencastFrame` event.</summary>
    /// <param name="Format">Image compression format.</param>
    /// <param name="Quality">Compression quality from range [0..100].</param>
    /// <param name="MaxWidth">Maximum screenshot width.</param>
    /// <param name="MaxHeight">Maximum screenshot height.</param>
    /// <param name="EveryNthFrame">Send every n-th frame.</param>
    [ChromeProtocol.Core.MethodName("Page.startScreencast")]
    public record StartScreencastRequest(
      [property: Newtonsoft.Json.JsonProperty("format")]
      string? Format = default,
      [property: Newtonsoft.Json.JsonProperty("quality")]
      int? Quality = default,
      [property: Newtonsoft.Json.JsonProperty("maxWidth")]
      int? MaxWidth = default,
      [property: Newtonsoft.Json.JsonProperty("maxHeight")]
      int? MaxHeight = default,
      [property: Newtonsoft.Json.JsonProperty("everyNthFrame")]
      int? EveryNthFrame = default
    ) : ChromeProtocol.Core.ICommand<StartScreencastRequestResult>
    {
    }
    public record StartScreencastRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Force the page stop all navigations and pending resource fetches.</summary>
    public static ChromeProtocol.Domains.Page.StopLoadingRequest StopLoading()    
    {
      return new ChromeProtocol.Domains.Page.StopLoadingRequest();
    }
    /// <summary>Force the page stop all navigations and pending resource fetches.</summary>
    [ChromeProtocol.Core.MethodName("Page.stopLoading")]
    public record StopLoadingRequest() : ChromeProtocol.Core.ICommand<StopLoadingRequestResult>
    {
    }
    public record StopLoadingRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Crashes renderer on the IO thread, generates minidumps.</summary>
    public static ChromeProtocol.Domains.Page.CrashRequest Crash()    
    {
      return new ChromeProtocol.Domains.Page.CrashRequest();
    }
    /// <summary>Crashes renderer on the IO thread, generates minidumps.</summary>
    [ChromeProtocol.Core.MethodName("Page.crash")]
    public record CrashRequest() : ChromeProtocol.Core.ICommand<CrashRequestResult>
    {
    }
    public record CrashRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Tries to close page, running its beforeunload hooks, if any.</summary>
    public static ChromeProtocol.Domains.Page.CloseRequest Close()    
    {
      return new ChromeProtocol.Domains.Page.CloseRequest();
    }
    /// <summary>Tries to close page, running its beforeunload hooks, if any.</summary>
    [ChromeProtocol.Core.MethodName("Page.close")]
    public record CloseRequest() : ChromeProtocol.Core.ICommand<CloseRequestResult>
    {
    }
    public record CloseRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Tries to update the web lifecycle state of the page.<br/>
    /// It will transition the page to the given state according to:<br/>
    /// https://github.com/WICG/web-lifecycle/<br/>
    /// </summary>
    /// <param name="State">Target lifecycle state</param>
    public static ChromeProtocol.Domains.Page.SetWebLifecycleStateRequest SetWebLifecycleState(string State)    
    {
      return new ChromeProtocol.Domains.Page.SetWebLifecycleStateRequest(State);
    }
    /// <summary>
    /// Tries to update the web lifecycle state of the page.<br/>
    /// It will transition the page to the given state according to:<br/>
    /// https://github.com/WICG/web-lifecycle/<br/>
    /// </summary>
    /// <param name="State">Target lifecycle state</param>
    [ChromeProtocol.Core.MethodName("Page.setWebLifecycleState")]
    public record SetWebLifecycleStateRequest(
      [property: Newtonsoft.Json.JsonProperty("state")]
      string State
    ) : ChromeProtocol.Core.ICommand<SetWebLifecycleStateRequestResult>
    {
    }
    public record SetWebLifecycleStateRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Stops sending each frame in the `screencastFrame`.</summary>
    public static ChromeProtocol.Domains.Page.StopScreencastRequest StopScreencast()    
    {
      return new ChromeProtocol.Domains.Page.StopScreencastRequest();
    }
    /// <summary>Stops sending each frame in the `screencastFrame`.</summary>
    [ChromeProtocol.Core.MethodName("Page.stopScreencast")]
    public record StopScreencastRequest() : ChromeProtocol.Core.ICommand<StopScreencastRequestResult>
    {
    }
    public record StopScreencastRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Requests backend to produce compilation cache for the specified scripts.<br/>
    /// `scripts` are appended to the list of scripts for which the cache<br/>
    /// would be produced. The list may be reset during page navigation.<br/>
    /// When script with a matching URL is encountered, the cache is optionally<br/>
    /// produced upon backend discretion, based on internal heuristics.<br/>
    /// See also: `Page.compilationCacheProduced`.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Page.ProduceCompilationCacheRequest ProduceCompilationCache(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.CompilationCacheParamsType> Scripts)    
    {
      return new ChromeProtocol.Domains.Page.ProduceCompilationCacheRequest(Scripts);
    }
    /// <summary>
    /// Requests backend to produce compilation cache for the specified scripts.<br/>
    /// `scripts` are appended to the list of scripts for which the cache<br/>
    /// would be produced. The list may be reset during page navigation.<br/>
    /// When script with a matching URL is encountered, the cache is optionally<br/>
    /// produced upon backend discretion, based on internal heuristics.<br/>
    /// See also: `Page.compilationCacheProduced`.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Page.produceCompilationCache")]
    public record ProduceCompilationCacheRequest(
      [property: Newtonsoft.Json.JsonProperty("scripts")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Page.CompilationCacheParamsType> Scripts
    ) : ChromeProtocol.Core.ICommand<ProduceCompilationCacheRequestResult>
    {
    }
    public record ProduceCompilationCacheRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Seeds compilation cache for given url. Compilation cache does not survive<br/>
    /// cross-process navigation.<br/>
    /// </summary>
    /// <param name="Data">Base64-encoded data (Encoded as a base64 string when passed over JSON)</param>
    public static ChromeProtocol.Domains.Page.AddCompilationCacheRequest AddCompilationCache(string Url, string Data)    
    {
      return new ChromeProtocol.Domains.Page.AddCompilationCacheRequest(Url, Data);
    }
    /// <summary>
    /// Seeds compilation cache for given url. Compilation cache does not survive<br/>
    /// cross-process navigation.<br/>
    /// </summary>
    /// <param name="Data">Base64-encoded data (Encoded as a base64 string when passed over JSON)</param>
    [ChromeProtocol.Core.MethodName("Page.addCompilationCache")]
    public record AddCompilationCacheRequest(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("data")]
      string Data
    ) : ChromeProtocol.Core.ICommand<AddCompilationCacheRequestResult>
    {
    }
    public record AddCompilationCacheRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears seeded compilation cache.</summary>
    public static ChromeProtocol.Domains.Page.ClearCompilationCacheRequest ClearCompilationCache()    
    {
      return new ChromeProtocol.Domains.Page.ClearCompilationCacheRequest();
    }
    /// <summary>Clears seeded compilation cache.</summary>
    [ChromeProtocol.Core.MethodName("Page.clearCompilationCache")]
    public record ClearCompilationCacheRequest() : ChromeProtocol.Core.ICommand<ClearCompilationCacheRequestResult>
    {
    }
    public record ClearCompilationCacheRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Sets the Secure Payment Confirmation transaction mode.<br/>
    /// https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Page.SetSPCTransactionModeRequest SetSPCTransactionMode(ChromeProtocol.Domains.Page.AutoResponseModeType Mode)    
    {
      return new ChromeProtocol.Domains.Page.SetSPCTransactionModeRequest(Mode);
    }
    /// <summary>
    /// Sets the Secure Payment Confirmation transaction mode.<br/>
    /// https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Page.setSPCTransactionMode")]
    public record SetSPCTransactionModeRequest(
      [property: Newtonsoft.Json.JsonProperty("mode")]
      ChromeProtocol.Domains.Page.AutoResponseModeType Mode
    ) : ChromeProtocol.Core.ICommand<SetSPCTransactionModeRequestResult>
    {
    }
    public record SetSPCTransactionModeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Extensions for Custom Handlers API:<br/>
    /// https://html.spec.whatwg.org/multipage/system-state.html#rph-automation<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Page.SetRPHRegistrationModeRequest SetRPHRegistrationMode(ChromeProtocol.Domains.Page.AutoResponseModeType Mode)    
    {
      return new ChromeProtocol.Domains.Page.SetRPHRegistrationModeRequest(Mode);
    }
    /// <summary>
    /// Extensions for Custom Handlers API:<br/>
    /// https://html.spec.whatwg.org/multipage/system-state.html#rph-automation<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Page.setRPHRegistrationMode")]
    public record SetRPHRegistrationModeRequest(
      [property: Newtonsoft.Json.JsonProperty("mode")]
      ChromeProtocol.Domains.Page.AutoResponseModeType Mode
    ) : ChromeProtocol.Core.ICommand<SetRPHRegistrationModeRequestResult>
    {
    }
    public record SetRPHRegistrationModeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Generates a report for testing.</summary>
    /// <param name="Message">Message to be displayed in the report.</param>
    /// <param name="Group">Specifies the endpoint group to deliver the report to.</param>
    public static ChromeProtocol.Domains.Page.GenerateTestReportRequest GenerateTestReport(string Message, string? Group = default)    
    {
      return new ChromeProtocol.Domains.Page.GenerateTestReportRequest(Message, Group);
    }
    /// <summary>Generates a report for testing.</summary>
    /// <param name="Message">Message to be displayed in the report.</param>
    /// <param name="Group">Specifies the endpoint group to deliver the report to.</param>
    [ChromeProtocol.Core.MethodName("Page.generateTestReport")]
    public record GenerateTestReportRequest(
      [property: Newtonsoft.Json.JsonProperty("message")]
      string Message,
      [property: Newtonsoft.Json.JsonProperty("group")]
      string? Group = default
    ) : ChromeProtocol.Core.ICommand<GenerateTestReportRequestResult>
    {
    }
    public record GenerateTestReportRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.</summary>
    public static ChromeProtocol.Domains.Page.WaitForDebuggerRequest WaitForDebugger()    
    {
      return new ChromeProtocol.Domains.Page.WaitForDebuggerRequest();
    }
    /// <summary>Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.</summary>
    [ChromeProtocol.Core.MethodName("Page.waitForDebugger")]
    public record WaitForDebuggerRequest() : ChromeProtocol.Core.ICommand<WaitForDebuggerRequestResult>
    {
    }
    public record WaitForDebuggerRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Intercept file chooser requests and transfer control to protocol clients.<br/>
    /// When file chooser interception is enabled, native file chooser dialog is not shown.<br/>
    /// Instead, a protocol event `Page.fileChooserOpened` is emitted.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Page.SetInterceptFileChooserDialogRequest SetInterceptFileChooserDialog(bool Enabled)    
    {
      return new ChromeProtocol.Domains.Page.SetInterceptFileChooserDialogRequest(Enabled);
    }
    /// <summary>
    /// Intercept file chooser requests and transfer control to protocol clients.<br/>
    /// When file chooser interception is enabled, native file chooser dialog is not shown.<br/>
    /// Instead, a protocol event `Page.fileChooserOpened` is emitted.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Page.setInterceptFileChooserDialog")]
    public record SetInterceptFileChooserDialogRequest(
      [property: Newtonsoft.Json.JsonProperty("enabled")]
      bool Enabled
    ) : ChromeProtocol.Core.ICommand<SetInterceptFileChooserDialogRequestResult>
    {
    }
    public record SetInterceptFileChooserDialogRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enable/disable prerendering manually.<br/>
    /// This command is a short-term solution for https://crbug.com/1440085.<br/>
    /// See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA<br/>
    /// for more details.<br/>
    /// TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Page.SetPrerenderingAllowedRequest SetPrerenderingAllowed(bool IsAllowed)    
    {
      return new ChromeProtocol.Domains.Page.SetPrerenderingAllowedRequest(IsAllowed);
    }
    /// <summary>
    /// Enable/disable prerendering manually.<br/>
    /// This command is a short-term solution for https://crbug.com/1440085.<br/>
    /// See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA<br/>
    /// for more details.<br/>
    /// TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Page.setPrerenderingAllowed")]
    public record SetPrerenderingAllowedRequest(
      [property: Newtonsoft.Json.JsonProperty("isAllowed")]
      bool IsAllowed
    ) : ChromeProtocol.Core.ICommand<SetPrerenderingAllowedRequestResult>
    {
    }
    public record SetPrerenderingAllowedRequestResult() : ChromeProtocol.Core.IType
    {
    }
  }
}
