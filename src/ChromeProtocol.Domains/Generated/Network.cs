// <auto-generated />
#nullable enable

namespace ChromeProtocol.Domains
{
  /// <summary>
  /// Network domain allows tracking network activities of the page. It exposes information about http,<br/>
  /// file, data and other requests and responses, their headers, bodies, timing, etc.<br/>
  /// </summary>
  public static partial class Network
  {
    /// <summary>Resource type as it was perceived by the rendering engine.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ResourceTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Unique loader identifier.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record LoaderIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Unique request identifier.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record RequestIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Unique intercepted request identifier.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record InterceptionIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Network level fetch failure reason.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ErrorReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>UTC time in seconds, counted from January 1, 1970.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record TimeSinceEpochType(
      double Value
    ) : ChromeProtocol.Core.PrimitiveType<double>(Value)
    {
    }
    /// <summary>Monotonically increasing time in seconds since an arbitrary point in the past.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record MonotonicTimeType(
      double Value
    ) : ChromeProtocol.Core.PrimitiveType<double>(Value)
    {
    }
    /// <summary>Request / response headers as keys / values of JSON object.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.ObjectTypeConverter))]
    public record HeadersType(
      System.Collections.Generic.IReadOnlyDictionary<System.String, System.Text.Json.Nodes.JsonNode?> Properties
    ) : ChromeProtocol.Core.IObjectType
    {
    }
    /// <summary>The underlying connection technology that the browser is supposedly using.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ConnectionTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Represents the cookie&#39;s &#39;SameSite&#39; status:<br/>
    /// https://tools.ietf.org/html/draft-west-first-party-cookies<br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CookieSameSiteType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Represents the cookie&#39;s &#39;Priority&#39; status:<br/>
    /// https://tools.ietf.org/html/draft-west-cookie-priority-00<br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CookiePriorityType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Represents the source scheme of the origin that originally set the cookie.<br/>
    /// A value of &quot;Unset&quot; allows protocol clients to emulate legacy cookie scope for the scheme.<br/>
    /// This is a temporary ability and it will be removed in the future.<br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CookieSourceSchemeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Timing information for the request.</summary>
    /// <param name="RequestTime">
    /// Timing&#39;s requestTime is a baseline in seconds, while the other numbers are ticks in<br/>
    /// milliseconds relatively to this requestTime.<br/>
    /// </param>
    /// <param name="ProxyStart">Started resolving proxy.</param>
    /// <param name="ProxyEnd">Finished resolving proxy.</param>
    /// <param name="DnsStart">Started DNS address resolve.</param>
    /// <param name="DnsEnd">Finished DNS address resolve.</param>
    /// <param name="ConnectStart">Started connecting to the remote host.</param>
    /// <param name="ConnectEnd">Connected to the remote host.</param>
    /// <param name="SslStart">Started SSL handshake.</param>
    /// <param name="SslEnd">Finished SSL handshake.</param>
    /// <param name="WorkerStart">Started running ServiceWorker.</param>
    /// <param name="WorkerReady">Finished Starting ServiceWorker.</param>
    /// <param name="WorkerFetchStart">Started fetch event.</param>
    /// <param name="WorkerRespondWithSettled">Settled fetch event respondWith promise.</param>
    /// <param name="SendStart">Started sending request.</param>
    /// <param name="SendEnd">Finished sending request.</param>
    /// <param name="PushStart">Time the server started pushing request.</param>
    /// <param name="PushEnd">Time the server finished pushing request.</param>
    /// <param name="ReceiveHeadersStart">Started receiving response headers.</param>
    /// <param name="ReceiveHeadersEnd">Finished receiving response headers.</param>
    /// <param name="WorkerRouterEvaluationStart">Started ServiceWorker static routing source evaluation.</param>
    /// <param name="WorkerCacheLookupStart">Started cache lookup when the source was evaluated to `cache`.</param>
    public record ResourceTimingType(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestTime")]
      double RequestTime,
      [property: System.Text.Json.Serialization.JsonPropertyName("proxyStart")]
      double ProxyStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("proxyEnd")]
      double ProxyEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("dnsStart")]
      double DnsStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("dnsEnd")]
      double DnsEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("connectStart")]
      double ConnectStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("connectEnd")]
      double ConnectEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("sslStart")]
      double SslStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("sslEnd")]
      double SslEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("workerStart")]
      double WorkerStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("workerReady")]
      double WorkerReady,
      [property: System.Text.Json.Serialization.JsonPropertyName("workerFetchStart")]
      double WorkerFetchStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("workerRespondWithSettled")]
      double WorkerRespondWithSettled,
      [property: System.Text.Json.Serialization.JsonPropertyName("sendStart")]
      double SendStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("sendEnd")]
      double SendEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("pushStart")]
      double PushStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("pushEnd")]
      double PushEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("receiveHeadersStart")]
      double ReceiveHeadersStart,
      [property: System.Text.Json.Serialization.JsonPropertyName("receiveHeadersEnd")]
      double ReceiveHeadersEnd,
      [property: System.Text.Json.Serialization.JsonPropertyName("workerRouterEvaluationStart")]
      double? WorkerRouterEvaluationStart = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("workerCacheLookupStart")]
      double? WorkerCacheLookupStart = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Loading priority of a resource request.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ResourcePriorityType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Post data entry for HTTP request</summary>
    public record PostDataEntryType(
      [property: System.Text.Json.Serialization.JsonPropertyName("bytes")]
      string? Bytes = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>HTTP request data.</summary>
    /// <param name="Url">Request URL (without fragment).</param>
    /// <param name="Method">HTTP request method.</param>
    /// <param name="Headers">HTTP request headers.</param>
    /// <param name="InitialPriority">Priority of the resource request at the time request is sent.</param>
    /// <param name="ReferrerPolicy">The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/</param>
    /// <param name="UrlFragment">Fragment of the requested URL starting with hash, if present.</param>
    /// <param name="PostData">
    /// HTTP POST request data.<br/>
    /// Use postDataEntries instead.<br/>
    /// </param>
    /// <param name="HasPostData">True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.</param>
    /// <param name="PostDataEntries">Request body elements (post data broken into individual entries).</param>
    /// <param name="MixedContentType">The mixed content type of the request.</param>
    /// <param name="IsLinkPreload">Whether is loaded via link preload.</param>
    /// <param name="TrustTokenParams">
    /// Set for requests when the TrustToken API is used. Contains the parameters<br/>
    /// passed by the developer (e.g. via &quot;fetch&quot;) as understood by the backend.<br/>
    /// </param>
    /// <param name="IsSameSite">
    /// True if this resource request is considered to be the &#39;same site&#39; as the<br/>
    /// request corresponding to the main frame.<br/>
    /// </param>
    public record RequestType(
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("method")]
      string Method,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers,
      [property: System.Text.Json.Serialization.JsonPropertyName("initialPriority")]
      ChromeProtocol.Domains.Network.ResourcePriorityType InitialPriority,
      [property: System.Text.Json.Serialization.JsonPropertyName("referrerPolicy")]
      string ReferrerPolicy,
      [property: System.Text.Json.Serialization.JsonPropertyName("urlFragment")]
      string? UrlFragment = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("postData")]
      string? PostData = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("hasPostData")]
      bool? HasPostData = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("postDataEntries")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.PostDataEntryType>? PostDataEntries = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("mixedContentType")]
      ChromeProtocol.Domains.Security.MixedContentTypeType? MixedContentType = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isLinkPreload")]
      bool? IsLinkPreload = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("trustTokenParams")]
      ChromeProtocol.Domains.Network.TrustTokenParamsType? TrustTokenParams = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isSameSite")]
      bool? IsSameSite = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Details of a signed certificate timestamp (SCT).</summary>
    /// <param name="Status">Validation status.</param>
    /// <param name="Origin">Origin.</param>
    /// <param name="LogDescription">Log name / description.</param>
    /// <param name="LogId">Log ID.</param>
    /// <param name="Timestamp">
    /// Issuance date. Unlike TimeSinceEpoch, this contains the number of<br/>
    /// milliseconds since January 1, 1970, UTC, not the number of seconds.<br/>
    /// </param>
    /// <param name="HashAlgorithm">Hash algorithm.</param>
    /// <param name="SignatureAlgorithm">Signature algorithm.</param>
    /// <param name="SignatureData">Signature data.</param>
    public record SignedCertificateTimestampType(
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      string Status,
      [property: System.Text.Json.Serialization.JsonPropertyName("origin")]
      string Origin,
      [property: System.Text.Json.Serialization.JsonPropertyName("logDescription")]
      string LogDescription,
      [property: System.Text.Json.Serialization.JsonPropertyName("logId")]
      string LogId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      double Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("hashAlgorithm")]
      string HashAlgorithm,
      [property: System.Text.Json.Serialization.JsonPropertyName("signatureAlgorithm")]
      string SignatureAlgorithm,
      [property: System.Text.Json.Serialization.JsonPropertyName("signatureData")]
      string SignatureData
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Security details about a request.</summary>
    /// <param name="Protocol">Protocol name (e.g. &quot;TLS 1.2&quot; or &quot;QUIC&quot;).</param>
    /// <param name="KeyExchange">Key Exchange used by the connection, or the empty string if not applicable.</param>
    /// <param name="Cipher">Cipher name.</param>
    /// <param name="CertificateId">Certificate ID value.</param>
    /// <param name="SubjectName">Certificate subject name.</param>
    /// <param name="SanList">Subject Alternative Name (SAN) DNS names and IP addresses.</param>
    /// <param name="Issuer">Name of the issuing CA.</param>
    /// <param name="ValidFrom">Certificate valid from date.</param>
    /// <param name="ValidTo">Certificate valid to (expiration) date</param>
    /// <param name="SignedCertificateTimestampList">List of signed certificate timestamps (SCTs).</param>
    /// <param name="CertificateTransparencyCompliance">Whether the request complied with Certificate Transparency policy</param>
    /// <param name="EncryptedClientHello">Whether the connection used Encrypted ClientHello</param>
    /// <param name="KeyExchangeGroup">(EC)DH group used by the connection, if applicable.</param>
    /// <param name="Mac">TLS MAC. Note that AEAD ciphers do not have separate MACs.</param>
    /// <param name="ServerSignatureAlgorithm">
    /// The signature algorithm used by the server in the TLS server signature,<br/>
    /// represented as a TLS SignatureScheme code point. Omitted if not<br/>
    /// applicable or not known.<br/>
    /// </param>
    public record SecurityDetailsType(
      [property: System.Text.Json.Serialization.JsonPropertyName("protocol")]
      string Protocol,
      [property: System.Text.Json.Serialization.JsonPropertyName("keyExchange")]
      string KeyExchange,
      [property: System.Text.Json.Serialization.JsonPropertyName("cipher")]
      string Cipher,
      [property: System.Text.Json.Serialization.JsonPropertyName("certificateId")]
      ChromeProtocol.Domains.Security.CertificateIdType CertificateId,
      [property: System.Text.Json.Serialization.JsonPropertyName("subjectName")]
      string SubjectName,
      [property: System.Text.Json.Serialization.JsonPropertyName("sanList")]
      System.Collections.Generic.IReadOnlyList<string> SanList,
      [property: System.Text.Json.Serialization.JsonPropertyName("issuer")]
      string Issuer,
      [property: System.Text.Json.Serialization.JsonPropertyName("validFrom")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType ValidFrom,
      [property: System.Text.Json.Serialization.JsonPropertyName("validTo")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType ValidTo,
      [property: System.Text.Json.Serialization.JsonPropertyName("signedCertificateTimestampList")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.SignedCertificateTimestampType> SignedCertificateTimestampList,
      [property: System.Text.Json.Serialization.JsonPropertyName("certificateTransparencyCompliance")]
      ChromeProtocol.Domains.Network.CertificateTransparencyComplianceType CertificateTransparencyCompliance,
      [property: System.Text.Json.Serialization.JsonPropertyName("encryptedClientHello")]
      bool EncryptedClientHello,
      [property: System.Text.Json.Serialization.JsonPropertyName("keyExchangeGroup")]
      string? KeyExchangeGroup = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("mac")]
      string? Mac = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("serverSignatureAlgorithm")]
      int? ServerSignatureAlgorithm = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Whether the request complied with Certificate Transparency policy.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CertificateTransparencyComplianceType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>The reason why request was blocked.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record BlockedReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>The reason why request was blocked.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CorsErrorType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    public record CorsErrorStatusType(
      [property: System.Text.Json.Serialization.JsonPropertyName("corsError")]
      ChromeProtocol.Domains.Network.CorsErrorType CorsError,
      [property: System.Text.Json.Serialization.JsonPropertyName("failedParameter")]
      string FailedParameter
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Source of serviceworker response.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ServiceWorkerResponseSourceType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// Determines what type of Trust Token operation is executed and<br/>
    /// depending on the type, some additional parameters. The values<br/>
    /// are specified in third_party/blink/renderer/core/fetch/trust_token.idl.<br/>
    /// </summary>
    /// <param name="RefreshPolicy">
    /// Only set for &quot;token-redemption&quot; operation and determine whether<br/>
    /// to request a fresh SRR or use a still valid cached SRR.<br/>
    /// </param>
    /// <param name="Issuers">
    /// Origins of issuers from whom to request tokens or redemption<br/>
    /// records.<br/>
    /// </param>
    public record TrustTokenParamsType(
      [property: System.Text.Json.Serialization.JsonPropertyName("operation")]
      ChromeProtocol.Domains.Network.TrustTokenOperationTypeType Operation,
      [property: System.Text.Json.Serialization.JsonPropertyName("refreshPolicy")]
      string RefreshPolicy,
      [property: System.Text.Json.Serialization.JsonPropertyName("issuers")]
      System.Collections.Generic.IReadOnlyList<string>? Issuers = default
    ) : ChromeProtocol.Core.IType
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record TrustTokenOperationTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>The reason why Chrome uses a specific transport protocol for HTTP semantics.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record AlternateProtocolUsageType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Source of service worker router.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ServiceWorkerRouterSourceType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <param name="RuleIdMatched">
    /// ID of the rule matched. If there is a matched rule, this field will<br/>
    /// be set, otherwiser no value will be set.<br/>
    /// </param>
    /// <param name="MatchedSourceType">
    /// The router source of the matched rule. If there is a matched rule, this<br/>
    /// field will be set, otherwise no value will be set.<br/>
    /// </param>
    /// <param name="ActualSourceType">The actual router source used.</param>
    public record ServiceWorkerRouterInfoType(
      [property: System.Text.Json.Serialization.JsonPropertyName("ruleIdMatched")]
      int? RuleIdMatched = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("matchedSourceType")]
      ChromeProtocol.Domains.Network.ServiceWorkerRouterSourceType? MatchedSourceType = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("actualSourceType")]
      ChromeProtocol.Domains.Network.ServiceWorkerRouterSourceType? ActualSourceType = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>HTTP response data.</summary>
    /// <param name="Url">Response URL. This URL can be different from CachedResource.url in case of redirect.</param>
    /// <param name="Status">HTTP response status code.</param>
    /// <param name="StatusText">HTTP response status text.</param>
    /// <param name="Headers">HTTP response headers.</param>
    /// <param name="MimeType">Resource mimeType as determined by the browser.</param>
    /// <param name="Charset">Resource charset as determined by the browser (if applicable).</param>
    /// <param name="ConnectionReused">Specifies whether physical connection was actually reused for this request.</param>
    /// <param name="ConnectionId">Physical connection id that was actually used for this request.</param>
    /// <param name="EncodedDataLength">Total number of bytes received for this request so far.</param>
    /// <param name="SecurityState">Security state of the request resource.</param>
    /// <param name="HeadersText">HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.</param>
    /// <param name="RequestHeaders">Refined HTTP request headers that were actually transmitted over the network.</param>
    /// <param name="RequestHeadersText">HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.</param>
    /// <param name="RemoteIPAddress">Remote IP address.</param>
    /// <param name="RemotePort">Remote port.</param>
    /// <param name="FromDiskCache">Specifies that the request was served from the disk cache.</param>
    /// <param name="FromServiceWorker">Specifies that the request was served from the ServiceWorker.</param>
    /// <param name="FromPrefetchCache">Specifies that the request was served from the prefetch cache.</param>
    /// <param name="FromEarlyHints">Specifies that the request was served from the prefetch cache.</param>
    /// <param name="ServiceWorkerRouterInfo">
    /// Information about how ServiceWorker Static Router API was used. If this<br/>
    /// field is set with `matchedSourceType` field, a matching rule is found.<br/>
    /// If this field is set without `matchedSource`, no matching rule is found.<br/>
    /// Otherwise, the API is not used.<br/>
    /// </param>
    /// <param name="Timing">Timing information for the given request.</param>
    /// <param name="ServiceWorkerResponseSource">Response source of response from ServiceWorker.</param>
    /// <param name="ResponseTime">The time at which the returned response was generated.</param>
    /// <param name="CacheStorageCacheName">Cache Storage Cache Name.</param>
    /// <param name="Protocol">Protocol used to fetch this request.</param>
    /// <param name="AlternateProtocolUsage">The reason why Chrome uses a specific transport protocol for HTTP semantics.</param>
    /// <param name="SecurityDetails">Security details for the request.</param>
    public record ResponseType(
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      int Status,
      [property: System.Text.Json.Serialization.JsonPropertyName("statusText")]
      string StatusText,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers,
      [property: System.Text.Json.Serialization.JsonPropertyName("mimeType")]
      string MimeType,
      [property: System.Text.Json.Serialization.JsonPropertyName("charset")]
      string Charset,
      [property: System.Text.Json.Serialization.JsonPropertyName("connectionReused")]
      bool ConnectionReused,
      [property: System.Text.Json.Serialization.JsonPropertyName("connectionId")]
      double ConnectionId,
      [property: System.Text.Json.Serialization.JsonPropertyName("encodedDataLength")]
      double EncodedDataLength,
      [property: System.Text.Json.Serialization.JsonPropertyName("securityState")]
      ChromeProtocol.Domains.Security.SecurityStateType SecurityState,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("headersText")]
      string? HeadersText = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("requestHeaders")]
      ChromeProtocol.Domains.Network.HeadersType? RequestHeaders = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("requestHeadersText")]
      string? RequestHeadersText = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("remoteIPAddress")]
      string? RemoteIPAddress = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("remotePort")]
      int? RemotePort = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("fromDiskCache")]
      bool? FromDiskCache = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("fromServiceWorker")]
      bool? FromServiceWorker = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("fromPrefetchCache")]
      bool? FromPrefetchCache = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("fromEarlyHints")]
      bool? FromEarlyHints = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("serviceWorkerRouterInfo")]
      ChromeProtocol.Domains.Network.ServiceWorkerRouterInfoType? ServiceWorkerRouterInfo = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("timing")]
      ChromeProtocol.Domains.Network.ResourceTimingType? Timing = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("serviceWorkerResponseSource")]
      ChromeProtocol.Domains.Network.ServiceWorkerResponseSourceType? ServiceWorkerResponseSource = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("responseTime")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType? ResponseTime = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("cacheStorageCacheName")]
      string? CacheStorageCacheName = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("protocol")]
      string? Protocol = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("alternateProtocolUsage")]
      ChromeProtocol.Domains.Network.AlternateProtocolUsageType? AlternateProtocolUsage = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("securityDetails")]
      ChromeProtocol.Domains.Network.SecurityDetailsType? SecurityDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>WebSocket request data.</summary>
    /// <param name="Headers">HTTP request headers.</param>
    public record WebSocketRequestType(
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>WebSocket response data.</summary>
    /// <param name="Status">HTTP response status code.</param>
    /// <param name="StatusText">HTTP response status text.</param>
    /// <param name="Headers">HTTP response headers.</param>
    /// <param name="HeadersText">HTTP response headers text.</param>
    /// <param name="RequestHeaders">HTTP request headers.</param>
    /// <param name="RequestHeadersText">HTTP request headers text.</param>
    public record WebSocketResponseType(
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      int Status,
      [property: System.Text.Json.Serialization.JsonPropertyName("statusText")]
      string StatusText,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers,
      [property: System.Text.Json.Serialization.JsonPropertyName("headersText")]
      string? HeadersText = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("requestHeaders")]
      ChromeProtocol.Domains.Network.HeadersType? RequestHeaders = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("requestHeadersText")]
      string? RequestHeadersText = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.</summary>
    /// <param name="Opcode">WebSocket message opcode.</param>
    /// <param name="Mask">WebSocket message mask.</param>
    /// <param name="PayloadData">
    /// WebSocket message payload data.<br/>
    /// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.<br/>
    /// If the opcode isn&#39;t 1, then payloadData is a base64 encoded string representing binary data.<br/>
    /// </param>
    public record WebSocketFrameType(
      [property: System.Text.Json.Serialization.JsonPropertyName("opcode")]
      double Opcode,
      [property: System.Text.Json.Serialization.JsonPropertyName("mask")]
      bool Mask,
      [property: System.Text.Json.Serialization.JsonPropertyName("payloadData")]
      string PayloadData
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about the cached resource.</summary>
    /// <param name="Url">Resource URL. This is the url of the original network request.</param>
    /// <param name="Type">Type of this resource.</param>
    /// <param name="BodySize">Cached response body size.</param>
    /// <param name="Response">Cached response data.</param>
    public record CachedResourceType(
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      ChromeProtocol.Domains.Network.ResourceTypeType Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("bodySize")]
      double BodySize,
      [property: System.Text.Json.Serialization.JsonPropertyName("response")]
      ChromeProtocol.Domains.Network.ResponseType? Response = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about the request initiator.</summary>
    /// <param name="Type">Type of this initiator.</param>
    /// <param name="Stack">Initiator JavaScript stack trace, set for Script only.</param>
    /// <param name="Url">Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.</param>
    /// <param name="LineNumber">
    /// Initiator line number, set for Parser type or for Script type (when script is importing<br/>
    /// module) (0-based).<br/>
    /// </param>
    /// <param name="ColumnNumber">
    /// Initiator column number, set for Parser type or for Script type (when script is importing<br/>
    /// module) (0-based).<br/>
    /// </param>
    /// <param name="RequestId">Set if another request triggered this request (e.g. preflight).</param>
    public record InitiatorType(
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      string Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("stack")]
      ChromeProtocol.Domains.Runtime.StackTraceType? Stack = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("lineNumber")]
      double? LineNumber = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("columnNumber")]
      double? ColumnNumber = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType? RequestId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// cookiePartitionKey object<br/>
    /// The representation of the components of the key that are created by the cookiePartitionKey class contained in net/cookies/cookie_partition_key.h.<br/>
    /// </summary>
    /// <param name="TopLevelSite">
    /// The site of the top-level URL the browser was visiting at the start<br/>
    /// of the request to the endpoint that set the cookie.<br/>
    /// </param>
    /// <param name="HasCrossSiteAncestor">Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.</param>
    public record CookiePartitionKeyType(
      [property: System.Text.Json.Serialization.JsonPropertyName("topLevelSite")]
      string TopLevelSite,
      [property: System.Text.Json.Serialization.JsonPropertyName("hasCrossSiteAncestor")]
      bool HasCrossSiteAncestor
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Cookie object</summary>
    /// <param name="Name">Cookie name.</param>
    /// <param name="Value">Cookie value.</param>
    /// <param name="Domain">Cookie domain.</param>
    /// <param name="Path">Cookie path.</param>
    /// <param name="Expires">Cookie expiration date as the number of seconds since the UNIX epoch.</param>
    /// <param name="Size">Cookie size.</param>
    /// <param name="HttpOnly">True if cookie is http-only.</param>
    /// <param name="Secure">True if cookie is secure.</param>
    /// <param name="Session">True in case of session cookie.</param>
    /// <param name="Priority">Cookie Priority</param>
    /// <param name="SameParty">True if cookie is SameParty.</param>
    /// <param name="SourceScheme">Cookie source scheme type.</param>
    /// <param name="SourcePort">
    /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.<br/>
    /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.<br/>
    /// This is a temporary ability and it will be removed in the future.<br/>
    /// </param>
    /// <param name="SameSite">Cookie SameSite type.</param>
    /// <param name="PartitionKey">Cookie partition key.</param>
    /// <param name="PartitionKeyOpaque">True if cookie partition key is opaque.</param>
    public record CookieType(
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value,
      [property: System.Text.Json.Serialization.JsonPropertyName("domain")]
      string Domain,
      [property: System.Text.Json.Serialization.JsonPropertyName("path")]
      string Path,
      [property: System.Text.Json.Serialization.JsonPropertyName("expires")]
      double Expires,
      [property: System.Text.Json.Serialization.JsonPropertyName("size")]
      int Size,
      [property: System.Text.Json.Serialization.JsonPropertyName("httpOnly")]
      bool HttpOnly,
      [property: System.Text.Json.Serialization.JsonPropertyName("secure")]
      bool Secure,
      [property: System.Text.Json.Serialization.JsonPropertyName("session")]
      bool Session,
      [property: System.Text.Json.Serialization.JsonPropertyName("priority")]
      ChromeProtocol.Domains.Network.CookiePriorityType Priority,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("sameParty")]
      bool SameParty,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourceScheme")]
      ChromeProtocol.Domains.Network.CookieSourceSchemeType SourceScheme,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourcePort")]
      int SourcePort,
      [property: System.Text.Json.Serialization.JsonPropertyName("sameSite")]
      ChromeProtocol.Domains.Network.CookieSameSiteType? SameSite = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("partitionKey")]
      ChromeProtocol.Domains.Network.CookiePartitionKeyType? PartitionKey = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("partitionKeyOpaque")]
      bool? PartitionKeyOpaque = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Types of reasons why a cookie may not be stored from a response.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record SetCookieBlockedReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Types of reasons why a cookie may not be sent with a request.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CookieBlockedReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CookieExemptionReasonType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>A cookie which was not stored from a response with the corresponding reason.</summary>
    /// <param name="BlockedReasons">The reason(s) this cookie was blocked.</param>
    /// <param name="CookieLine">
    /// The string representing this individual cookie as it would appear in the header.<br/>
    /// This is not the entire &quot;cookie&quot; or &quot;set-cookie&quot; header which could have multiple cookies.<br/>
    /// </param>
    /// <param name="Cookie">
    /// The cookie object which represents the cookie which was not stored. It is optional because<br/>
    /// sometimes complete cookie information is not available, such as in the case of parsing<br/>
    /// errors.<br/>
    /// </param>
    public record BlockedSetCookieWithReasonType(
      [property: System.Text.Json.Serialization.JsonPropertyName("blockedReasons")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.SetCookieBlockedReasonType> BlockedReasons,
      [property: System.Text.Json.Serialization.JsonPropertyName("cookieLine")]
      string CookieLine,
      [property: System.Text.Json.Serialization.JsonPropertyName("cookie")]
      ChromeProtocol.Domains.Network.CookieType? Cookie = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// A cookie should have been blocked by 3PCD but is exempted and stored from a response with the<br/>
    /// corresponding reason. A cookie could only have at most one exemption reason.<br/>
    /// </summary>
    /// <param name="ExemptionReason">The reason the cookie was exempted.</param>
    /// <param name="CookieLine">The string representing this individual cookie as it would appear in the header.</param>
    /// <param name="Cookie">The cookie object representing the cookie.</param>
    public record ExemptedSetCookieWithReasonType(
      [property: System.Text.Json.Serialization.JsonPropertyName("exemptionReason")]
      ChromeProtocol.Domains.Network.CookieExemptionReasonType ExemptionReason,
      [property: System.Text.Json.Serialization.JsonPropertyName("cookieLine")]
      string CookieLine,
      [property: System.Text.Json.Serialization.JsonPropertyName("cookie")]
      ChromeProtocol.Domains.Network.CookieType Cookie
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// A cookie associated with the request which may or may not be sent with it.<br/>
    /// Includes the cookies itself and reasons for blocking or exemption.<br/>
    /// </summary>
    /// <param name="Cookie">The cookie object representing the cookie which was not sent.</param>
    /// <param name="BlockedReasons">The reason(s) the cookie was blocked. If empty means the cookie is included.</param>
    /// <param name="ExemptionReason">
    /// The reason the cookie should have been blocked by 3PCD but is exempted. A cookie could<br/>
    /// only have at most one exemption reason.<br/>
    /// </param>
    public record AssociatedCookieType(
      [property: System.Text.Json.Serialization.JsonPropertyName("cookie")]
      ChromeProtocol.Domains.Network.CookieType Cookie,
      [property: System.Text.Json.Serialization.JsonPropertyName("blockedReasons")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.CookieBlockedReasonType> BlockedReasons,
      [property: System.Text.Json.Serialization.JsonPropertyName("exemptionReason")]
      ChromeProtocol.Domains.Network.CookieExemptionReasonType? ExemptionReason = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Cookie parameter object</summary>
    /// <param name="Name">Cookie name.</param>
    /// <param name="Value">Cookie value.</param>
    /// <param name="Url">
    /// The request-URI to associate with the setting of the cookie. This value can affect the<br/>
    /// default domain, path, source port, and source scheme values of the created cookie.<br/>
    /// </param>
    /// <param name="Domain">Cookie domain.</param>
    /// <param name="Path">Cookie path.</param>
    /// <param name="Secure">True if cookie is secure.</param>
    /// <param name="HttpOnly">True if cookie is http-only.</param>
    /// <param name="SameSite">Cookie SameSite type.</param>
    /// <param name="Expires">Cookie expiration date, session cookie if not set</param>
    /// <param name="Priority">Cookie Priority.</param>
    /// <param name="SameParty">True if cookie is SameParty.</param>
    /// <param name="SourceScheme">Cookie source scheme type.</param>
    /// <param name="SourcePort">
    /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.<br/>
    /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.<br/>
    /// This is a temporary ability and it will be removed in the future.<br/>
    /// </param>
    /// <param name="PartitionKey">Cookie partition key. If not set, the cookie will be set as not partitioned.</param>
    public record CookieParamType(
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("domain")]
      string? Domain = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("path")]
      string? Path = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("secure")]
      bool? Secure = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("httpOnly")]
      bool? HttpOnly = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sameSite")]
      ChromeProtocol.Domains.Network.CookieSameSiteType? SameSite = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("expires")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType? Expires = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("priority")]
      ChromeProtocol.Domains.Network.CookiePriorityType? Priority = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sameParty")]
      bool? SameParty = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourceScheme")]
      ChromeProtocol.Domains.Network.CookieSourceSchemeType? SourceScheme = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourcePort")]
      int? SourcePort = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("partitionKey")]
      ChromeProtocol.Domains.Network.CookiePartitionKeyType? PartitionKey = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Authorization challenge for HTTP status code 401 or 407.</summary>
    /// <param name="Origin">Origin of the challenger.</param>
    /// <param name="Scheme">The authentication scheme used, such as basic or digest</param>
    /// <param name="Realm">The realm of the challenge. May be empty.</param>
    /// <param name="Source">Source of the authentication challenge.</param>
    public record AuthChallengeType(
      [property: System.Text.Json.Serialization.JsonPropertyName("origin")]
      string Origin,
      [property: System.Text.Json.Serialization.JsonPropertyName("scheme")]
      string Scheme,
      [property: System.Text.Json.Serialization.JsonPropertyName("realm")]
      string Realm,
      [property: System.Text.Json.Serialization.JsonPropertyName("source")]
      string? Source = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Response to an AuthChallenge.</summary>
    /// <param name="Response">
    /// The decision on what to do in response to the authorization challenge.  Default means<br/>
    /// deferring to the default behavior of the net stack, which will likely either the Cancel<br/>
    /// authentication or display a popup dialog box.<br/>
    /// </param>
    /// <param name="Username">
    /// The username to provide, possibly empty. Should only be set if response is<br/>
    /// ProvideCredentials.<br/>
    /// </param>
    /// <param name="Password">
    /// The password to provide, possibly empty. Should only be set if response is<br/>
    /// ProvideCredentials.<br/>
    /// </param>
    public record AuthChallengeResponseType(
      [property: System.Text.Json.Serialization.JsonPropertyName("response")]
      string Response,
      [property: System.Text.Json.Serialization.JsonPropertyName("username")]
      string? Username = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("password")]
      string? Password = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Stages of the interception to begin intercepting. Request will intercept before the request is<br/>
    /// sent. Response will intercept after the response is received.<br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record InterceptionStageType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Request pattern for interception.</summary>
    /// <param name="UrlPattern">
    /// Wildcards (`&#39;*&#39;` -&gt; zero or more, `&#39;?&#39;` -&gt; exactly one) are allowed. Escape character is<br/>
    /// backslash. Omitting is equivalent to `&quot;*&quot;`.<br/>
    /// </param>
    /// <param name="ResourceType">If set, only requests for matching resource types will be intercepted.</param>
    /// <param name="InterceptionStage">Stage at which to begin intercepting requests. Default is Request.</param>
    public record RequestPatternType(
      [property: System.Text.Json.Serialization.JsonPropertyName("urlPattern")]
      string? UrlPattern = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("resourceType")]
      ChromeProtocol.Domains.Network.ResourceTypeType? ResourceType = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("interceptionStage")]
      ChromeProtocol.Domains.Network.InterceptionStageType? InterceptionStage = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Information about a signed exchange signature.<br/>
    /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1<br/>
    /// </summary>
    /// <param name="Label">Signed exchange signature label.</param>
    /// <param name="Signature">The hex string of signed exchange signature.</param>
    /// <param name="Integrity">Signed exchange signature integrity.</param>
    /// <param name="ValidityUrl">Signed exchange signature validity Url.</param>
    /// <param name="Date">Signed exchange signature date.</param>
    /// <param name="Expires">Signed exchange signature expires.</param>
    /// <param name="CertUrl">Signed exchange signature cert Url.</param>
    /// <param name="CertSha256">The hex string of signed exchange signature cert sha256.</param>
    /// <param name="Certificates">The encoded certificates.</param>
    public record SignedExchangeSignatureType(
      [property: System.Text.Json.Serialization.JsonPropertyName("label")]
      string Label,
      [property: System.Text.Json.Serialization.JsonPropertyName("signature")]
      string Signature,
      [property: System.Text.Json.Serialization.JsonPropertyName("integrity")]
      string Integrity,
      [property: System.Text.Json.Serialization.JsonPropertyName("validityUrl")]
      string ValidityUrl,
      [property: System.Text.Json.Serialization.JsonPropertyName("date")]
      int Date,
      [property: System.Text.Json.Serialization.JsonPropertyName("expires")]
      int Expires,
      [property: System.Text.Json.Serialization.JsonPropertyName("certUrl")]
      string? CertUrl = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("certSha256")]
      string? CertSha256 = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("certificates")]
      System.Collections.Generic.IReadOnlyList<string>? Certificates = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Information about a signed exchange header.<br/>
    /// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation<br/>
    /// </summary>
    /// <param name="RequestUrl">Signed exchange request URL.</param>
    /// <param name="ResponseCode">Signed exchange response code.</param>
    /// <param name="ResponseHeaders">Signed exchange response headers.</param>
    /// <param name="Signatures">Signed exchange response signature.</param>
    /// <param name="HeaderIntegrity">Signed exchange header integrity hash in the form of `sha256-&lt;base64-hash-value&gt;`.</param>
    public record SignedExchangeHeaderType(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestUrl")]
      string RequestUrl,
      [property: System.Text.Json.Serialization.JsonPropertyName("responseCode")]
      int ResponseCode,
      [property: System.Text.Json.Serialization.JsonPropertyName("responseHeaders")]
      ChromeProtocol.Domains.Network.HeadersType ResponseHeaders,
      [property: System.Text.Json.Serialization.JsonPropertyName("signatures")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.SignedExchangeSignatureType> Signatures,
      [property: System.Text.Json.Serialization.JsonPropertyName("headerIntegrity")]
      string HeaderIntegrity
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Field type for a signed exchange related error.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record SignedExchangeErrorFieldType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Information about a signed exchange response.</summary>
    /// <param name="Message">Error message.</param>
    /// <param name="SignatureIndex">The index of the signature which caused the error.</param>
    /// <param name="ErrorField">The field which caused the error.</param>
    public record SignedExchangeErrorType(
      [property: System.Text.Json.Serialization.JsonPropertyName("message")]
      string Message,
      [property: System.Text.Json.Serialization.JsonPropertyName("signatureIndex")]
      int? SignatureIndex = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("errorField")]
      ChromeProtocol.Domains.Network.SignedExchangeErrorFieldType? ErrorField = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Information about a signed exchange response.</summary>
    /// <param name="OuterResponse">The outer response of signed HTTP exchange which was received from network.</param>
    /// <param name="Header">Information about the signed exchange header.</param>
    /// <param name="SecurityDetails">Security details for the signed exchange header.</param>
    /// <param name="Errors">Errors occurred while handling the signed exchange.</param>
    public record SignedExchangeInfoType(
      [property: System.Text.Json.Serialization.JsonPropertyName("outerResponse")]
      ChromeProtocol.Domains.Network.ResponseType OuterResponse,
      [property: System.Text.Json.Serialization.JsonPropertyName("header")]
      ChromeProtocol.Domains.Network.SignedExchangeHeaderType? Header = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("securityDetails")]
      ChromeProtocol.Domains.Network.SecurityDetailsType? SecurityDetails = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("errors")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.SignedExchangeErrorType>? Errors = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>List of content encodings supported by the backend.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ContentEncodingType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record PrivateNetworkRequestPolicyType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record IPAddressSpaceType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <param name="RequestTime">
    /// Timing&#39;s requestTime is a baseline in seconds, while the other numbers are ticks in<br/>
    /// milliseconds relatively to this requestTime. Matches ResourceTiming&#39;s requestTime for<br/>
    /// the same request (but not for redirected requests).<br/>
    /// </param>
    public record ConnectTimingType(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestTime")]
      double RequestTime
    ) : ChromeProtocol.Core.IType
    {
    }
    public record ClientSecurityStateType(
      [property: System.Text.Json.Serialization.JsonPropertyName("initiatorIsSecureContext")]
      bool InitiatorIsSecureContext,
      [property: System.Text.Json.Serialization.JsonPropertyName("initiatorIPAddressSpace")]
      ChromeProtocol.Domains.Network.IPAddressSpaceType InitiatorIPAddressSpace,
      [property: System.Text.Json.Serialization.JsonPropertyName("privateNetworkRequestPolicy")]
      ChromeProtocol.Domains.Network.PrivateNetworkRequestPolicyType PrivateNetworkRequestPolicy
    ) : ChromeProtocol.Core.IType
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CrossOriginOpenerPolicyValueType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    public record CrossOriginOpenerPolicyStatusType(
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      ChromeProtocol.Domains.Network.CrossOriginOpenerPolicyValueType Value,
      [property: System.Text.Json.Serialization.JsonPropertyName("reportOnlyValue")]
      ChromeProtocol.Domains.Network.CrossOriginOpenerPolicyValueType ReportOnlyValue,
      [property: System.Text.Json.Serialization.JsonPropertyName("reportingEndpoint")]
      string? ReportingEndpoint = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("reportOnlyReportingEndpoint")]
      string? ReportOnlyReportingEndpoint = default
    ) : ChromeProtocol.Core.IType
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CrossOriginEmbedderPolicyValueType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    public record CrossOriginEmbedderPolicyStatusType(
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      ChromeProtocol.Domains.Network.CrossOriginEmbedderPolicyValueType Value,
      [property: System.Text.Json.Serialization.JsonPropertyName("reportOnlyValue")]
      ChromeProtocol.Domains.Network.CrossOriginEmbedderPolicyValueType ReportOnlyValue,
      [property: System.Text.Json.Serialization.JsonPropertyName("reportingEndpoint")]
      string? ReportingEndpoint = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("reportOnlyReportingEndpoint")]
      string? ReportOnlyReportingEndpoint = default
    ) : ChromeProtocol.Core.IType
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ContentSecurityPolicySourceType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    public record ContentSecurityPolicyStatusType(
      [property: System.Text.Json.Serialization.JsonPropertyName("effectiveDirectives")]
      string EffectiveDirectives,
      [property: System.Text.Json.Serialization.JsonPropertyName("isEnforced")]
      bool IsEnforced,
      [property: System.Text.Json.Serialization.JsonPropertyName("source")]
      ChromeProtocol.Domains.Network.ContentSecurityPolicySourceType Source
    ) : ChromeProtocol.Core.IType
    {
    }
    public record SecurityIsolationStatusType(
      [property: System.Text.Json.Serialization.JsonPropertyName("coop")]
      ChromeProtocol.Domains.Network.CrossOriginOpenerPolicyStatusType? Coop = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("coep")]
      ChromeProtocol.Domains.Network.CrossOriginEmbedderPolicyStatusType? Coep = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("csp")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.ContentSecurityPolicyStatusType>? Csp = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>The status of a Reporting API report.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ReportStatusType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ReportIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>An object representing a report generated by the Reporting API.</summary>
    /// <param name="InitiatorUrl">The URL of the document that triggered the report.</param>
    /// <param name="Destination">The name of the endpoint group that should be used to deliver the report.</param>
    /// <param name="Type">The type of the report (specifies the set of data that is contained in the report body).</param>
    /// <param name="Timestamp">When the report was generated.</param>
    /// <param name="Depth">How many uploads deep the related request was.</param>
    /// <param name="CompletedAttempts">The number of delivery attempts made so far, not including an active attempt.</param>
    public record ReportingApiReportType(
      [property: System.Text.Json.Serialization.JsonPropertyName("id")]
      ChromeProtocol.Domains.Network.ReportIdType Id,
      [property: System.Text.Json.Serialization.JsonPropertyName("initiatorUrl")]
      string InitiatorUrl,
      [property: System.Text.Json.Serialization.JsonPropertyName("destination")]
      string Destination,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      string Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("depth")]
      int Depth,
      [property: System.Text.Json.Serialization.JsonPropertyName("completedAttempts")]
      int CompletedAttempts,
      [property: System.Text.Json.Serialization.JsonPropertyName("body")]
      System.Text.Json.Nodes.JsonObject Body,
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      ChromeProtocol.Domains.Network.ReportStatusType Status
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Url">The URL of the endpoint to which reports may be delivered.</param>
    /// <param name="GroupName">Name of the endpoint group.</param>
    public record ReportingApiEndpointType(
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("groupName")]
      string GroupName
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>An object providing the result of a network resource load.</summary>
    /// <param name="NetError">Optional values used for error reporting.</param>
    /// <param name="Stream">If successful, one of the following two fields holds the result.</param>
    /// <param name="Headers">Response headers.</param>
    public record LoadNetworkResourcePageResultType(
      [property: System.Text.Json.Serialization.JsonPropertyName("success")]
      bool Success,
      [property: System.Text.Json.Serialization.JsonPropertyName("netError")]
      double? NetError = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("netErrorName")]
      string? NetErrorName = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("httpStatusCode")]
      double? HttpStatusCode = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("stream")]
      ChromeProtocol.Domains.IO.StreamHandleType? Stream = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType? Headers = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// An options object that may be extended later to better support CORS,<br/>
    /// CORB and streaming.<br/>
    /// </summary>
    public record LoadNetworkResourceOptionsType(
      [property: System.Text.Json.Serialization.JsonPropertyName("disableCache")]
      bool DisableCache,
      [property: System.Text.Json.Serialization.JsonPropertyName("includeCredentials")]
      bool IncludeCredentials
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Fired when data chunk was received over the network.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="DataLength">Data chunk length.</param>
    /// <param name="EncodedDataLength">Actual bytes received (might be less than dataLength for compressed encodings).</param>
    /// <param name="Data">Data that was received. (Encoded as a base64 string when passed over JSON)</param>
    [ChromeProtocol.Core.MethodName("Network.dataReceived")]
    public record DataReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("dataLength")]
      int DataLength,
      [property: System.Text.Json.Serialization.JsonPropertyName("encodedDataLength")]
      int EncodedDataLength,
      [property: System.Text.Json.Serialization.JsonPropertyName("data")]
      string? Data = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when EventSource message is received.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="EventName">Message type.</param>
    /// <param name="EventId">Message identifier.</param>
    /// <param name="Data">Message content.</param>
    [ChromeProtocol.Core.MethodName("Network.eventSourceMessageReceived")]
    public record EventSourceMessageReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("eventName")]
      string EventName,
      [property: System.Text.Json.Serialization.JsonPropertyName("eventId")]
      string EventId,
      [property: System.Text.Json.Serialization.JsonPropertyName("data")]
      string Data
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when HTTP request has failed to load.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="Type">Resource type.</param>
    /// <param name="ErrorText">Error message. List of network errors: https://cs.chromium.org/chromium/src/net/base/net_error_list.h</param>
    /// <param name="Canceled">True if loading was canceled.</param>
    /// <param name="BlockedReason">The reason why loading was blocked, if any.</param>
    /// <param name="CorsErrorStatus">The reason why loading was blocked by CORS, if any.</param>
    [ChromeProtocol.Core.MethodName("Network.loadingFailed")]
    public record LoadingFailed(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      ChromeProtocol.Domains.Network.ResourceTypeType Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("errorText")]
      string ErrorText,
      [property: System.Text.Json.Serialization.JsonPropertyName("canceled")]
      bool? Canceled = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("blockedReason")]
      ChromeProtocol.Domains.Network.BlockedReasonType? BlockedReason = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("corsErrorStatus")]
      ChromeProtocol.Domains.Network.CorsErrorStatusType? CorsErrorStatus = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when HTTP request has finished loading.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="EncodedDataLength">Total number of bytes received for this request.</param>
    [ChromeProtocol.Core.MethodName("Network.loadingFinished")]
    public record LoadingFinished(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("encodedDataLength")]
      double EncodedDataLength
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Details of an intercepted HTTP request, which must be either allowed, blocked, modified or<br/>
    /// mocked.<br/>
    /// Deprecated, use Fetch.requestPaused instead.<br/>
    /// </summary>
    /// <param name="InterceptionId">
    /// Each request the page makes will have a unique id, however if any redirects are encountered<br/>
    /// while processing that fetch, they will be reported with the same id as the original fetch.<br/>
    /// Likewise if HTTP authentication is needed then the same fetch id will be used.<br/>
    /// </param>
    /// <param name="FrameId">The id of the frame that initiated the request.</param>
    /// <param name="ResourceType">How the requested resource will be used.</param>
    /// <param name="IsNavigationRequest">Whether this is a navigation request, which can abort the navigation completely.</param>
    /// <param name="IsDownload">
    /// Set if the request is a navigation that will result in a download.<br/>
    /// Only present after response is received from the server (i.e. HeadersReceived stage).<br/>
    /// </param>
    /// <param name="RedirectUrl">Redirect location, only sent if a redirect was intercepted.</param>
    /// <param name="AuthChallenge">
    /// Details of the Authorization Challenge encountered. If this is set then<br/>
    /// continueInterceptedRequest must contain an authChallengeResponse.<br/>
    /// </param>
    /// <param name="ResponseErrorReason">
    /// Response error if intercepted at response stage or if redirect occurred while intercepting<br/>
    /// request.<br/>
    /// </param>
    /// <param name="ResponseStatusCode">
    /// Response code if intercepted at response stage or if redirect occurred while intercepting<br/>
    /// request or auth retry occurred.<br/>
    /// </param>
    /// <param name="ResponseHeaders">
    /// Response headers if intercepted at the response stage or if redirect occurred while<br/>
    /// intercepting request or auth retry occurred.<br/>
    /// </param>
    /// <param name="RequestId">
    /// If the intercepted request had a corresponding requestWillBeSent event fired for it, then<br/>
    /// this requestId will be the same as the requestId present in the requestWillBeSent event.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.requestIntercepted")]
    [System.Obsolete("This event marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record RequestIntercepted(
      [property: System.Text.Json.Serialization.JsonPropertyName("interceptionId")]
      ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId,
      [property: System.Text.Json.Serialization.JsonPropertyName("request")]
      ChromeProtocol.Domains.Network.RequestType Request,
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: System.Text.Json.Serialization.JsonPropertyName("resourceType")]
      ChromeProtocol.Domains.Network.ResourceTypeType ResourceType,
      [property: System.Text.Json.Serialization.JsonPropertyName("isNavigationRequest")]
      bool IsNavigationRequest,
      [property: System.Text.Json.Serialization.JsonPropertyName("isDownload")]
      bool? IsDownload = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("redirectUrl")]
      string? RedirectUrl = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("authChallenge")]
      ChromeProtocol.Domains.Network.AuthChallengeType? AuthChallenge = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("responseErrorReason")]
      ChromeProtocol.Domains.Network.ErrorReasonType? ResponseErrorReason = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("responseStatusCode")]
      int? ResponseStatusCode = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("responseHeaders")]
      ChromeProtocol.Domains.Network.HeadersType? ResponseHeaders = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType? RequestId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired if request ended up loading from cache.</summary>
    /// <param name="RequestId">Request identifier.</param>
    [ChromeProtocol.Core.MethodName("Network.requestServedFromCache")]
    public record RequestServedFromCache(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when page is about to send HTTP request.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="LoaderId">Loader identifier. Empty string if the request is fetched from worker.</param>
    /// <param name="DocumentURL">URL of the document this request is loaded for.</param>
    /// <param name="Request">Request data.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="WallTime">Timestamp.</param>
    /// <param name="Initiator">Request initiator.</param>
    /// <param name="RedirectHasExtraInfo">
    /// In the case that redirectResponse is populated, this flag indicates whether<br/>
    /// requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted<br/>
    /// for the request which was just redirected.<br/>
    /// </param>
    /// <param name="RedirectResponse">Redirect response data.</param>
    /// <param name="Type">Type of this resource.</param>
    /// <param name="FrameId">Frame identifier.</param>
    /// <param name="HasUserGesture">Whether the request is initiated by a user gesture. Defaults to false.</param>
    [ChromeProtocol.Core.MethodName("Network.requestWillBeSent")]
    public record RequestWillBeSent(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: System.Text.Json.Serialization.JsonPropertyName("documentURL")]
      string DocumentURL,
      [property: System.Text.Json.Serialization.JsonPropertyName("request")]
      ChromeProtocol.Domains.Network.RequestType Request,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("wallTime")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType WallTime,
      [property: System.Text.Json.Serialization.JsonPropertyName("initiator")]
      ChromeProtocol.Domains.Network.InitiatorType Initiator,
      [property: System.Text.Json.Serialization.JsonPropertyName("redirectHasExtraInfo")]
      bool RedirectHasExtraInfo,
      [property: System.Text.Json.Serialization.JsonPropertyName("redirectResponse")]
      ChromeProtocol.Domains.Network.ResponseType? RedirectResponse = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      ChromeProtocol.Domains.Network.ResourceTypeType? Type = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType? FrameId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("hasUserGesture")]
      bool? HasUserGesture = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when resource loading priority is changed</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="NewPriority">New priority</param>
    /// <param name="Timestamp">Timestamp.</param>
    [ChromeProtocol.Core.MethodName("Network.resourceChangedPriority")]
    public record ResourceChangedPriority(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("newPriority")]
      ChromeProtocol.Domains.Network.ResourcePriorityType NewPriority,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when a signed exchange was received over the network</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Info">Information about the signed exchange response.</param>
    [ChromeProtocol.Core.MethodName("Network.signedExchangeReceived")]
    public record SignedExchangeReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("info")]
      ChromeProtocol.Domains.Network.SignedExchangeInfoType Info
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when HTTP response is available.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="LoaderId">Loader identifier. Empty string if the request is fetched from worker.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="Type">Resource type.</param>
    /// <param name="Response">Response data.</param>
    /// <param name="HasExtraInfo">
    /// Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be<br/>
    /// or were emitted for this request.<br/>
    /// </param>
    /// <param name="FrameId">Frame identifier.</param>
    [ChromeProtocol.Core.MethodName("Network.responseReceived")]
    public record ResponseReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("loaderId")]
      ChromeProtocol.Domains.Network.LoaderIdType LoaderId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      ChromeProtocol.Domains.Network.ResourceTypeType Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("response")]
      ChromeProtocol.Domains.Network.ResponseType Response,
      [property: System.Text.Json.Serialization.JsonPropertyName("hasExtraInfo")]
      bool HasExtraInfo,
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType? FrameId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebSocket is closed.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketClosed")]
    public record WebSocketClosed(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired upon WebSocket creation.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Url">WebSocket request URL.</param>
    /// <param name="Initiator">Request initiator.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketCreated")]
    public record WebSocketCreated(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("initiator")]
      ChromeProtocol.Domains.Network.InitiatorType? Initiator = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebSocket message error occurs.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="ErrorMessage">WebSocket error message.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketFrameError")]
    public record WebSocketFrameError(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("errorMessage")]
      string ErrorMessage
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebSocket message is received.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="Response">WebSocket response data.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketFrameReceived")]
    public record WebSocketFrameReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("response")]
      ChromeProtocol.Domains.Network.WebSocketFrameType Response
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebSocket message is sent.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="Response">WebSocket response data.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketFrameSent")]
    public record WebSocketFrameSent(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("response")]
      ChromeProtocol.Domains.Network.WebSocketFrameType Response
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebSocket handshake response becomes available.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="Response">WebSocket response data.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketHandshakeResponseReceived")]
    public record WebSocketHandshakeResponseReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("response")]
      ChromeProtocol.Domains.Network.WebSocketResponseType Response
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebSocket is about to initiate handshake.</summary>
    /// <param name="RequestId">Request identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="WallTime">UTC Timestamp.</param>
    /// <param name="Request">WebSocket request data.</param>
    [ChromeProtocol.Core.MethodName("Network.webSocketWillSendHandshakeRequest")]
    public record WebSocketWillSendHandshakeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("wallTime")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType WallTime,
      [property: System.Text.Json.Serialization.JsonPropertyName("request")]
      ChromeProtocol.Domains.Network.WebSocketRequestType Request
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired upon WebTransport creation.</summary>
    /// <param name="TransportId">WebTransport identifier.</param>
    /// <param name="Url">WebTransport request URL.</param>
    /// <param name="Timestamp">Timestamp.</param>
    /// <param name="Initiator">Request initiator.</param>
    [ChromeProtocol.Core.MethodName("Network.webTransportCreated")]
    public record WebTransportCreated(
      [property: System.Text.Json.Serialization.JsonPropertyName("transportId")]
      ChromeProtocol.Domains.Network.RequestIdType TransportId,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp,
      [property: System.Text.Json.Serialization.JsonPropertyName("initiator")]
      ChromeProtocol.Domains.Network.InitiatorType? Initiator = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebTransport handshake is finished.</summary>
    /// <param name="TransportId">WebTransport identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    [ChromeProtocol.Core.MethodName("Network.webTransportConnectionEstablished")]
    public record WebTransportConnectionEstablished(
      [property: System.Text.Json.Serialization.JsonPropertyName("transportId")]
      ChromeProtocol.Domains.Network.RequestIdType TransportId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when WebTransport is disposed.</summary>
    /// <param name="TransportId">WebTransport identifier.</param>
    /// <param name="Timestamp">Timestamp.</param>
    [ChromeProtocol.Core.MethodName("Network.webTransportClosed")]
    public record WebTransportClosed(
      [property: System.Text.Json.Serialization.JsonPropertyName("transportId")]
      ChromeProtocol.Domains.Network.RequestIdType TransportId,
      [property: System.Text.Json.Serialization.JsonPropertyName("timestamp")]
      ChromeProtocol.Domains.Network.MonotonicTimeType Timestamp
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when additional information about a requestWillBeSent event is available from the<br/>
    /// network stack. Not every requestWillBeSent event will have an additional<br/>
    /// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent<br/>
    /// or requestWillBeSentExtraInfo will be fired first for the same request.<br/>
    /// </summary>
    /// <param name="RequestId">Request identifier. Used to match this information to an existing requestWillBeSent event.</param>
    /// <param name="AssociatedCookies">
    /// A list of cookies potentially associated to the requested URL. This includes both cookies sent with<br/>
    /// the request and the ones not sent; the latter are distinguished by having blockedReasons field set.<br/>
    /// </param>
    /// <param name="Headers">Raw request headers as they will be sent over the wire.</param>
    /// <param name="ConnectTiming">Connection timing information for the request.</param>
    /// <param name="ClientSecurityState">The client security state set for the request.</param>
    /// <param name="SiteHasCookieInOtherPartition">Whether the site has partitioned cookies stored in a partition different than the current one.</param>
    [ChromeProtocol.Core.MethodName("Network.requestWillBeSentExtraInfo")]
    public record RequestWillBeSentExtraInfo(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("associatedCookies")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.AssociatedCookieType> AssociatedCookies,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers,
      [property: System.Text.Json.Serialization.JsonPropertyName("connectTiming")]
      ChromeProtocol.Domains.Network.ConnectTimingType ConnectTiming,
      [property: System.Text.Json.Serialization.JsonPropertyName("clientSecurityState")]
      ChromeProtocol.Domains.Network.ClientSecurityStateType? ClientSecurityState = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("siteHasCookieInOtherPartition")]
      bool? SiteHasCookieInOtherPartition = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when additional information about a responseReceived event is available from the network<br/>
    /// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for<br/>
    /// it, and responseReceivedExtraInfo may be fired before or after responseReceived.<br/>
    /// </summary>
    /// <param name="RequestId">Request identifier. Used to match this information to another responseReceived event.</param>
    /// <param name="BlockedCookies">
    /// A list of cookies which were not stored from the response along with the corresponding<br/>
    /// reasons for blocking. The cookies here may not be valid due to syntax errors, which<br/>
    /// are represented by the invalid cookie line string instead of a proper cookie.<br/>
    /// </param>
    /// <param name="Headers">Raw response headers as they were received over the wire.</param>
    /// <param name="ResourceIPAddressSpace">
    /// The IP address space of the resource. The address space can only be determined once the transport<br/>
    /// established the connection, so we can&#39;t send it in `requestWillBeSentExtraInfo`.<br/>
    /// </param>
    /// <param name="StatusCode">
    /// The status code of the response. This is useful in cases the request failed and no responseReceived<br/>
    /// event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code<br/>
    /// for cached requests, where the status in responseReceived is a 200 and this will be 304.<br/>
    /// </param>
    /// <param name="HeadersText">
    /// Raw response header text as it was received over the wire. The raw text may not always be<br/>
    /// available, such as in the case of HTTP/2 or QUIC.<br/>
    /// </param>
    /// <param name="CookiePartitionKey">
    /// The cookie partition key that will be used to store partitioned cookies set in this response.<br/>
    /// Only sent when partitioned cookies are enabled.<br/>
    /// </param>
    /// <param name="CookiePartitionKeyOpaque">True if partitioned cookies are enabled, but the partition key is not serializable to string.</param>
    /// <param name="ExemptedCookies">
    /// A list of cookies which should have been blocked by 3PCD but are exempted and stored from<br/>
    /// the response with the corresponding reason.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.responseReceivedExtraInfo")]
    public record ResponseReceivedExtraInfo(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("blockedCookies")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.BlockedSetCookieWithReasonType> BlockedCookies,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers,
      [property: System.Text.Json.Serialization.JsonPropertyName("resourceIPAddressSpace")]
      ChromeProtocol.Domains.Network.IPAddressSpaceType ResourceIPAddressSpace,
      [property: System.Text.Json.Serialization.JsonPropertyName("statusCode")]
      int StatusCode,
      [property: System.Text.Json.Serialization.JsonPropertyName("headersText")]
      string? HeadersText = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("cookiePartitionKey")]
      ChromeProtocol.Domains.Network.CookiePartitionKeyType? CookiePartitionKey = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("cookiePartitionKeyOpaque")]
      bool? CookiePartitionKeyOpaque = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("exemptedCookies")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.ExemptedSetCookieWithReasonType>? ExemptedCookies = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when 103 Early Hints headers is received in addition to the common response.<br/>
    /// Not every responseReceived event will have an responseReceivedEarlyHints fired.<br/>
    /// Only one responseReceivedEarlyHints may be fired for eached responseReceived event.<br/>
    /// </summary>
    /// <param name="RequestId">Request identifier. Used to match this information to another responseReceived event.</param>
    /// <param name="Headers">Raw response headers as they were received over the wire.</param>
    [ChromeProtocol.Core.MethodName("Network.responseReceivedEarlyHints")]
    public record ResponseReceivedEarlyHints(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired exactly once for each Trust Token operation. Depending on<br/>
    /// the type of the operation and whether the operation succeeded or<br/>
    /// failed, the event is fired before the corresponding request was sent<br/>
    /// or after the response was received.<br/>
    /// </summary>
    /// <param name="Status">
    /// Detailed success or error status of the operation.<br/>
    /// &#39;AlreadyExists&#39; also signifies a successful operation, as the result<br/>
    /// of the operation already exists und thus, the operation was abort<br/>
    /// preemptively (e.g. a cache hit).<br/>
    /// </param>
    /// <param name="TopLevelOrigin">Top level origin. The context in which the operation was attempted.</param>
    /// <param name="IssuerOrigin">Origin of the issuer in case of a &quot;Issuance&quot; or &quot;Redemption&quot; operation.</param>
    /// <param name="IssuedTokenCount">The number of obtained Trust Tokens on a successful &quot;Issuance&quot; operation.</param>
    [ChromeProtocol.Core.MethodName("Network.trustTokenOperationDone")]
    public record TrustTokenOperationDone(
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      string Status,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      ChromeProtocol.Domains.Network.TrustTokenOperationTypeType Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("topLevelOrigin")]
      string? TopLevelOrigin = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("issuerOrigin")]
      string? IssuerOrigin = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("issuedTokenCount")]
      int? IssuedTokenCount = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired once security policy has been updated.</summary>
    [ChromeProtocol.Core.MethodName("Network.policyUpdated")]
    public record PolicyUpdated() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired once when parsing the .wbn file has succeeded.<br/>
    /// The event contains the information about the web bundle contents.<br/>
    /// </summary>
    /// <param name="RequestId">Request identifier. Used to match this information to another event.</param>
    /// <param name="Urls">A list of URLs of resources in the subresource Web Bundle.</param>
    [ChromeProtocol.Core.MethodName("Network.subresourceWebBundleMetadataReceived")]
    public record SubresourceWebBundleMetadataReceived(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("urls")]
      System.Collections.Generic.IReadOnlyList<string> Urls
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired once when parsing the .wbn file has failed.</summary>
    /// <param name="RequestId">Request identifier. Used to match this information to another event.</param>
    /// <param name="ErrorMessage">Error message</param>
    [ChromeProtocol.Core.MethodName("Network.subresourceWebBundleMetadataError")]
    public record SubresourceWebBundleMetadataError(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("errorMessage")]
      string ErrorMessage
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when handling requests for resources within a .wbn file.<br/>
    /// Note: this will only be fired for resources that are requested by the webpage.<br/>
    /// </summary>
    /// <param name="InnerRequestId">Request identifier of the subresource request</param>
    /// <param name="InnerRequestURL">URL of the subresource resource.</param>
    /// <param name="BundleRequestId">
    /// Bundle request identifier. Used to match this information to another event.<br/>
    /// This made be absent in case when the instrumentation was enabled only<br/>
    /// after webbundle was parsed.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.subresourceWebBundleInnerResponseParsed")]
    public record SubresourceWebBundleInnerResponseParsed(
      [property: System.Text.Json.Serialization.JsonPropertyName("innerRequestId")]
      ChromeProtocol.Domains.Network.RequestIdType InnerRequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("innerRequestURL")]
      string InnerRequestURL,
      [property: System.Text.Json.Serialization.JsonPropertyName("bundleRequestId")]
      ChromeProtocol.Domains.Network.RequestIdType? BundleRequestId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when request for resources within a .wbn file failed.</summary>
    /// <param name="InnerRequestId">Request identifier of the subresource request</param>
    /// <param name="InnerRequestURL">URL of the subresource resource.</param>
    /// <param name="ErrorMessage">Error message</param>
    /// <param name="BundleRequestId">
    /// Bundle request identifier. Used to match this information to another event.<br/>
    /// This made be absent in case when the instrumentation was enabled only<br/>
    /// after webbundle was parsed.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.subresourceWebBundleInnerResponseError")]
    public record SubresourceWebBundleInnerResponseError(
      [property: System.Text.Json.Serialization.JsonPropertyName("innerRequestId")]
      ChromeProtocol.Domains.Network.RequestIdType InnerRequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("innerRequestURL")]
      string InnerRequestURL,
      [property: System.Text.Json.Serialization.JsonPropertyName("errorMessage")]
      string ErrorMessage,
      [property: System.Text.Json.Serialization.JsonPropertyName("bundleRequestId")]
      ChromeProtocol.Domains.Network.RequestIdType? BundleRequestId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Is sent whenever a new report is added.<br/>
    /// And after &#39;enableReportingApi&#39; for all existing reports.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Network.reportingApiReportAdded")]
    public record ReportingApiReportAdded(
      [property: System.Text.Json.Serialization.JsonPropertyName("report")]
      ChromeProtocol.Domains.Network.ReportingApiReportType Report
    ) : ChromeProtocol.Core.IEvent
    {
    }
    [ChromeProtocol.Core.MethodName("Network.reportingApiReportUpdated")]
    public record ReportingApiReportUpdated(
      [property: System.Text.Json.Serialization.JsonPropertyName("report")]
      ChromeProtocol.Domains.Network.ReportingApiReportType Report
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <param name="Origin">Origin of the document(s) which configured the endpoints.</param>
    [ChromeProtocol.Core.MethodName("Network.reportingApiEndpointsChangedForOrigin")]
    public record ReportingApiEndpointsChangedForOrigin(
      [property: System.Text.Json.Serialization.JsonPropertyName("origin")]
      string Origin,
      [property: System.Text.Json.Serialization.JsonPropertyName("endpoints")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.ReportingApiEndpointType> Endpoints
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.</summary>
    /// <param name="Encodings">List of accepted content encodings.</param>
    public static ChromeProtocol.Domains.Network.SetAcceptedEncodingsRequest SetAcceptedEncodings(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.ContentEncodingType> Encodings)    
    {
      return new ChromeProtocol.Domains.Network.SetAcceptedEncodingsRequest(Encodings);
    }
    /// <summary>Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.</summary>
    /// <param name="Encodings">List of accepted content encodings.</param>
    [ChromeProtocol.Core.MethodName("Network.setAcceptedEncodings")]
    public record SetAcceptedEncodingsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("encodings")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.ContentEncodingType> Encodings
    ) : ChromeProtocol.Core.ICommand<SetAcceptedEncodingsRequestResult>
    {
    }
    public record SetAcceptedEncodingsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears accepted encodings set by setAcceptedEncodings</summary>
    public static ChromeProtocol.Domains.Network.ClearAcceptedEncodingsOverrideRequest ClearAcceptedEncodingsOverride()    
    {
      return new ChromeProtocol.Domains.Network.ClearAcceptedEncodingsOverrideRequest();
    }
    /// <summary>Clears accepted encodings set by setAcceptedEncodings</summary>
    [ChromeProtocol.Core.MethodName("Network.clearAcceptedEncodingsOverride")]
    public record ClearAcceptedEncodingsOverrideRequest() : ChromeProtocol.Core.ICommand<ClearAcceptedEncodingsOverrideRequestResult>
    {
    }
    public record ClearAcceptedEncodingsOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Tells whether clearing browser cache is supported.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Network.CanClearBrowserCacheRequest CanClearBrowserCache()    
    {
      return new ChromeProtocol.Domains.Network.CanClearBrowserCacheRequest();
    }
    /// <summary>Tells whether clearing browser cache is supported.</summary>
    [ChromeProtocol.Core.MethodName("Network.canClearBrowserCache")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record CanClearBrowserCacheRequest() : ChromeProtocol.Core.ICommand<CanClearBrowserCacheRequestResult>
    {
    }
    /// <param name="Result">True if browser cache can be cleared.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record CanClearBrowserCacheRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("result")]
      bool Result
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Tells whether clearing browser cookies is supported.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Network.CanClearBrowserCookiesRequest CanClearBrowserCookies()    
    {
      return new ChromeProtocol.Domains.Network.CanClearBrowserCookiesRequest();
    }
    /// <summary>Tells whether clearing browser cookies is supported.</summary>
    [ChromeProtocol.Core.MethodName("Network.canClearBrowserCookies")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record CanClearBrowserCookiesRequest() : ChromeProtocol.Core.ICommand<CanClearBrowserCookiesRequestResult>
    {
    }
    /// <param name="Result">True if browser cookies can be cleared.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record CanClearBrowserCookiesRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("result")]
      bool Result
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Tells whether emulation of network conditions is supported.</summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Network.CanEmulateNetworkConditionsRequest CanEmulateNetworkConditions()    
    {
      return new ChromeProtocol.Domains.Network.CanEmulateNetworkConditionsRequest();
    }
    /// <summary>Tells whether emulation of network conditions is supported.</summary>
    [ChromeProtocol.Core.MethodName("Network.canEmulateNetworkConditions")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record CanEmulateNetworkConditionsRequest() : ChromeProtocol.Core.ICommand<CanEmulateNetworkConditionsRequestResult>
    {
    }
    /// <param name="Result">True if emulation of network conditions is supported.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record CanEmulateNetworkConditionsRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("result")]
      bool Result
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears browser cache.</summary>
    public static ChromeProtocol.Domains.Network.ClearBrowserCacheRequest ClearBrowserCache()    
    {
      return new ChromeProtocol.Domains.Network.ClearBrowserCacheRequest();
    }
    /// <summary>Clears browser cache.</summary>
    [ChromeProtocol.Core.MethodName("Network.clearBrowserCache")]
    public record ClearBrowserCacheRequest() : ChromeProtocol.Core.ICommand<ClearBrowserCacheRequestResult>
    {
    }
    public record ClearBrowserCacheRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Clears browser cookies.</summary>
    public static ChromeProtocol.Domains.Network.ClearBrowserCookiesRequest ClearBrowserCookies()    
    {
      return new ChromeProtocol.Domains.Network.ClearBrowserCookiesRequest();
    }
    /// <summary>Clears browser cookies.</summary>
    [ChromeProtocol.Core.MethodName("Network.clearBrowserCookies")]
    public record ClearBrowserCookiesRequest() : ChromeProtocol.Core.ICommand<ClearBrowserCookiesRequestResult>
    {
    }
    public record ClearBrowserCookiesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Response to Network.requestIntercepted which either modifies the request to continue with any<br/>
    /// modifications, or blocks it, or completes it with the provided response bytes. If a network<br/>
    /// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted<br/>
    /// event will be sent with the same InterceptionId.<br/>
    /// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.<br/>
    /// </summary>
    /// <param name="ErrorReason">
    /// If set this causes the request to fail with the given reason. Passing `Aborted` for requests<br/>
    /// marked with `isNavigationRequest` also cancels the navigation. Must not be set in response<br/>
    /// to an authChallenge.<br/>
    /// </param>
    /// <param name="RawResponse">
    /// If set the requests completes using with the provided base64 encoded raw response, including<br/>
    /// HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)<br/>
    /// </param>
    /// <param name="Url">
    /// If set the request url will be modified in a way that&#39;s not observable by page. Must not be<br/>
    /// set in response to an authChallenge.<br/>
    /// </param>
    /// <param name="Method">
    /// If set this allows the request method to be overridden. Must not be set in response to an<br/>
    /// authChallenge.<br/>
    /// </param>
    /// <param name="PostData">If set this allows postData to be set. Must not be set in response to an authChallenge.</param>
    /// <param name="Headers">
    /// If set this allows the request headers to be changed. Must not be set in response to an<br/>
    /// authChallenge.<br/>
    /// </param>
    /// <param name="AuthChallengeResponse">Response to a requestIntercepted with an authChallenge. Must not be set otherwise.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Network.ContinueInterceptedRequestRequest ContinueInterceptedRequest(ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId, ChromeProtocol.Domains.Network.ErrorReasonType? ErrorReason = default, string? RawResponse = default, string? Url = default, string? Method = default, string? PostData = default, ChromeProtocol.Domains.Network.HeadersType? Headers = default, ChromeProtocol.Domains.Network.AuthChallengeResponseType? AuthChallengeResponse = default)    
    {
      return new ChromeProtocol.Domains.Network.ContinueInterceptedRequestRequest(InterceptionId, ErrorReason, RawResponse, Url, Method, PostData, Headers, AuthChallengeResponse);
    }
    /// <summary>
    /// Response to Network.requestIntercepted which either modifies the request to continue with any<br/>
    /// modifications, or blocks it, or completes it with the provided response bytes. If a network<br/>
    /// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted<br/>
    /// event will be sent with the same InterceptionId.<br/>
    /// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.<br/>
    /// </summary>
    /// <param name="ErrorReason">
    /// If set this causes the request to fail with the given reason. Passing `Aborted` for requests<br/>
    /// marked with `isNavigationRequest` also cancels the navigation. Must not be set in response<br/>
    /// to an authChallenge.<br/>
    /// </param>
    /// <param name="RawResponse">
    /// If set the requests completes using with the provided base64 encoded raw response, including<br/>
    /// HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)<br/>
    /// </param>
    /// <param name="Url">
    /// If set the request url will be modified in a way that&#39;s not observable by page. Must not be<br/>
    /// set in response to an authChallenge.<br/>
    /// </param>
    /// <param name="Method">
    /// If set this allows the request method to be overridden. Must not be set in response to an<br/>
    /// authChallenge.<br/>
    /// </param>
    /// <param name="PostData">If set this allows postData to be set. Must not be set in response to an authChallenge.</param>
    /// <param name="Headers">
    /// If set this allows the request headers to be changed. Must not be set in response to an<br/>
    /// authChallenge.<br/>
    /// </param>
    /// <param name="AuthChallengeResponse">Response to a requestIntercepted with an authChallenge. Must not be set otherwise.</param>
    [ChromeProtocol.Core.MethodName("Network.continueInterceptedRequest")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ContinueInterceptedRequestRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("interceptionId")]
      ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId,
      [property: System.Text.Json.Serialization.JsonPropertyName("errorReason")]
      ChromeProtocol.Domains.Network.ErrorReasonType? ErrorReason = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("rawResponse")]
      string? RawResponse = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("method")]
      string? Method = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("postData")]
      string? PostData = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType? Headers = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("authChallengeResponse")]
      ChromeProtocol.Domains.Network.AuthChallengeResponseType? AuthChallengeResponse = default
    ) : ChromeProtocol.Core.ICommand<ContinueInterceptedRequestRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record ContinueInterceptedRequestRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Deletes browser cookies with matching name and url or domain/path/partitionKey pair.</summary>
    /// <param name="Name">Name of the cookies to remove.</param>
    /// <param name="Url">
    /// If specified, deletes all the cookies with the given name where domain and path match<br/>
    /// provided URL.<br/>
    /// </param>
    /// <param name="Domain">If specified, deletes only cookies with the exact domain.</param>
    /// <param name="Path">If specified, deletes only cookies with the exact path.</param>
    /// <param name="PartitionKey">
    /// If specified, deletes only cookies with the the given name and partitionKey where<br/>
    /// all partition key attributes match the cookie partition key attribute.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Network.DeleteCookiesRequest DeleteCookies(string Name, string? Url = default, string? Domain = default, string? Path = default, ChromeProtocol.Domains.Network.CookiePartitionKeyType? PartitionKey = default)    
    {
      return new ChromeProtocol.Domains.Network.DeleteCookiesRequest(Name, Url, Domain, Path, PartitionKey);
    }
    /// <summary>Deletes browser cookies with matching name and url or domain/path/partitionKey pair.</summary>
    /// <param name="Name">Name of the cookies to remove.</param>
    /// <param name="Url">
    /// If specified, deletes all the cookies with the given name where domain and path match<br/>
    /// provided URL.<br/>
    /// </param>
    /// <param name="Domain">If specified, deletes only cookies with the exact domain.</param>
    /// <param name="Path">If specified, deletes only cookies with the exact path.</param>
    /// <param name="PartitionKey">
    /// If specified, deletes only cookies with the the given name and partitionKey where<br/>
    /// all partition key attributes match the cookie partition key attribute.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.deleteCookies")]
    public record DeleteCookiesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("domain")]
      string? Domain = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("path")]
      string? Path = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("partitionKey")]
      ChromeProtocol.Domains.Network.CookiePartitionKeyType? PartitionKey = default
    ) : ChromeProtocol.Core.ICommand<DeleteCookiesRequestResult>
    {
    }
    public record DeleteCookiesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Disables network tracking, prevents network events from being sent to the client.</summary>
    public static ChromeProtocol.Domains.Network.DisableRequest Disable()    
    {
      return new ChromeProtocol.Domains.Network.DisableRequest();
    }
    /// <summary>Disables network tracking, prevents network events from being sent to the client.</summary>
    [ChromeProtocol.Core.MethodName("Network.disable")]
    public record DisableRequest() : ChromeProtocol.Core.ICommand<DisableRequestResult>
    {
    }
    public record DisableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Activates emulation of network conditions.</summary>
    /// <param name="Offline">True to emulate internet disconnection.</param>
    /// <param name="Latency">Minimum latency from request sent to response headers received (ms).</param>
    /// <param name="DownloadThroughput">Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.</param>
    /// <param name="UploadThroughput">Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.</param>
    /// <param name="ConnectionType">Connection type if known.</param>
    /// <param name="PacketLoss">WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.</param>
    /// <param name="PacketQueueLength">WebRTC packet queue length (packet). 0 removes any queue length limitations.</param>
    /// <param name="PacketReordering">WebRTC packetReordering feature.</param>
    public static ChromeProtocol.Domains.Network.EmulateNetworkConditionsRequest EmulateNetworkConditions(bool Offline, double Latency, double DownloadThroughput, double UploadThroughput, ChromeProtocol.Domains.Network.ConnectionTypeType? ConnectionType = default, double? PacketLoss = default, int? PacketQueueLength = default, bool? PacketReordering = default)    
    {
      return new ChromeProtocol.Domains.Network.EmulateNetworkConditionsRequest(Offline, Latency, DownloadThroughput, UploadThroughput, ConnectionType, PacketLoss, PacketQueueLength, PacketReordering);
    }
    /// <summary>Activates emulation of network conditions.</summary>
    /// <param name="Offline">True to emulate internet disconnection.</param>
    /// <param name="Latency">Minimum latency from request sent to response headers received (ms).</param>
    /// <param name="DownloadThroughput">Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.</param>
    /// <param name="UploadThroughput">Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.</param>
    /// <param name="ConnectionType">Connection type if known.</param>
    /// <param name="PacketLoss">WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.</param>
    /// <param name="PacketQueueLength">WebRTC packet queue length (packet). 0 removes any queue length limitations.</param>
    /// <param name="PacketReordering">WebRTC packetReordering feature.</param>
    [ChromeProtocol.Core.MethodName("Network.emulateNetworkConditions")]
    public record EmulateNetworkConditionsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("offline")]
      bool Offline,
      [property: System.Text.Json.Serialization.JsonPropertyName("latency")]
      double Latency,
      [property: System.Text.Json.Serialization.JsonPropertyName("downloadThroughput")]
      double DownloadThroughput,
      [property: System.Text.Json.Serialization.JsonPropertyName("uploadThroughput")]
      double UploadThroughput,
      [property: System.Text.Json.Serialization.JsonPropertyName("connectionType")]
      ChromeProtocol.Domains.Network.ConnectionTypeType? ConnectionType = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("packetLoss")]
      double? PacketLoss = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("packetQueueLength")]
      int? PacketQueueLength = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("packetReordering")]
      bool? PacketReordering = default
    ) : ChromeProtocol.Core.ICommand<EmulateNetworkConditionsRequestResult>
    {
    }
    public record EmulateNetworkConditionsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enables network tracking, network events will now be delivered to the client.</summary>
    /// <param name="MaxTotalBufferSize">Buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
    /// <param name="MaxResourceBufferSize">Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
    /// <param name="MaxPostDataSize">Longest post body size (in bytes) that would be included in requestWillBeSent notification</param>
    public static ChromeProtocol.Domains.Network.EnableRequest Enable(int? MaxTotalBufferSize = default, int? MaxResourceBufferSize = default, int? MaxPostDataSize = default)    
    {
      return new ChromeProtocol.Domains.Network.EnableRequest(MaxTotalBufferSize, MaxResourceBufferSize, MaxPostDataSize);
    }
    /// <summary>Enables network tracking, network events will now be delivered to the client.</summary>
    /// <param name="MaxTotalBufferSize">Buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
    /// <param name="MaxResourceBufferSize">Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).</param>
    /// <param name="MaxPostDataSize">Longest post body size (in bytes) that would be included in requestWillBeSent notification</param>
    [ChromeProtocol.Core.MethodName("Network.enable")]
    public record EnableRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("maxTotalBufferSize")]
      int? MaxTotalBufferSize = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("maxResourceBufferSize")]
      int? MaxResourceBufferSize = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("maxPostDataSize")]
      int? MaxPostDataSize = default
    ) : ChromeProtocol.Core.ICommand<EnableRequestResult>
    {
    }
    public record EnableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns all browser cookies. Depending on the backend support, will return detailed cookie<br/>
    /// information in the `cookies` field.<br/>
    /// Deprecated. Use Storage.getCookies instead.<br/>
    /// </summary>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Network.GetAllCookiesRequest GetAllCookies()    
    {
      return new ChromeProtocol.Domains.Network.GetAllCookiesRequest();
    }
    /// <summary>
    /// Returns all browser cookies. Depending on the backend support, will return detailed cookie<br/>
    /// information in the `cookies` field.<br/>
    /// Deprecated. Use Storage.getCookies instead.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Network.getAllCookies")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetAllCookiesRequest() : ChromeProtocol.Core.ICommand<GetAllCookiesRequestResult>
    {
    }
    /// <param name="Cookies">Array of cookie objects.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetAllCookiesRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("cookies")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.CookieType> Cookies
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns the DER-encoded certificate.</summary>
    /// <param name="Origin">Origin to get certificate for.</param>
    public static ChromeProtocol.Domains.Network.GetCertificateRequest GetCertificate(string Origin)    
    {
      return new ChromeProtocol.Domains.Network.GetCertificateRequest(Origin);
    }
    /// <summary>Returns the DER-encoded certificate.</summary>
    /// <param name="Origin">Origin to get certificate for.</param>
    [ChromeProtocol.Core.MethodName("Network.getCertificate")]
    public record GetCertificateRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("origin")]
      string Origin
    ) : ChromeProtocol.Core.ICommand<GetCertificateRequestResult>
    {
    }
    public record GetCertificateRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("tableNames")]
      System.Collections.Generic.IReadOnlyList<string> TableNames
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns all browser cookies for the current URL. Depending on the backend support, will return<br/>
    /// detailed cookie information in the `cookies` field.<br/>
    /// </summary>
    /// <param name="Urls">
    /// The list of URLs for which applicable cookies will be fetched.<br/>
    /// If not specified, it&#39;s assumed to be set to the list containing<br/>
    /// the URLs of the page and all of its subframes.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Network.GetCookiesRequest GetCookies(System.Collections.Generic.IReadOnlyList<string>? Urls = default)    
    {
      return new ChromeProtocol.Domains.Network.GetCookiesRequest(Urls);
    }
    /// <summary>
    /// Returns all browser cookies for the current URL. Depending on the backend support, will return<br/>
    /// detailed cookie information in the `cookies` field.<br/>
    /// </summary>
    /// <param name="Urls">
    /// The list of URLs for which applicable cookies will be fetched.<br/>
    /// If not specified, it&#39;s assumed to be set to the list containing<br/>
    /// the URLs of the page and all of its subframes.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.getCookies")]
    public record GetCookiesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("urls")]
      System.Collections.Generic.IReadOnlyList<string>? Urls = default
    ) : ChromeProtocol.Core.ICommand<GetCookiesRequestResult>
    {
    }
    /// <param name="Cookies">Array of cookie objects.</param>
    public record GetCookiesRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("cookies")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.CookieType> Cookies
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns content served for the given request.</summary>
    /// <param name="RequestId">Identifier of the network request to get content for.</param>
    public static ChromeProtocol.Domains.Network.GetResponseBodyRequest GetResponseBody(ChromeProtocol.Domains.Network.RequestIdType RequestId)    
    {
      return new ChromeProtocol.Domains.Network.GetResponseBodyRequest(RequestId);
    }
    /// <summary>Returns content served for the given request.</summary>
    /// <param name="RequestId">Identifier of the network request to get content for.</param>
    [ChromeProtocol.Core.MethodName("Network.getResponseBody")]
    public record GetResponseBodyRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId
    ) : ChromeProtocol.Core.ICommand<GetResponseBodyRequestResult>
    {
    }
    /// <param name="Body">Response body.</param>
    /// <param name="Base64Encoded">True, if content was sent as base64.</param>
    public record GetResponseBodyRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("body")]
      string Body,
      [property: System.Text.Json.Serialization.JsonPropertyName("base64Encoded")]
      bool Base64Encoded
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns post data sent with the request. Returns an error when no data was sent with the request.</summary>
    /// <param name="RequestId">Identifier of the network request to get content for.</param>
    public static ChromeProtocol.Domains.Network.GetRequestPostDataRequest GetRequestPostData(ChromeProtocol.Domains.Network.RequestIdType RequestId)    
    {
      return new ChromeProtocol.Domains.Network.GetRequestPostDataRequest(RequestId);
    }
    /// <summary>Returns post data sent with the request. Returns an error when no data was sent with the request.</summary>
    /// <param name="RequestId">Identifier of the network request to get content for.</param>
    [ChromeProtocol.Core.MethodName("Network.getRequestPostData")]
    public record GetRequestPostDataRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId
    ) : ChromeProtocol.Core.ICommand<GetRequestPostDataRequestResult>
    {
    }
    /// <param name="PostData">Request body string, omitting files from multipart requests</param>
    public record GetRequestPostDataRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("postData")]
      string PostData
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns content served for the given currently intercepted request.</summary>
    /// <param name="InterceptionId">Identifier for the intercepted request to get body for.</param>
    public static ChromeProtocol.Domains.Network.GetResponseBodyForInterceptionRequest GetResponseBodyForInterception(ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId)    
    {
      return new ChromeProtocol.Domains.Network.GetResponseBodyForInterceptionRequest(InterceptionId);
    }
    /// <summary>Returns content served for the given currently intercepted request.</summary>
    /// <param name="InterceptionId">Identifier for the intercepted request to get body for.</param>
    [ChromeProtocol.Core.MethodName("Network.getResponseBodyForInterception")]
    public record GetResponseBodyForInterceptionRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("interceptionId")]
      ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId
    ) : ChromeProtocol.Core.ICommand<GetResponseBodyForInterceptionRequestResult>
    {
    }
    /// <param name="Body">Response body.</param>
    /// <param name="Base64Encoded">True, if content was sent as base64.</param>
    public record GetResponseBodyForInterceptionRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("body")]
      string Body,
      [property: System.Text.Json.Serialization.JsonPropertyName("base64Encoded")]
      bool Base64Encoded
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns a handle to the stream representing the response body. Note that after this command,<br/>
    /// the intercepted request can&#39;t be continued as is -- you either need to cancel it or to provide<br/>
    /// the response body. The stream only supports sequential read, IO.read will fail if the position<br/>
    /// is specified.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Network.TakeResponseBodyForInterceptionAsStreamRequest TakeResponseBodyForInterceptionAsStream(ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId)    
    {
      return new ChromeProtocol.Domains.Network.TakeResponseBodyForInterceptionAsStreamRequest(InterceptionId);
    }
    /// <summary>
    /// Returns a handle to the stream representing the response body. Note that after this command,<br/>
    /// the intercepted request can&#39;t be continued as is -- you either need to cancel it or to provide<br/>
    /// the response body. The stream only supports sequential read, IO.read will fail if the position<br/>
    /// is specified.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Network.takeResponseBodyForInterceptionAsStream")]
    public record TakeResponseBodyForInterceptionAsStreamRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("interceptionId")]
      ChromeProtocol.Domains.Network.InterceptionIdType InterceptionId
    ) : ChromeProtocol.Core.ICommand<TakeResponseBodyForInterceptionAsStreamRequestResult>
    {
    }
    public record TakeResponseBodyForInterceptionAsStreamRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("stream")]
      ChromeProtocol.Domains.IO.StreamHandleType Stream
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// This method sends a new XMLHttpRequest which is identical to the original one. The following<br/>
    /// parameters should be identical: method, url, async, request body, extra headers, withCredentials<br/>
    /// attribute, user, password.<br/>
    /// </summary>
    /// <param name="RequestId">Identifier of XHR to replay.</param>
    public static ChromeProtocol.Domains.Network.ReplayXHRRequest ReplayXHR(ChromeProtocol.Domains.Network.RequestIdType RequestId)    
    {
      return new ChromeProtocol.Domains.Network.ReplayXHRRequest(RequestId);
    }
    /// <summary>
    /// This method sends a new XMLHttpRequest which is identical to the original one. The following<br/>
    /// parameters should be identical: method, url, async, request body, extra headers, withCredentials<br/>
    /// attribute, user, password.<br/>
    /// </summary>
    /// <param name="RequestId">Identifier of XHR to replay.</param>
    [ChromeProtocol.Core.MethodName("Network.replayXHR")]
    public record ReplayXHRRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId
    ) : ChromeProtocol.Core.ICommand<ReplayXHRRequestResult>
    {
    }
    public record ReplayXHRRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Searches for given string in response content.</summary>
    /// <param name="RequestId">Identifier of the network response to search.</param>
    /// <param name="Query">String to search for.</param>
    /// <param name="CaseSensitive">If true, search is case sensitive.</param>
    /// <param name="IsRegex">If true, treats string parameter as regex.</param>
    public static ChromeProtocol.Domains.Network.SearchInResponseBodyRequest SearchInResponseBody(ChromeProtocol.Domains.Network.RequestIdType RequestId, string Query, bool? CaseSensitive = default, bool? IsRegex = default)    
    {
      return new ChromeProtocol.Domains.Network.SearchInResponseBodyRequest(RequestId, Query, CaseSensitive, IsRegex);
    }
    /// <summary>Searches for given string in response content.</summary>
    /// <param name="RequestId">Identifier of the network response to search.</param>
    /// <param name="Query">String to search for.</param>
    /// <param name="CaseSensitive">If true, search is case sensitive.</param>
    /// <param name="IsRegex">If true, treats string parameter as regex.</param>
    [ChromeProtocol.Core.MethodName("Network.searchInResponseBody")]
    public record SearchInResponseBodyRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("query")]
      string Query,
      [property: System.Text.Json.Serialization.JsonPropertyName("caseSensitive")]
      bool? CaseSensitive = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isRegex")]
      bool? IsRegex = default
    ) : ChromeProtocol.Core.ICommand<SearchInResponseBodyRequestResult>
    {
    }
    /// <param name="Result">List of search matches.</param>
    public record SearchInResponseBodyRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("result")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.SearchMatchType> Result
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Blocks URLs from loading.</summary>
    /// <param name="Urls">URL patterns to block. Wildcards (&#39;*&#39;) are allowed.</param>
    public static ChromeProtocol.Domains.Network.SetBlockedURLsRequest SetBlockedURLs(System.Collections.Generic.IReadOnlyList<string> Urls)    
    {
      return new ChromeProtocol.Domains.Network.SetBlockedURLsRequest(Urls);
    }
    /// <summary>Blocks URLs from loading.</summary>
    /// <param name="Urls">URL patterns to block. Wildcards (&#39;*&#39;) are allowed.</param>
    [ChromeProtocol.Core.MethodName("Network.setBlockedURLs")]
    public record SetBlockedURLsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("urls")]
      System.Collections.Generic.IReadOnlyList<string> Urls
    ) : ChromeProtocol.Core.ICommand<SetBlockedURLsRequestResult>
    {
    }
    public record SetBlockedURLsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Toggles ignoring of service worker for each request.</summary>
    /// <param name="Bypass">Bypass service worker and load from network.</param>
    public static ChromeProtocol.Domains.Network.SetBypassServiceWorkerRequest SetBypassServiceWorker(bool Bypass)    
    {
      return new ChromeProtocol.Domains.Network.SetBypassServiceWorkerRequest(Bypass);
    }
    /// <summary>Toggles ignoring of service worker for each request.</summary>
    /// <param name="Bypass">Bypass service worker and load from network.</param>
    [ChromeProtocol.Core.MethodName("Network.setBypassServiceWorker")]
    public record SetBypassServiceWorkerRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("bypass")]
      bool Bypass
    ) : ChromeProtocol.Core.ICommand<SetBypassServiceWorkerRequestResult>
    {
    }
    public record SetBypassServiceWorkerRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Toggles ignoring cache for each request. If `true`, cache will not be used.</summary>
    /// <param name="CacheDisabled">Cache disabled state.</param>
    public static ChromeProtocol.Domains.Network.SetCacheDisabledRequest SetCacheDisabled(bool CacheDisabled)    
    {
      return new ChromeProtocol.Domains.Network.SetCacheDisabledRequest(CacheDisabled);
    }
    /// <summary>Toggles ignoring cache for each request. If `true`, cache will not be used.</summary>
    /// <param name="CacheDisabled">Cache disabled state.</param>
    [ChromeProtocol.Core.MethodName("Network.setCacheDisabled")]
    public record SetCacheDisabledRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("cacheDisabled")]
      bool CacheDisabled
    ) : ChromeProtocol.Core.ICommand<SetCacheDisabledRequestResult>
    {
    }
    public record SetCacheDisabledRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.</summary>
    /// <param name="Name">Cookie name.</param>
    /// <param name="Value">Cookie value.</param>
    /// <param name="Url">
    /// The request-URI to associate with the setting of the cookie. This value can affect the<br/>
    /// default domain, path, source port, and source scheme values of the created cookie.<br/>
    /// </param>
    /// <param name="Domain">Cookie domain.</param>
    /// <param name="Path">Cookie path.</param>
    /// <param name="Secure">True if cookie is secure.</param>
    /// <param name="HttpOnly">True if cookie is http-only.</param>
    /// <param name="SameSite">Cookie SameSite type.</param>
    /// <param name="Expires">Cookie expiration date, session cookie if not set</param>
    /// <param name="Priority">Cookie Priority type.</param>
    /// <param name="SameParty">True if cookie is SameParty.</param>
    /// <param name="SourceScheme">Cookie source scheme type.</param>
    /// <param name="SourcePort">
    /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.<br/>
    /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.<br/>
    /// This is a temporary ability and it will be removed in the future.<br/>
    /// </param>
    /// <param name="PartitionKey">Cookie partition key. If not set, the cookie will be set as not partitioned.</param>
    public static ChromeProtocol.Domains.Network.SetCookieRequest SetCookie(string Name, string Value, string? Url = default, string? Domain = default, string? Path = default, bool? Secure = default, bool? HttpOnly = default, ChromeProtocol.Domains.Network.CookieSameSiteType? SameSite = default, ChromeProtocol.Domains.Network.TimeSinceEpochType? Expires = default, ChromeProtocol.Domains.Network.CookiePriorityType? Priority = default, bool? SameParty = default, ChromeProtocol.Domains.Network.CookieSourceSchemeType? SourceScheme = default, int? SourcePort = default, ChromeProtocol.Domains.Network.CookiePartitionKeyType? PartitionKey = default)    
    {
      return new ChromeProtocol.Domains.Network.SetCookieRequest(Name, Value, Url, Domain, Path, Secure, HttpOnly, SameSite, Expires, Priority, SameParty, SourceScheme, SourcePort, PartitionKey);
    }
    /// <summary>Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.</summary>
    /// <param name="Name">Cookie name.</param>
    /// <param name="Value">Cookie value.</param>
    /// <param name="Url">
    /// The request-URI to associate with the setting of the cookie. This value can affect the<br/>
    /// default domain, path, source port, and source scheme values of the created cookie.<br/>
    /// </param>
    /// <param name="Domain">Cookie domain.</param>
    /// <param name="Path">Cookie path.</param>
    /// <param name="Secure">True if cookie is secure.</param>
    /// <param name="HttpOnly">True if cookie is http-only.</param>
    /// <param name="SameSite">Cookie SameSite type.</param>
    /// <param name="Expires">Cookie expiration date, session cookie if not set</param>
    /// <param name="Priority">Cookie Priority type.</param>
    /// <param name="SameParty">True if cookie is SameParty.</param>
    /// <param name="SourceScheme">Cookie source scheme type.</param>
    /// <param name="SourcePort">
    /// Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.<br/>
    /// An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.<br/>
    /// This is a temporary ability and it will be removed in the future.<br/>
    /// </param>
    /// <param name="PartitionKey">Cookie partition key. If not set, the cookie will be set as not partitioned.</param>
    [ChromeProtocol.Core.MethodName("Network.setCookie")]
    public record SetCookieRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("domain")]
      string? Domain = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("path")]
      string? Path = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("secure")]
      bool? Secure = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("httpOnly")]
      bool? HttpOnly = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sameSite")]
      ChromeProtocol.Domains.Network.CookieSameSiteType? SameSite = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("expires")]
      ChromeProtocol.Domains.Network.TimeSinceEpochType? Expires = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("priority")]
      ChromeProtocol.Domains.Network.CookiePriorityType? Priority = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sameParty")]
      bool? SameParty = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourceScheme")]
      ChromeProtocol.Domains.Network.CookieSourceSchemeType? SourceScheme = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourcePort")]
      int? SourcePort = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("partitionKey")]
      ChromeProtocol.Domains.Network.CookiePartitionKeyType? PartitionKey = default
    ) : ChromeProtocol.Core.ICommand<SetCookieRequestResult>
    {
    }
    /// <param name="Success">Always set to true. If an error occurs, the response indicates protocol error.</param>
    public record SetCookieRequestResult(
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("success")]
      bool Success
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets given cookies.</summary>
    /// <param name="Cookies">Cookies to be set.</param>
    public static ChromeProtocol.Domains.Network.SetCookiesRequest SetCookies(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.CookieParamType> Cookies)    
    {
      return new ChromeProtocol.Domains.Network.SetCookiesRequest(Cookies);
    }
    /// <summary>Sets given cookies.</summary>
    /// <param name="Cookies">Cookies to be set.</param>
    [ChromeProtocol.Core.MethodName("Network.setCookies")]
    public record SetCookiesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("cookies")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.CookieParamType> Cookies
    ) : ChromeProtocol.Core.ICommand<SetCookiesRequestResult>
    {
    }
    public record SetCookiesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Specifies whether to always send extra HTTP headers with the requests from this page.</summary>
    /// <param name="Headers">Map with extra HTTP headers.</param>
    public static ChromeProtocol.Domains.Network.SetExtraHTTPHeadersRequest SetExtraHTTPHeaders(ChromeProtocol.Domains.Network.HeadersType Headers)    
    {
      return new ChromeProtocol.Domains.Network.SetExtraHTTPHeadersRequest(Headers);
    }
    /// <summary>Specifies whether to always send extra HTTP headers with the requests from this page.</summary>
    /// <param name="Headers">Map with extra HTTP headers.</param>
    [ChromeProtocol.Core.MethodName("Network.setExtraHTTPHeaders")]
    public record SetExtraHTTPHeadersRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("headers")]
      ChromeProtocol.Domains.Network.HeadersType Headers
    ) : ChromeProtocol.Core.ICommand<SetExtraHTTPHeadersRequestResult>
    {
    }
    public record SetExtraHTTPHeadersRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Specifies whether to attach a page script stack id in requests</summary>
    /// <param name="Enabled">Whether to attach a page script stack for debugging purpose.</param>
    public static ChromeProtocol.Domains.Network.SetAttachDebugStackRequest SetAttachDebugStack(bool Enabled)    
    {
      return new ChromeProtocol.Domains.Network.SetAttachDebugStackRequest(Enabled);
    }
    /// <summary>Specifies whether to attach a page script stack id in requests</summary>
    /// <param name="Enabled">Whether to attach a page script stack for debugging purpose.</param>
    [ChromeProtocol.Core.MethodName("Network.setAttachDebugStack")]
    public record SetAttachDebugStackRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("enabled")]
      bool Enabled
    ) : ChromeProtocol.Core.ICommand<SetAttachDebugStackRequestResult>
    {
    }
    public record SetAttachDebugStackRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Sets the requests to intercept that match the provided patterns and optionally resource types.<br/>
    /// Deprecated, please use Fetch.enable instead.<br/>
    /// </summary>
    /// <param name="Patterns">
    /// Requests matching any of these patterns will be forwarded and wait for the corresponding<br/>
    /// continueInterceptedRequest call.<br/>
    /// </param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Network.SetRequestInterceptionRequest SetRequestInterception(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.RequestPatternType> Patterns)    
    {
      return new ChromeProtocol.Domains.Network.SetRequestInterceptionRequest(Patterns);
    }
    /// <summary>
    /// Sets the requests to intercept that match the provided patterns and optionally resource types.<br/>
    /// Deprecated, please use Fetch.enable instead.<br/>
    /// </summary>
    /// <param name="Patterns">
    /// Requests matching any of these patterns will be forwarded and wait for the corresponding<br/>
    /// continueInterceptedRequest call.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.setRequestInterception")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetRequestInterceptionRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("patterns")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Network.RequestPatternType> Patterns
    ) : ChromeProtocol.Core.ICommand<SetRequestInterceptionRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SetRequestInterceptionRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Allows overriding user agent with the given string.</summary>
    /// <param name="UserAgent">User agent to use.</param>
    /// <param name="AcceptLanguage">Browser language to emulate.</param>
    /// <param name="Platform">The platform navigator.platform should return.</param>
    /// <param name="UserAgentMetadata">To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData</param>
    public static ChromeProtocol.Domains.Network.SetUserAgentOverrideRequest SetUserAgentOverride(string UserAgent, string? AcceptLanguage = default, string? Platform = default, ChromeProtocol.Domains.Emulation.UserAgentMetadataType? UserAgentMetadata = default)    
    {
      return new ChromeProtocol.Domains.Network.SetUserAgentOverrideRequest(UserAgent, AcceptLanguage, Platform, UserAgentMetadata);
    }
    /// <summary>Allows overriding user agent with the given string.</summary>
    /// <param name="UserAgent">User agent to use.</param>
    /// <param name="AcceptLanguage">Browser language to emulate.</param>
    /// <param name="Platform">The platform navigator.platform should return.</param>
    /// <param name="UserAgentMetadata">To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData</param>
    [ChromeProtocol.Core.MethodName("Network.setUserAgentOverride")]
    public record SetUserAgentOverrideRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("userAgent")]
      string UserAgent,
      [property: System.Text.Json.Serialization.JsonPropertyName("acceptLanguage")]
      string? AcceptLanguage = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("platform")]
      string? Platform = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("userAgentMetadata")]
      ChromeProtocol.Domains.Emulation.UserAgentMetadataType? UserAgentMetadata = default
    ) : ChromeProtocol.Core.ICommand<SetUserAgentOverrideRequestResult>
    {
    }
    public record SetUserAgentOverrideRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enables streaming of the response for the given requestId.<br/>
    /// If enabled, the dataReceived event contains the data that was received during streaming.<br/>
    /// </summary>
    /// <param name="RequestId">Identifier of the request to stream.</param>
    public static ChromeProtocol.Domains.Network.StreamResourceContentRequest StreamResourceContent(ChromeProtocol.Domains.Network.RequestIdType RequestId)    
    {
      return new ChromeProtocol.Domains.Network.StreamResourceContentRequest(RequestId);
    }
    /// <summary>
    /// Enables streaming of the response for the given requestId.<br/>
    /// If enabled, the dataReceived event contains the data that was received during streaming.<br/>
    /// </summary>
    /// <param name="RequestId">Identifier of the request to stream.</param>
    [ChromeProtocol.Core.MethodName("Network.streamResourceContent")]
    public record StreamResourceContentRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("requestId")]
      ChromeProtocol.Domains.Network.RequestIdType RequestId
    ) : ChromeProtocol.Core.ICommand<StreamResourceContentRequestResult>
    {
    }
    /// <param name="BufferedData">Data that has been buffered until streaming is enabled. (Encoded as a base64 string when passed over JSON)</param>
    public record StreamResourceContentRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("bufferedData")]
      string BufferedData
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns information about the COEP/COOP isolation status.</summary>
    /// <param name="FrameId">If no frameId is provided, the status of the target is provided.</param>
    public static ChromeProtocol.Domains.Network.GetSecurityIsolationStatusRequest GetSecurityIsolationStatus(ChromeProtocol.Domains.Page.FrameIdType? FrameId = default)    
    {
      return new ChromeProtocol.Domains.Network.GetSecurityIsolationStatusRequest(FrameId);
    }
    /// <summary>Returns information about the COEP/COOP isolation status.</summary>
    /// <param name="FrameId">If no frameId is provided, the status of the target is provided.</param>
    [ChromeProtocol.Core.MethodName("Network.getSecurityIsolationStatus")]
    public record GetSecurityIsolationStatusRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType? FrameId = default
    ) : ChromeProtocol.Core.ICommand<GetSecurityIsolationStatusRequestResult>
    {
    }
    public record GetSecurityIsolationStatusRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      ChromeProtocol.Domains.Network.SecurityIsolationStatusType Status
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.<br/>
    /// Enabling triggers &#39;reportingApiReportAdded&#39; for all existing reports.<br/>
    /// </summary>
    /// <param name="Enable">Whether to enable or disable events for the Reporting API</param>
    public static ChromeProtocol.Domains.Network.EnableReportingApiRequest EnableReportingApi(bool Enable)    
    {
      return new ChromeProtocol.Domains.Network.EnableReportingApiRequest(Enable);
    }
    /// <summary>
    /// Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.<br/>
    /// Enabling triggers &#39;reportingApiReportAdded&#39; for all existing reports.<br/>
    /// </summary>
    /// <param name="Enable">Whether to enable or disable events for the Reporting API</param>
    [ChromeProtocol.Core.MethodName("Network.enableReportingApi")]
    public record EnableReportingApiRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("enable")]
      bool Enable
    ) : ChromeProtocol.Core.ICommand<EnableReportingApiRequestResult>
    {
    }
    public record EnableReportingApiRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Fetches the resource and returns the content.</summary>
    /// <param name="Url">URL of the resource to get content for.</param>
    /// <param name="Options">Options for the request.</param>
    /// <param name="FrameId">
    /// Frame id to get the resource for. Mandatory for frame targets, and<br/>
    /// should be omitted for worker targets.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Network.LoadNetworkResourceRequest LoadNetworkResource(string Url, ChromeProtocol.Domains.Network.LoadNetworkResourceOptionsType Options, ChromeProtocol.Domains.Page.FrameIdType? FrameId = default)    
    {
      return new ChromeProtocol.Domains.Network.LoadNetworkResourceRequest(Url, Options, FrameId);
    }
    /// <summary>Fetches the resource and returns the content.</summary>
    /// <param name="Url">URL of the resource to get content for.</param>
    /// <param name="Options">Options for the request.</param>
    /// <param name="FrameId">
    /// Frame id to get the resource for. Mandatory for frame targets, and<br/>
    /// should be omitted for worker targets.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Network.loadNetworkResource")]
    public record LoadNetworkResourceRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("options")]
      ChromeProtocol.Domains.Network.LoadNetworkResourceOptionsType Options,
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType? FrameId = default
    ) : ChromeProtocol.Core.ICommand<LoadNetworkResourceRequestResult>
    {
    }
    public record LoadNetworkResourceRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("resource")]
      ChromeProtocol.Domains.Network.LoadNetworkResourcePageResultType Resource
    ) : ChromeProtocol.Core.IType
    {
    }
  }
}
