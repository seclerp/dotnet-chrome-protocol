// <auto-generated />
#nullable enable

namespace ChromeProtocol.Domains
{
  /// <summary>This domain allows interacting with the browser to control PWAs.</summary>
  public static partial class PWA
  {
    /// <summary>
    /// The following types are the replica of<br/>
    /// https://crsrc.org/c/chrome/browser/web_applications/proto/web_app_os_integration_state.proto;drc=9910d3be894c8f142c977ba1023f30a656bc13fc;l=67<br/>
    /// </summary>
    /// <param name="MediaType">
    /// New name of the mimetype according to<br/>
    /// https://www.iana.org/assignments/media-types/media-types.xhtml<br/>
    /// </param>
    public record FileHandlerAcceptType(
      [property: System.Text.Json.Serialization.JsonPropertyName("mediaType")]
      string MediaType,
      [property: System.Text.Json.Serialization.JsonPropertyName("fileExtensions")]
      System.Collections.Generic.IReadOnlyList<string> FileExtensions
    ) : ChromeProtocol.Core.IType
    {
    }
    public record FileHandlerType(
      [property: System.Text.Json.Serialization.JsonPropertyName("action")]
      string Action,
      [property: System.Text.Json.Serialization.JsonPropertyName("accepts")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.PWA.FileHandlerAcceptType> Accepts,
      [property: System.Text.Json.Serialization.JsonPropertyName("displayName")]
      string DisplayName
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>If user prefers opening the app in browser or an app window.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record DisplayModeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Returns the following OS state for the given manifest id.</summary>
    /// <param name="ManifestId">
    /// The id from the webapp&#39;s manifest file, commonly it&#39;s the url of the<br/>
    /// site installing the webapp. See<br/>
    /// https://web.dev/learn/pwa/web-app-manifest.<br/>
    /// </param>
    public static ChromeProtocol.Domains.PWA.GetOsAppStateRequest GetOsAppState(string ManifestId)    
    {
      return new ChromeProtocol.Domains.PWA.GetOsAppStateRequest(ManifestId);
    }
    /// <summary>Returns the following OS state for the given manifest id.</summary>
    /// <param name="ManifestId">
    /// The id from the webapp&#39;s manifest file, commonly it&#39;s the url of the<br/>
    /// site installing the webapp. See<br/>
    /// https://web.dev/learn/pwa/web-app-manifest.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("PWA.getOsAppState")]
    public record GetOsAppStateRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId
    ) : ChromeProtocol.Core.ICommand<GetOsAppStateRequestResult>
    {
    }
    public record GetOsAppStateRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("badgeCount")]
      int BadgeCount,
      [property: System.Text.Json.Serialization.JsonPropertyName("fileHandlers")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.PWA.FileHandlerType> FileHandlers
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Installs the given manifest identity, optionally using the given install_url<br/>
    /// or IWA bundle location.<br/>
    /// TODO(crbug.com/337872319) Support IWA to meet the following specific<br/>
    /// requirement.<br/>
    /// IWA-specific install description: If the manifest_id is isolated-app://,<br/>
    /// install_url_or_bundle_url is required, and can be either an http(s) URL or<br/>
    /// file:// URL pointing to a signed web bundle (.swbn). The .swbn file&#39;s<br/>
    /// signing key must correspond to manifest_id. If Chrome is not in IWA dev<br/>
    /// mode, the installation will fail, regardless of the state of the allowlist.<br/>
    /// </summary>
    /// <param name="InstallUrlOrBundleUrl">
    /// The location of the app or bundle overriding the one derived from the<br/>
    /// manifestId.<br/>
    /// </param>
    public static ChromeProtocol.Domains.PWA.InstallRequest Install(string ManifestId, string? InstallUrlOrBundleUrl = default)    
    {
      return new ChromeProtocol.Domains.PWA.InstallRequest(ManifestId, InstallUrlOrBundleUrl);
    }
    /// <summary>
    /// Installs the given manifest identity, optionally using the given install_url<br/>
    /// or IWA bundle location.<br/>
    /// TODO(crbug.com/337872319) Support IWA to meet the following specific<br/>
    /// requirement.<br/>
    /// IWA-specific install description: If the manifest_id is isolated-app://,<br/>
    /// install_url_or_bundle_url is required, and can be either an http(s) URL or<br/>
    /// file:// URL pointing to a signed web bundle (.swbn). The .swbn file&#39;s<br/>
    /// signing key must correspond to manifest_id. If Chrome is not in IWA dev<br/>
    /// mode, the installation will fail, regardless of the state of the allowlist.<br/>
    /// </summary>
    /// <param name="InstallUrlOrBundleUrl">
    /// The location of the app or bundle overriding the one derived from the<br/>
    /// manifestId.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("PWA.install")]
    public record InstallRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("installUrlOrBundleUrl")]
      string? InstallUrlOrBundleUrl = default
    ) : ChromeProtocol.Core.ICommand<InstallRequestResult>
    {
    }
    public record InstallRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Uninstalls the given manifest_id and closes any opened app windows.</summary>
    public static ChromeProtocol.Domains.PWA.UninstallRequest Uninstall(string ManifestId)    
    {
      return new ChromeProtocol.Domains.PWA.UninstallRequest(ManifestId);
    }
    /// <summary>Uninstalls the given manifest_id and closes any opened app windows.</summary>
    [ChromeProtocol.Core.MethodName("PWA.uninstall")]
    public record UninstallRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId
    ) : ChromeProtocol.Core.ICommand<UninstallRequestResult>
    {
    }
    public record UninstallRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Launches the installed web app, or an url in the same web app instead of the<br/>
    /// default start url if it is provided. Returns a page Target.TargetID which<br/>
    /// can be used to attach to via Target.attachToTarget or similar APIs.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.PWA.LaunchRequest Launch(string ManifestId, string? Url = default)    
    {
      return new ChromeProtocol.Domains.PWA.LaunchRequest(ManifestId, Url);
    }
    /// <summary>
    /// Launches the installed web app, or an url in the same web app instead of the<br/>
    /// default start url if it is provided. Returns a page Target.TargetID which<br/>
    /// can be used to attach to via Target.attachToTarget or similar APIs.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("PWA.launch")]
    public record LaunchRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default
    ) : ChromeProtocol.Core.ICommand<LaunchRequestResult>
    {
    }
    /// <param name="TargetId">ID of the tab target created as a result.</param>
    public record LaunchRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Opens one or more local files from an installed web app identified by its<br/>
    /// manifestId. The web app needs to have file handlers registered to process<br/>
    /// the files. The API returns one or more page Target.TargetIDs which can be<br/>
    /// used to attach to via Target.attachToTarget or similar APIs.<br/>
    /// If some files in the parameters cannot be handled by the web app, they will<br/>
    /// be ignored. If none of the files can be handled, this API returns an error.<br/>
    /// If no files are provided as the parameter, this API also returns an error.<br/>
    /// According to the definition of the file handlers in the manifest file, one<br/>
    /// Target.TargetID may represent a page handling one or more files. The order<br/>
    /// of the returned Target.TargetIDs is not guaranteed.<br/>
    /// TODO(crbug.com/339454034): Check the existences of the input files.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.PWA.LaunchFilesInAppRequest LaunchFilesInApp(string ManifestId, System.Collections.Generic.IReadOnlyList<string> Files)    
    {
      return new ChromeProtocol.Domains.PWA.LaunchFilesInAppRequest(ManifestId, Files);
    }
    /// <summary>
    /// Opens one or more local files from an installed web app identified by its<br/>
    /// manifestId. The web app needs to have file handlers registered to process<br/>
    /// the files. The API returns one or more page Target.TargetIDs which can be<br/>
    /// used to attach to via Target.attachToTarget or similar APIs.<br/>
    /// If some files in the parameters cannot be handled by the web app, they will<br/>
    /// be ignored. If none of the files can be handled, this API returns an error.<br/>
    /// If no files are provided as the parameter, this API also returns an error.<br/>
    /// According to the definition of the file handlers in the manifest file, one<br/>
    /// Target.TargetID may represent a page handling one or more files. The order<br/>
    /// of the returned Target.TargetIDs is not guaranteed.<br/>
    /// TODO(crbug.com/339454034): Check the existences of the input files.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("PWA.launchFilesInApp")]
    public record LaunchFilesInAppRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("files")]
      System.Collections.Generic.IReadOnlyList<string> Files
    ) : ChromeProtocol.Core.ICommand<LaunchFilesInAppRequestResult>
    {
    }
    /// <param name="TargetIds">IDs of the tab targets created as the result.</param>
    public record LaunchFilesInAppRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("targetIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Target.TargetIDType> TargetIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Opens the current page in its web app identified by the manifest id, needs<br/>
    /// to be called on a page target. This function returns immediately without<br/>
    /// waiting for the app to finish loading.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.PWA.OpenCurrentPageInAppRequest OpenCurrentPageInApp(string ManifestId)    
    {
      return new ChromeProtocol.Domains.PWA.OpenCurrentPageInAppRequest(ManifestId);
    }
    /// <summary>
    /// Opens the current page in its web app identified by the manifest id, needs<br/>
    /// to be called on a page target. This function returns immediately without<br/>
    /// waiting for the app to finish loading.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("PWA.openCurrentPageInApp")]
    public record OpenCurrentPageInAppRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId
    ) : ChromeProtocol.Core.ICommand<OpenCurrentPageInAppRequestResult>
    {
    }
    public record OpenCurrentPageInAppRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Changes user settings of the web app identified by its manifestId. If the<br/>
    /// app was not installed, this command returns an error. Unset parameters will<br/>
    /// be ignored; unrecognized values will cause an error.<br/>
    /// Unlike the ones defined in the manifest files of the web apps, these<br/>
    /// settings are provided by the browser and controlled by the users, they<br/>
    /// impact the way the browser handling the web apps.<br/>
    /// See the comment of each parameter.<br/>
    /// </summary>
    /// <param name="LinkCapturing">
    /// If user allows the links clicked on by the user in the app&#39;s scope, or<br/>
    /// extended scope if the manifest has scope extensions and the flags<br/>
    /// `DesktopPWAsLinkCapturingWithScopeExtensions` and<br/>
    /// `WebAppEnableScopeExtensions` are enabled.<br/>
    /// Note, the API does not support resetting the linkCapturing to the<br/>
    /// initial value, uninstalling and installing the web app again will reset<br/>
    /// it.<br/>
    /// TODO(crbug.com/339453269): Setting this value on ChromeOS is not<br/>
    /// supported yet.<br/>
    /// </param>
    public static ChromeProtocol.Domains.PWA.ChangeAppUserSettingsRequest ChangeAppUserSettings(string ManifestId, bool? LinkCapturing = default, ChromeProtocol.Domains.PWA.DisplayModeType? DisplayMode = default)    
    {
      return new ChromeProtocol.Domains.PWA.ChangeAppUserSettingsRequest(ManifestId, LinkCapturing, DisplayMode);
    }
    /// <summary>
    /// Changes user settings of the web app identified by its manifestId. If the<br/>
    /// app was not installed, this command returns an error. Unset parameters will<br/>
    /// be ignored; unrecognized values will cause an error.<br/>
    /// Unlike the ones defined in the manifest files of the web apps, these<br/>
    /// settings are provided by the browser and controlled by the users, they<br/>
    /// impact the way the browser handling the web apps.<br/>
    /// See the comment of each parameter.<br/>
    /// </summary>
    /// <param name="LinkCapturing">
    /// If user allows the links clicked on by the user in the app&#39;s scope, or<br/>
    /// extended scope if the manifest has scope extensions and the flags<br/>
    /// `DesktopPWAsLinkCapturingWithScopeExtensions` and<br/>
    /// `WebAppEnableScopeExtensions` are enabled.<br/>
    /// Note, the API does not support resetting the linkCapturing to the<br/>
    /// initial value, uninstalling and installing the web app again will reset<br/>
    /// it.<br/>
    /// TODO(crbug.com/339453269): Setting this value on ChromeOS is not<br/>
    /// supported yet.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("PWA.changeAppUserSettings")]
    public record ChangeAppUserSettingsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("manifestId")]
      string ManifestId,
      [property: System.Text.Json.Serialization.JsonPropertyName("linkCapturing")]
      bool? LinkCapturing = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("displayMode")]
      ChromeProtocol.Domains.PWA.DisplayModeType? DisplayMode = default
    ) : ChromeProtocol.Core.ICommand<ChangeAppUserSettingsRequestResult>
    {
    }
    public record ChangeAppUserSettingsRequestResult() : ChromeProtocol.Core.IType
    {
    }
  }
}
