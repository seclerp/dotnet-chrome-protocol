// <auto-generated />
#nullable enable

namespace ChromeProtocol.Domains
{
  /// <summary>
  /// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing<br/>
  /// breakpoints, stepping through execution, exploring stack traces, etc.<br/>
  /// </summary>
  public static partial class Debugger
  {
    /// <summary>Breakpoint identifier.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record BreakpointIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Call frame identifier.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CallFrameIdType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Location in the source code.</summary>
    /// <param name="ScriptId">Script identifier as reported in the `Debugger.scriptParsed`.</param>
    /// <param name="LineNumber">Line number in the script (0-based).</param>
    /// <param name="ColumnNumber">Column number in the script (0-based).</param>
    public record LocationType(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("lineNumber")]
      int LineNumber,
      [property: System.Text.Json.Serialization.JsonPropertyName("columnNumber")]
      int? ColumnNumber = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Location in the source code.</summary>
    public record ScriptPositionType(
      [property: System.Text.Json.Serialization.JsonPropertyName("lineNumber")]
      int LineNumber,
      [property: System.Text.Json.Serialization.JsonPropertyName("columnNumber")]
      int ColumnNumber
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Location range within one script.</summary>
    public record LocationRangeType(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("start")]
      ChromeProtocol.Domains.Debugger.ScriptPositionType Start,
      [property: System.Text.Json.Serialization.JsonPropertyName("end")]
      ChromeProtocol.Domains.Debugger.ScriptPositionType End
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>JavaScript call frame. Array of call frames form the call stack.</summary>
    /// <param name="CallFrameId">Call frame identifier. This identifier is only valid while the virtual machine is paused.</param>
    /// <param name="FunctionName">Name of the JavaScript function called on this call frame.</param>
    /// <param name="Location">Location in the source code.</param>
    /// <param name="Url">
    /// JavaScript script name or url.<br/>
    /// Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously<br/>
    /// sent `Debugger.scriptParsed` event.<br/>
    /// </param>
    /// <param name="ScopeChain">Scope chain for this call frame.</param>
    /// <param name="This">`this` object for this call frame.</param>
    /// <param name="FunctionLocation">Location in the source code.</param>
    /// <param name="ReturnValue">The value being returned, if the function is at return point.</param>
    /// <param name="CanBeRestarted">
    /// Valid only while the VM is paused and indicates whether this frame<br/>
    /// can be restarted or not. Note that a `true` value here does not<br/>
    /// guarantee that Debugger#restartFrame with this CallFrameId will be<br/>
    /// successful, but it is very likely.<br/>
    /// </param>
    public record CallFrameType(
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrameId")]
      ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId,
      [property: System.Text.Json.Serialization.JsonPropertyName("functionName")]
      string FunctionName,
      [property: System.Text.Json.Serialization.JsonPropertyName("location")]
      ChromeProtocol.Domains.Debugger.LocationType Location,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("scopeChain")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.ScopeType> ScopeChain,
      [property: System.Text.Json.Serialization.JsonPropertyName("this")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType This,
      [property: System.Text.Json.Serialization.JsonPropertyName("functionLocation")]
      ChromeProtocol.Domains.Debugger.LocationType? FunctionLocation = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("returnValue")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType? ReturnValue = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("canBeRestarted")]
      bool? CanBeRestarted = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Scope description.</summary>
    /// <param name="Type">Scope type.</param>
    /// <param name="Object">
    /// Object representing the scope. For `global` and `with` scopes it represents the actual<br/>
    /// object; for the rest of the scopes, it is artificial transient object enumerating scope<br/>
    /// variables as its properties.<br/>
    /// </param>
    /// <param name="StartLocation">Location in the source code where scope starts</param>
    /// <param name="EndLocation">Location in the source code where scope ends</param>
    public record ScopeType(
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      string Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("object")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Object,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string? Name = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("startLocation")]
      ChromeProtocol.Domains.Debugger.LocationType? StartLocation = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("endLocation")]
      ChromeProtocol.Domains.Debugger.LocationType? EndLocation = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Search match for resource.</summary>
    /// <param name="LineNumber">Line number in resource content.</param>
    /// <param name="LineContent">Line with match content.</param>
    public record SearchMatchType(
      [property: System.Text.Json.Serialization.JsonPropertyName("lineNumber")]
      double LineNumber,
      [property: System.Text.Json.Serialization.JsonPropertyName("lineContent")]
      string LineContent
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="ScriptId">Script identifier as reported in the `Debugger.scriptParsed`.</param>
    /// <param name="LineNumber">Line number in the script (0-based).</param>
    /// <param name="ColumnNumber">Column number in the script (0-based).</param>
    public record BreakLocationType(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("lineNumber")]
      int LineNumber,
      [property: System.Text.Json.Serialization.JsonPropertyName("columnNumber")]
      int? ColumnNumber = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      string? Type = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Lines">The next chunk of disassembled lines.</param>
    /// <param name="BytecodeOffsets">The bytecode offsets describing the start of each line.</param>
    public record WasmDisassemblyChunkType(
      [property: System.Text.Json.Serialization.JsonPropertyName("lines")]
      System.Collections.Generic.IReadOnlyList<string> Lines,
      [property: System.Text.Json.Serialization.JsonPropertyName("bytecodeOffsets")]
      System.Collections.Generic.IReadOnlyList<int> BytecodeOffsets
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enum of possible script languages.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ScriptLanguageType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Debug symbols available for a wasm script.</summary>
    /// <param name="Type">Type of the debug symbols.</param>
    /// <param name="ExternalURL">URL of the external symbol source.</param>
    public record DebugSymbolsType(
      [property: System.Text.Json.Serialization.JsonPropertyName("type")]
      string Type,
      [property: System.Text.Json.Serialization.JsonPropertyName("externalURL")]
      string? ExternalURL = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Fired when breakpoint is resolved to an actual script and location.</summary>
    /// <param name="BreakpointId">Breakpoint unique identifier.</param>
    /// <param name="Location">Actual breakpoint location.</param>
    [ChromeProtocol.Core.MethodName("Debugger.breakpointResolved")]
    public record BreakpointResolved(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakpointId")]
      ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId,
      [property: System.Text.Json.Serialization.JsonPropertyName("location")]
      ChromeProtocol.Domains.Debugger.LocationType Location
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.</summary>
    /// <param name="CallFrames">Call stack the virtual machine stopped on.</param>
    /// <param name="Reason">Pause reason.</param>
    /// <param name="Data">Object containing break-specific auxiliary properties.</param>
    /// <param name="HitBreakpoints">Hit breakpoints IDs</param>
    /// <param name="AsyncStackTrace">Async stack trace, if any.</param>
    /// <param name="AsyncStackTraceId">Async stack trace, if any.</param>
    /// <param name="AsyncCallStackTraceId">Never present, will be removed.</param>
    [ChromeProtocol.Core.MethodName("Debugger.paused")]
    public record Paused(
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrames")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.CallFrameType> CallFrames,
      [property: System.Text.Json.Serialization.JsonPropertyName("reason")]
      string Reason,
      [property: System.Text.Json.Serialization.JsonPropertyName("data")]
      System.Text.Json.Nodes.JsonObject? Data = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("hitBreakpoints")]
      System.Collections.Generic.IReadOnlyList<string>? HitBreakpoints = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncStackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? AsyncStackTrace = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncStackTraceId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType? AsyncStackTraceId = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncCallStackTraceId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType? AsyncCallStackTraceId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when the virtual machine resumed execution.</summary>
    [ChromeProtocol.Core.MethodName("Debugger.resumed")]
    public record Resumed() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when virtual machine fails to parse the script.</summary>
    /// <param name="ScriptId">Identifier of the script parsed.</param>
    /// <param name="Url">URL or name of the script parsed (if any).</param>
    /// <param name="StartLine">Line offset of the script within the resource with given URL (for script tags).</param>
    /// <param name="StartColumn">Column offset of the script within the resource with given URL.</param>
    /// <param name="EndLine">Last line of the script.</param>
    /// <param name="EndColumn">Length of the last line of the script.</param>
    /// <param name="ExecutionContextId">Specifies script creation context.</param>
    /// <param name="Hash">Content hash of the script, SHA-256.</param>
    /// <param name="ExecutionContextAuxData">Embedder-specific auxiliary data likely matching {isDefault: boolean, type: &#39;default&#39;|&#39;isolated&#39;|&#39;worker&#39;, frameId: string}</param>
    /// <param name="SourceMapURL">URL of source map associated with script (if any).</param>
    /// <param name="HasSourceURL">True, if this script has sourceURL.</param>
    /// <param name="IsModule">True, if this script is ES6 module.</param>
    /// <param name="Length">This script length.</param>
    /// <param name="StackTrace">JavaScript top stack frame of where the script parsed event was triggered if available.</param>
    /// <param name="CodeOffset">If the scriptLanguage is WebAssembly, the code section offset in the module.</param>
    /// <param name="ScriptLanguage">The language of the script.</param>
    /// <param name="EmbedderName">The name the embedder supplied for this script.</param>
    [ChromeProtocol.Core.MethodName("Debugger.scriptFailedToParse")]
    public record ScriptFailedToParse(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("startLine")]
      int StartLine,
      [property: System.Text.Json.Serialization.JsonPropertyName("startColumn")]
      int StartColumn,
      [property: System.Text.Json.Serialization.JsonPropertyName("endLine")]
      int EndLine,
      [property: System.Text.Json.Serialization.JsonPropertyName("endColumn")]
      int EndColumn,
      [property: System.Text.Json.Serialization.JsonPropertyName("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType ExecutionContextId,
      [property: System.Text.Json.Serialization.JsonPropertyName("hash")]
      string Hash,
      [property: System.Text.Json.Serialization.JsonPropertyName("executionContextAuxData")]
      System.Text.Json.Nodes.JsonObject? ExecutionContextAuxData = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourceMapURL")]
      string? SourceMapURL = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("hasSourceURL")]
      bool? HasSourceURL = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isModule")]
      bool? IsModule = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("length")]
      int? Length = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("stackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? StackTrace = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("codeOffset")]
      int? CodeOffset = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptLanguage")]
      ChromeProtocol.Domains.Debugger.ScriptLanguageType? ScriptLanguage = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("embedderName")]
      string? EmbedderName = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when virtual machine parses script. This event is also fired for all known and uncollected<br/>
    /// scripts upon enabling debugger.<br/>
    /// </summary>
    /// <param name="ScriptId">Identifier of the script parsed.</param>
    /// <param name="Url">URL or name of the script parsed (if any).</param>
    /// <param name="StartLine">Line offset of the script within the resource with given URL (for script tags).</param>
    /// <param name="StartColumn">Column offset of the script within the resource with given URL.</param>
    /// <param name="EndLine">Last line of the script.</param>
    /// <param name="EndColumn">Length of the last line of the script.</param>
    /// <param name="ExecutionContextId">Specifies script creation context.</param>
    /// <param name="Hash">Content hash of the script, SHA-256.</param>
    /// <param name="ExecutionContextAuxData">Embedder-specific auxiliary data likely matching {isDefault: boolean, type: &#39;default&#39;|&#39;isolated&#39;|&#39;worker&#39;, frameId: string}</param>
    /// <param name="IsLiveEdit">True, if this script is generated as a result of the live edit operation.</param>
    /// <param name="SourceMapURL">URL of source map associated with script (if any).</param>
    /// <param name="HasSourceURL">True, if this script has sourceURL.</param>
    /// <param name="IsModule">True, if this script is ES6 module.</param>
    /// <param name="Length">This script length.</param>
    /// <param name="StackTrace">JavaScript top stack frame of where the script parsed event was triggered if available.</param>
    /// <param name="CodeOffset">If the scriptLanguage is WebAssembly, the code section offset in the module.</param>
    /// <param name="ScriptLanguage">The language of the script.</param>
    /// <param name="DebugSymbols">If the scriptLanguage is WebASsembly, the source of debug symbols for the module.</param>
    /// <param name="EmbedderName">The name the embedder supplied for this script.</param>
    [ChromeProtocol.Core.MethodName("Debugger.scriptParsed")]
    public record ScriptParsed(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string Url,
      [property: System.Text.Json.Serialization.JsonPropertyName("startLine")]
      int StartLine,
      [property: System.Text.Json.Serialization.JsonPropertyName("startColumn")]
      int StartColumn,
      [property: System.Text.Json.Serialization.JsonPropertyName("endLine")]
      int EndLine,
      [property: System.Text.Json.Serialization.JsonPropertyName("endColumn")]
      int EndColumn,
      [property: System.Text.Json.Serialization.JsonPropertyName("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType ExecutionContextId,
      [property: System.Text.Json.Serialization.JsonPropertyName("hash")]
      string Hash,
      [property: System.Text.Json.Serialization.JsonPropertyName("executionContextAuxData")]
      System.Text.Json.Nodes.JsonObject? ExecutionContextAuxData = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isLiveEdit")]
      bool? IsLiveEdit = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("sourceMapURL")]
      string? SourceMapURL = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("hasSourceURL")]
      bool? HasSourceURL = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isModule")]
      bool? IsModule = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("length")]
      int? Length = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("stackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? StackTrace = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("codeOffset")]
      int? CodeOffset = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptLanguage")]
      ChromeProtocol.Domains.Debugger.ScriptLanguageType? ScriptLanguage = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("debugSymbols")]
      ChromeProtocol.Domains.Debugger.DebugSymbolsType? DebugSymbols = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("embedderName")]
      string? EmbedderName = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Continues execution until specific location is reached.</summary>
    /// <param name="Location">Location to continue to.</param>
    public static ChromeProtocol.Domains.Debugger.ContinueToLocationRequest ContinueToLocation(ChromeProtocol.Domains.Debugger.LocationType Location, string? TargetCallFrames = default)
    {
      return new ChromeProtocol.Domains.Debugger.ContinueToLocationRequest(Location, TargetCallFrames);
    }
    /// <summary>Continues execution until specific location is reached.</summary>
    /// <param name="Location">Location to continue to.</param>
    [ChromeProtocol.Core.MethodName("Debugger.continueToLocation")]
    public record ContinueToLocationRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("location")]
      ChromeProtocol.Domains.Debugger.LocationType Location,
      [property: System.Text.Json.Serialization.JsonPropertyName("targetCallFrames")]
      string? TargetCallFrames = default
    ) : ChromeProtocol.Core.ICommand<ContinueToLocationRequestResult>
    {
    }
    public record ContinueToLocationRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Disables debugger for given page.</summary>
    public static ChromeProtocol.Domains.Debugger.DisableRequest Disable()
    {
      return new ChromeProtocol.Domains.Debugger.DisableRequest();
    }
    /// <summary>Disables debugger for given page.</summary>
    [ChromeProtocol.Core.MethodName("Debugger.disable")]
    public record DisableRequest() : ChromeProtocol.Core.ICommand<DisableRequestResult>
    {
    }
    public record DisableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enables debugger for the given page. Clients should not assume that the debugging has been<br/>
    /// enabled until the result for this command is received.<br/>
    /// </summary>
    /// <param name="MaxScriptsCacheSize">
    /// The maximum size in bytes of collected scripts (not referenced by other heap objects)<br/>
    /// the debugger can hold. Puts no limit if parameter is omitted.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.EnableRequest Enable(double? MaxScriptsCacheSize = default)
    {
      return new ChromeProtocol.Domains.Debugger.EnableRequest(MaxScriptsCacheSize);
    }
    /// <summary>
    /// Enables debugger for the given page. Clients should not assume that the debugging has been<br/>
    /// enabled until the result for this command is received.<br/>
    /// </summary>
    /// <param name="MaxScriptsCacheSize">
    /// The maximum size in bytes of collected scripts (not referenced by other heap objects)<br/>
    /// the debugger can hold. Puts no limit if parameter is omitted.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.enable")]
    public record EnableRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("maxScriptsCacheSize")]
      double? MaxScriptsCacheSize = default
    ) : ChromeProtocol.Core.ICommand<EnableRequestResult>
    {
    }
    /// <param name="DebuggerId">Unique identifier of the debugger.</param>
    public record EnableRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("debuggerId")]
      ChromeProtocol.Domains.Runtime.UniqueDebuggerIdType DebuggerId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Evaluates expression on a given call frame.</summary>
    /// <param name="CallFrameId">Call frame identifier to evaluate on.</param>
    /// <param name="Expression">Expression to evaluate.</param>
    /// <param name="ObjectGroup">
    /// String object group name to put result into (allows rapid releasing resulting object handles<br/>
    /// using `releaseObjectGroup`).<br/>
    /// </param>
    /// <param name="IncludeCommandLineAPI">
    /// Specifies whether command line API should be available to the evaluated expression, defaults<br/>
    /// to false.<br/>
    /// </param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="ThrowOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
    /// <param name="Timeout">Terminate execution after timing out (number of milliseconds).</param>
    public static ChromeProtocol.Domains.Debugger.EvaluateOnCallFrameRequest EvaluateOnCallFrame(ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId, string Expression, string? ObjectGroup = default, bool? IncludeCommandLineAPI = default, bool? Silent = default, bool? ReturnByValue = default, bool? GeneratePreview = default, bool? ThrowOnSideEffect = default, ChromeProtocol.Domains.Runtime.TimeDeltaType? Timeout = default)
    {
      return new ChromeProtocol.Domains.Debugger.EvaluateOnCallFrameRequest(CallFrameId, Expression, ObjectGroup, IncludeCommandLineAPI, Silent, ReturnByValue, GeneratePreview, ThrowOnSideEffect, Timeout);
    }
    /// <summary>Evaluates expression on a given call frame.</summary>
    /// <param name="CallFrameId">Call frame identifier to evaluate on.</param>
    /// <param name="Expression">Expression to evaluate.</param>
    /// <param name="ObjectGroup">
    /// String object group name to put result into (allows rapid releasing resulting object handles<br/>
    /// using `releaseObjectGroup`).<br/>
    /// </param>
    /// <param name="IncludeCommandLineAPI">
    /// Specifies whether command line API should be available to the evaluated expression, defaults<br/>
    /// to false.<br/>
    /// </param>
    /// <param name="Silent">
    /// In silent mode exceptions thrown during evaluation are not reported and do not pause<br/>
    /// execution. Overrides `setPauseOnException` state.<br/>
    /// </param>
    /// <param name="ReturnByValue">Whether the result is expected to be a JSON object that should be sent by value.</param>
    /// <param name="GeneratePreview">Whether preview should be generated for the result.</param>
    /// <param name="ThrowOnSideEffect">Whether to throw an exception if side effect cannot be ruled out during evaluation.</param>
    /// <param name="Timeout">Terminate execution after timing out (number of milliseconds).</param>
    [ChromeProtocol.Core.MethodName("Debugger.evaluateOnCallFrame")]
    public record EvaluateOnCallFrameRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrameId")]
      ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId,
      [property: System.Text.Json.Serialization.JsonPropertyName("expression")]
      string Expression,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectGroup")]
      string? ObjectGroup = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("includeCommandLineAPI")]
      bool? IncludeCommandLineAPI = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("silent")]
      bool? Silent = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("returnByValue")]
      bool? ReturnByValue = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("generatePreview")]
      bool? GeneratePreview = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("throwOnSideEffect")]
      bool? ThrowOnSideEffect = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("timeout")]
      ChromeProtocol.Domains.Runtime.TimeDeltaType? Timeout = default
    ) : ChromeProtocol.Core.ICommand<EvaluateOnCallFrameRequestResult>
    {
    }
    /// <param name="Result">Object wrapper for the evaluation result.</param>
    /// <param name="ExceptionDetails">Exception details.</param>
    public record EvaluateOnCallFrameRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("result")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Result,
      [property: System.Text.Json.Serialization.JsonPropertyName("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns possible locations for breakpoint. scriptId in start and end range locations should be<br/>
    /// the same.<br/>
    /// </summary>
    /// <param name="Start">Start of range to search possible breakpoint locations in.</param>
    /// <param name="End">
    /// End of range to search possible breakpoint locations in (excluding). When not specified, end<br/>
    /// of scripts is used as end of range.<br/>
    /// </param>
    /// <param name="RestrictToFunction">Only consider locations which are in the same (non-nested) function as start.</param>
    public static ChromeProtocol.Domains.Debugger.GetPossibleBreakpointsRequest GetPossibleBreakpoints(ChromeProtocol.Domains.Debugger.LocationType Start, ChromeProtocol.Domains.Debugger.LocationType? End = default, bool? RestrictToFunction = default)
    {
      return new ChromeProtocol.Domains.Debugger.GetPossibleBreakpointsRequest(Start, End, RestrictToFunction);
    }
    /// <summary>
    /// Returns possible locations for breakpoint. scriptId in start and end range locations should be<br/>
    /// the same.<br/>
    /// </summary>
    /// <param name="Start">Start of range to search possible breakpoint locations in.</param>
    /// <param name="End">
    /// End of range to search possible breakpoint locations in (excluding). When not specified, end<br/>
    /// of scripts is used as end of range.<br/>
    /// </param>
    /// <param name="RestrictToFunction">Only consider locations which are in the same (non-nested) function as start.</param>
    [ChromeProtocol.Core.MethodName("Debugger.getPossibleBreakpoints")]
    public record GetPossibleBreakpointsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("start")]
      ChromeProtocol.Domains.Debugger.LocationType Start,
      [property: System.Text.Json.Serialization.JsonPropertyName("end")]
      ChromeProtocol.Domains.Debugger.LocationType? End = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("restrictToFunction")]
      bool? RestrictToFunction = default
    ) : ChromeProtocol.Core.ICommand<GetPossibleBreakpointsRequestResult>
    {
    }
    /// <param name="Locations">List of the possible breakpoint locations.</param>
    public record GetPossibleBreakpointsRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("locations")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.BreakLocationType> Locations
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns source for the script with given id.</summary>
    /// <param name="ScriptId">Id of the script to get source for.</param>
    public static ChromeProtocol.Domains.Debugger.GetScriptSourceRequest GetScriptSource(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId)
    {
      return new ChromeProtocol.Domains.Debugger.GetScriptSourceRequest(ScriptId);
    }
    /// <summary>Returns source for the script with given id.</summary>
    /// <param name="ScriptId">Id of the script to get source for.</param>
    [ChromeProtocol.Core.MethodName("Debugger.getScriptSource")]
    public record GetScriptSourceRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId
    ) : ChromeProtocol.Core.ICommand<GetScriptSourceRequestResult>
    {
    }
    /// <param name="ScriptSource">Script source (empty in case of Wasm bytecode).</param>
    /// <param name="Bytecode">Wasm bytecode. (Encoded as a base64 string when passed over JSON)</param>
    public record GetScriptSourceRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptSource")]
      string ScriptSource,
      [property: System.Text.Json.Serialization.JsonPropertyName("bytecode")]
      string? Bytecode = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="ScriptId">Id of the script to disassemble</param>
    public static ChromeProtocol.Domains.Debugger.DisassembleWasmModuleRequest DisassembleWasmModule(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId)
    {
      return new ChromeProtocol.Domains.Debugger.DisassembleWasmModuleRequest(ScriptId);
    }
    /// <param name="ScriptId">Id of the script to disassemble</param>
    [ChromeProtocol.Core.MethodName("Debugger.disassembleWasmModule")]
    public record DisassembleWasmModuleRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId
    ) : ChromeProtocol.Core.ICommand<DisassembleWasmModuleRequestResult>
    {
    }
    /// <param name="TotalNumberOfLines">The total number of lines in the disassembly text.</param>
    /// <param name="FunctionBodyOffsets">
    /// The offsets of all function bodies, in the format [start1, end1,<br/>
    /// start2, end2, ...] where all ends are exclusive.<br/>
    /// </param>
    /// <param name="Chunk">The first chunk of disassembly.</param>
    /// <param name="StreamId">
    /// For large modules, return a stream from which additional chunks of<br/>
    /// disassembly can be read successively.<br/>
    /// </param>
    public record DisassembleWasmModuleRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("totalNumberOfLines")]
      int TotalNumberOfLines,
      [property: System.Text.Json.Serialization.JsonPropertyName("functionBodyOffsets")]
      System.Collections.Generic.IReadOnlyList<int> FunctionBodyOffsets,
      [property: System.Text.Json.Serialization.JsonPropertyName("chunk")]
      ChromeProtocol.Domains.Debugger.WasmDisassemblyChunkType Chunk,
      [property: System.Text.Json.Serialization.JsonPropertyName("streamId")]
      string? StreamId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Disassemble the next chunk of lines for the module corresponding to the<br/>
    /// stream. If disassembly is complete, this API will invalidate the streamId<br/>
    /// and return an empty chunk. Any subsequent calls for the now invalid stream<br/>
    /// will return errors.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Debugger.NextWasmDisassemblyChunkRequest NextWasmDisassemblyChunk(string StreamId)
    {
      return new ChromeProtocol.Domains.Debugger.NextWasmDisassemblyChunkRequest(StreamId);
    }
    /// <summary>
    /// Disassemble the next chunk of lines for the module corresponding to the<br/>
    /// stream. If disassembly is complete, this API will invalidate the streamId<br/>
    /// and return an empty chunk. Any subsequent calls for the now invalid stream<br/>
    /// will return errors.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Debugger.nextWasmDisassemblyChunk")]
    public record NextWasmDisassemblyChunkRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("streamId")]
      string StreamId
    ) : ChromeProtocol.Core.ICommand<NextWasmDisassemblyChunkRequestResult>
    {
    }
    /// <param name="Chunk">The next chunk of disassembly.</param>
    public record NextWasmDisassemblyChunkRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("chunk")]
      ChromeProtocol.Domains.Debugger.WasmDisassemblyChunkType Chunk
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>This command is deprecated. Use getScriptSource instead.</summary>
    /// <param name="ScriptId">Id of the Wasm script to get source for.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Debugger.GetWasmBytecodeRequest GetWasmBytecode(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId)
    {
      return new ChromeProtocol.Domains.Debugger.GetWasmBytecodeRequest(ScriptId);
    }
    /// <summary>This command is deprecated. Use getScriptSource instead.</summary>
    /// <param name="ScriptId">Id of the Wasm script to get source for.</param>
    [ChromeProtocol.Core.MethodName("Debugger.getWasmBytecode")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetWasmBytecodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId
    ) : ChromeProtocol.Core.ICommand<GetWasmBytecodeRequestResult>
    {
    }
    /// <param name="Bytecode">Script source. (Encoded as a base64 string when passed over JSON)</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetWasmBytecodeRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("bytecode")]
      string Bytecode
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns stack trace with given `stackTraceId`.</summary>
    public static ChromeProtocol.Domains.Debugger.GetStackTraceRequest GetStackTrace(ChromeProtocol.Domains.Runtime.StackTraceIdType StackTraceId)
    {
      return new ChromeProtocol.Domains.Debugger.GetStackTraceRequest(StackTraceId);
    }
    /// <summary>Returns stack trace with given `stackTraceId`.</summary>
    [ChromeProtocol.Core.MethodName("Debugger.getStackTrace")]
    public record GetStackTraceRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("stackTraceId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType StackTraceId
    ) : ChromeProtocol.Core.ICommand<GetStackTraceRequestResult>
    {
    }
    public record GetStackTraceRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("stackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType StackTrace
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Stops on the next JavaScript statement.</summary>
    public static ChromeProtocol.Domains.Debugger.PauseRequest Pause()
    {
      return new ChromeProtocol.Domains.Debugger.PauseRequest();
    }
    /// <summary>Stops on the next JavaScript statement.</summary>
    [ChromeProtocol.Core.MethodName("Debugger.pause")]
    public record PauseRequest() : ChromeProtocol.Core.ICommand<PauseRequestResult>
    {
    }
    public record PauseRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <param name="ParentStackTraceId">Debugger will pause when async call with given stack trace is started.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Debugger.PauseOnAsyncCallRequest PauseOnAsyncCall(ChromeProtocol.Domains.Runtime.StackTraceIdType ParentStackTraceId)
    {
      return new ChromeProtocol.Domains.Debugger.PauseOnAsyncCallRequest(ParentStackTraceId);
    }
    /// <param name="ParentStackTraceId">Debugger will pause when async call with given stack trace is started.</param>
    [ChromeProtocol.Core.MethodName("Debugger.pauseOnAsyncCall")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record PauseOnAsyncCallRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("parentStackTraceId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType ParentStackTraceId
    ) : ChromeProtocol.Core.ICommand<PauseOnAsyncCallRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record PauseOnAsyncCallRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Removes JavaScript breakpoint.</summary>
    public static ChromeProtocol.Domains.Debugger.RemoveBreakpointRequest RemoveBreakpoint(ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId)
    {
      return new ChromeProtocol.Domains.Debugger.RemoveBreakpointRequest(BreakpointId);
    }
    /// <summary>Removes JavaScript breakpoint.</summary>
    [ChromeProtocol.Core.MethodName("Debugger.removeBreakpoint")]
    public record RemoveBreakpointRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakpointId")]
      ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId
    ) : ChromeProtocol.Core.ICommand<RemoveBreakpointRequestResult>
    {
    }
    public record RemoveBreakpointRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Restarts particular call frame from the beginning. The old, deprecated<br/>
    /// behavior of `restartFrame` is to stay paused and allow further CDP commands<br/>
    /// after a restart was scheduled. This can cause problems with restarting, so<br/>
    /// we now continue execution immediatly after it has been scheduled until we<br/>
    /// reach the beginning of the restarted frame.<br/>
    /// To stay back-wards compatible, `restartFrame` now expects a `mode`<br/>
    /// parameter to be present. If the `mode` parameter is missing, `restartFrame`<br/>
    /// errors out.<br/>
    /// The various return values are deprecated and `callFrames` is always empty.<br/>
    /// Use the call frames from the `Debugger#paused` events instead, that fires<br/>
    /// once V8 pauses at the beginning of the restarted function.<br/>
    /// </summary>
    /// <param name="CallFrameId">Call frame identifier to evaluate on.</param>
    /// <param name="Mode">
    /// The `mode` parameter must be present and set to &#39;StepInto&#39;, otherwise<br/>
    /// `restartFrame` will error out.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.RestartFrameRequest RestartFrame(ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId, string? Mode = default)
    {
      return new ChromeProtocol.Domains.Debugger.RestartFrameRequest(CallFrameId, Mode);
    }
    /// <summary>
    /// Restarts particular call frame from the beginning. The old, deprecated<br/>
    /// behavior of `restartFrame` is to stay paused and allow further CDP commands<br/>
    /// after a restart was scheduled. This can cause problems with restarting, so<br/>
    /// we now continue execution immediatly after it has been scheduled until we<br/>
    /// reach the beginning of the restarted frame.<br/>
    /// To stay back-wards compatible, `restartFrame` now expects a `mode`<br/>
    /// parameter to be present. If the `mode` parameter is missing, `restartFrame`<br/>
    /// errors out.<br/>
    /// The various return values are deprecated and `callFrames` is always empty.<br/>
    /// Use the call frames from the `Debugger#paused` events instead, that fires<br/>
    /// once V8 pauses at the beginning of the restarted function.<br/>
    /// </summary>
    /// <param name="CallFrameId">Call frame identifier to evaluate on.</param>
    /// <param name="Mode">
    /// The `mode` parameter must be present and set to &#39;StepInto&#39;, otherwise<br/>
    /// `restartFrame` will error out.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.restartFrame")]
    public record RestartFrameRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrameId")]
      ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId,
      [property: System.Text.Json.Serialization.JsonPropertyName("mode")]
      string? Mode = default
    ) : ChromeProtocol.Core.ICommand<RestartFrameRequestResult>
    {
    }
    /// <param name="CallFrames">New stack trace.</param>
    /// <param name="AsyncStackTrace">Async stack trace, if any.</param>
    /// <param name="AsyncStackTraceId">Async stack trace, if any.</param>
    public record RestartFrameRequestResult(
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrames")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.CallFrameType> CallFrames,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncStackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? AsyncStackTrace = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncStackTraceId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType? AsyncStackTraceId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Resumes JavaScript execution.</summary>
    /// <param name="TerminateOnResume">
    /// Set to true to terminate execution upon resuming execution. In contrast<br/>
    /// to Runtime.terminateExecution, this will allows to execute further<br/>
    /// JavaScript (i.e. via evaluation) until execution of the paused code<br/>
    /// is actually resumed, at which point termination is triggered.<br/>
    /// If execution is currently not paused, this parameter has no effect.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.ResumeRequest Resume(bool? TerminateOnResume = default)
    {
      return new ChromeProtocol.Domains.Debugger.ResumeRequest(TerminateOnResume);
    }
    /// <summary>Resumes JavaScript execution.</summary>
    /// <param name="TerminateOnResume">
    /// Set to true to terminate execution upon resuming execution. In contrast<br/>
    /// to Runtime.terminateExecution, this will allows to execute further<br/>
    /// JavaScript (i.e. via evaluation) until execution of the paused code<br/>
    /// is actually resumed, at which point termination is triggered.<br/>
    /// If execution is currently not paused, this parameter has no effect.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.resume")]
    public record ResumeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("terminateOnResume")]
      bool? TerminateOnResume = default
    ) : ChromeProtocol.Core.ICommand<ResumeRequestResult>
    {
    }
    public record ResumeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Searches for given string in script content.</summary>
    /// <param name="ScriptId">Id of the script to search in.</param>
    /// <param name="Query">String to search for.</param>
    /// <param name="CaseSensitive">If true, search is case sensitive.</param>
    /// <param name="IsRegex">If true, treats string parameter as regex.</param>
    public static ChromeProtocol.Domains.Debugger.SearchInContentRequest SearchInContent(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId, string Query, bool? CaseSensitive = default, bool? IsRegex = default)
    {
      return new ChromeProtocol.Domains.Debugger.SearchInContentRequest(ScriptId, Query, CaseSensitive, IsRegex);
    }
    /// <summary>Searches for given string in script content.</summary>
    /// <param name="ScriptId">Id of the script to search in.</param>
    /// <param name="Query">String to search for.</param>
    /// <param name="CaseSensitive">If true, search is case sensitive.</param>
    /// <param name="IsRegex">If true, treats string parameter as regex.</param>
    [ChromeProtocol.Core.MethodName("Debugger.searchInContent")]
    public record SearchInContentRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("query")]
      string Query,
      [property: System.Text.Json.Serialization.JsonPropertyName("caseSensitive")]
      bool? CaseSensitive = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isRegex")]
      bool? IsRegex = default
    ) : ChromeProtocol.Core.ICommand<SearchInContentRequestResult>
    {
    }
    /// <param name="Result">List of search matches.</param>
    public record SearchInContentRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("result")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.SearchMatchType> Result
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enables or disables async call stacks tracking.</summary>
    /// <param name="MaxDepth">
    /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async<br/>
    /// call stacks (default).<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.SetAsyncCallStackDepthRequest SetAsyncCallStackDepth(int MaxDepth)
    {
      return new ChromeProtocol.Domains.Debugger.SetAsyncCallStackDepthRequest(MaxDepth);
    }
    /// <summary>Enables or disables async call stacks tracking.</summary>
    /// <param name="MaxDepth">
    /// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async<br/>
    /// call stacks (default).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.setAsyncCallStackDepth")]
    public record SetAsyncCallStackDepthRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("maxDepth")]
      int MaxDepth
    ) : ChromeProtocol.Core.ICommand<SetAsyncCallStackDepthRequestResult>
    {
    }
    public record SetAsyncCallStackDepthRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in<br/>
    /// scripts with url matching one of the patterns. VM will try to leave blackboxed script by<br/>
    /// performing &#39;step in&#39; several times, finally resorting to &#39;step out&#39; if unsuccessful.<br/>
    /// </summary>
    /// <param name="Patterns">Array of regexps that will be used to check script url for blackbox state.</param>
    public static ChromeProtocol.Domains.Debugger.SetBlackboxPatternsRequest SetBlackboxPatterns(System.Collections.Generic.IReadOnlyList<string> Patterns)
    {
      return new ChromeProtocol.Domains.Debugger.SetBlackboxPatternsRequest(Patterns);
    }
    /// <summary>
    /// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in<br/>
    /// scripts with url matching one of the patterns. VM will try to leave blackboxed script by<br/>
    /// performing &#39;step in&#39; several times, finally resorting to &#39;step out&#39; if unsuccessful.<br/>
    /// </summary>
    /// <param name="Patterns">Array of regexps that will be used to check script url for blackbox state.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setBlackboxPatterns")]
    public record SetBlackboxPatternsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("patterns")]
      System.Collections.Generic.IReadOnlyList<string> Patterns
    ) : ChromeProtocol.Core.ICommand<SetBlackboxPatternsRequestResult>
    {
    }
    public record SetBlackboxPatternsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted<br/>
    /// scripts by performing &#39;step in&#39; several times, finally resorting to &#39;step out&#39; if unsuccessful.<br/>
    /// Positions array contains positions where blackbox state is changed. First interval isn&#39;t<br/>
    /// blackboxed. Array should be sorted.<br/>
    /// </summary>
    /// <param name="ScriptId">Id of the script.</param>
    public static ChromeProtocol.Domains.Debugger.SetBlackboxedRangesRequest SetBlackboxedRanges(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId, System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.ScriptPositionType> Positions)
    {
      return new ChromeProtocol.Domains.Debugger.SetBlackboxedRangesRequest(ScriptId, Positions);
    }
    /// <summary>
    /// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted<br/>
    /// scripts by performing &#39;step in&#39; several times, finally resorting to &#39;step out&#39; if unsuccessful.<br/>
    /// Positions array contains positions where blackbox state is changed. First interval isn&#39;t<br/>
    /// blackboxed. Array should be sorted.<br/>
    /// </summary>
    /// <param name="ScriptId">Id of the script.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setBlackboxedRanges")]
    public record SetBlackboxedRangesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("positions")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.ScriptPositionType> Positions
    ) : ChromeProtocol.Core.ICommand<SetBlackboxedRangesRequestResult>
    {
    }
    public record SetBlackboxedRangesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets JavaScript breakpoint at a given location.</summary>
    /// <param name="Location">Location to set breakpoint in.</param>
    /// <param name="Condition">
    /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the<br/>
    /// breakpoint if this expression evaluates to true.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.SetBreakpointRequest SetBreakpoint(ChromeProtocol.Domains.Debugger.LocationType Location, string? Condition = default)
    {
      return new ChromeProtocol.Domains.Debugger.SetBreakpointRequest(Location, Condition);
    }
    /// <summary>Sets JavaScript breakpoint at a given location.</summary>
    /// <param name="Location">Location to set breakpoint in.</param>
    /// <param name="Condition">
    /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the<br/>
    /// breakpoint if this expression evaluates to true.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.setBreakpoint")]
    public record SetBreakpointRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("location")]
      ChromeProtocol.Domains.Debugger.LocationType Location,
      [property: System.Text.Json.Serialization.JsonPropertyName("condition")]
      string? Condition = default
    ) : ChromeProtocol.Core.ICommand<SetBreakpointRequestResult>
    {
    }
    /// <param name="BreakpointId">Id of the created breakpoint for further reference.</param>
    /// <param name="ActualLocation">Location this breakpoint resolved into.</param>
    public record SetBreakpointRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakpointId")]
      ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId,
      [property: System.Text.Json.Serialization.JsonPropertyName("actualLocation")]
      ChromeProtocol.Domains.Debugger.LocationType ActualLocation
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets instrumentation breakpoint.</summary>
    /// <param name="Instrumentation">Instrumentation name.</param>
    public static ChromeProtocol.Domains.Debugger.SetInstrumentationBreakpointRequest SetInstrumentationBreakpoint(string Instrumentation)
    {
      return new ChromeProtocol.Domains.Debugger.SetInstrumentationBreakpointRequest(Instrumentation);
    }
    /// <summary>Sets instrumentation breakpoint.</summary>
    /// <param name="Instrumentation">Instrumentation name.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setInstrumentationBreakpoint")]
    public record SetInstrumentationBreakpointRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("instrumentation")]
      string Instrumentation
    ) : ChromeProtocol.Core.ICommand<SetInstrumentationBreakpointRequestResult>
    {
    }
    /// <param name="BreakpointId">Id of the created breakpoint for further reference.</param>
    public record SetInstrumentationBreakpointRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakpointId")]
      ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this<br/>
    /// command is issued, all existing parsed scripts will have breakpoints resolved and returned in<br/>
    /// `locations` property. Further matching script parsing will result in subsequent<br/>
    /// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.<br/>
    /// </summary>
    /// <param name="LineNumber">Line number to set breakpoint at.</param>
    /// <param name="Url">URL of the resources to set breakpoint on.</param>
    /// <param name="UrlRegex">
    /// Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or<br/>
    /// `urlRegex` must be specified.<br/>
    /// </param>
    /// <param name="ScriptHash">Script hash of the resources to set breakpoint on.</param>
    /// <param name="ColumnNumber">Offset in the line to set breakpoint at.</param>
    /// <param name="Condition">
    /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the<br/>
    /// breakpoint if this expression evaluates to true.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.SetBreakpointByUrlRequest SetBreakpointByUrl(int LineNumber, string? Url = default, string? UrlRegex = default, string? ScriptHash = default, int? ColumnNumber = default, string? Condition = default)
    {
      return new ChromeProtocol.Domains.Debugger.SetBreakpointByUrlRequest(LineNumber, Url, UrlRegex, ScriptHash, ColumnNumber, Condition);
    }
    /// <summary>
    /// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this<br/>
    /// command is issued, all existing parsed scripts will have breakpoints resolved and returned in<br/>
    /// `locations` property. Further matching script parsing will result in subsequent<br/>
    /// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.<br/>
    /// </summary>
    /// <param name="LineNumber">Line number to set breakpoint at.</param>
    /// <param name="Url">URL of the resources to set breakpoint on.</param>
    /// <param name="UrlRegex">
    /// Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or<br/>
    /// `urlRegex` must be specified.<br/>
    /// </param>
    /// <param name="ScriptHash">Script hash of the resources to set breakpoint on.</param>
    /// <param name="ColumnNumber">Offset in the line to set breakpoint at.</param>
    /// <param name="Condition">
    /// Expression to use as a breakpoint condition. When specified, debugger will only stop on the<br/>
    /// breakpoint if this expression evaluates to true.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.setBreakpointByUrl")]
    public record SetBreakpointByUrlRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("lineNumber")]
      int LineNumber,
      [property: System.Text.Json.Serialization.JsonPropertyName("url")]
      string? Url = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("urlRegex")]
      string? UrlRegex = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptHash")]
      string? ScriptHash = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("columnNumber")]
      int? ColumnNumber = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("condition")]
      string? Condition = default
    ) : ChromeProtocol.Core.ICommand<SetBreakpointByUrlRequestResult>
    {
    }
    /// <param name="BreakpointId">Id of the created breakpoint for further reference.</param>
    /// <param name="Locations">List of the locations this breakpoint resolved into upon addition.</param>
    public record SetBreakpointByUrlRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakpointId")]
      ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId,
      [property: System.Text.Json.Serialization.JsonPropertyName("locations")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.LocationType> Locations
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Sets JavaScript breakpoint before each call to the given function.<br/>
    /// If another function was created from the same source as a given one,<br/>
    /// calling it will also trigger the breakpoint.<br/>
    /// </summary>
    /// <param name="ObjectId">Function object id.</param>
    /// <param name="Condition">
    /// Expression to use as a breakpoint condition. When specified, debugger will<br/>
    /// stop on the breakpoint if this expression evaluates to true.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.SetBreakpointOnFunctionCallRequest SetBreakpointOnFunctionCall(ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId, string? Condition = default)
    {
      return new ChromeProtocol.Domains.Debugger.SetBreakpointOnFunctionCallRequest(ObjectId, Condition);
    }
    /// <summary>
    /// Sets JavaScript breakpoint before each call to the given function.<br/>
    /// If another function was created from the same source as a given one,<br/>
    /// calling it will also trigger the breakpoint.<br/>
    /// </summary>
    /// <param name="ObjectId">Function object id.</param>
    /// <param name="Condition">
    /// Expression to use as a breakpoint condition. When specified, debugger will<br/>
    /// stop on the breakpoint if this expression evaluates to true.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.setBreakpointOnFunctionCall")]
    public record SetBreakpointOnFunctionCallRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId,
      [property: System.Text.Json.Serialization.JsonPropertyName("condition")]
      string? Condition = default
    ) : ChromeProtocol.Core.ICommand<SetBreakpointOnFunctionCallRequestResult>
    {
    }
    /// <param name="BreakpointId">Id of the created breakpoint for further reference.</param>
    public record SetBreakpointOnFunctionCallRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakpointId")]
      ChromeProtocol.Domains.Debugger.BreakpointIdType BreakpointId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Activates / deactivates all breakpoints on the page.</summary>
    /// <param name="Active">New value for breakpoints active state.</param>
    public static ChromeProtocol.Domains.Debugger.SetBreakpointsActiveRequest SetBreakpointsActive(bool Active)
    {
      return new ChromeProtocol.Domains.Debugger.SetBreakpointsActiveRequest(Active);
    }
    /// <summary>Activates / deactivates all breakpoints on the page.</summary>
    /// <param name="Active">New value for breakpoints active state.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setBreakpointsActive")]
    public record SetBreakpointsActiveRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("active")]
      bool Active
    ) : ChromeProtocol.Core.ICommand<SetBreakpointsActiveRequestResult>
    {
    }
    public record SetBreakpointsActiveRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,<br/>
    /// or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.<br/>
    /// </summary>
    /// <param name="State">Pause on exceptions mode.</param>
    public static ChromeProtocol.Domains.Debugger.SetPauseOnExceptionsRequest SetPauseOnExceptions(string State)
    {
      return new ChromeProtocol.Domains.Debugger.SetPauseOnExceptionsRequest(State);
    }
    /// <summary>
    /// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,<br/>
    /// or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.<br/>
    /// </summary>
    /// <param name="State">Pause on exceptions mode.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setPauseOnExceptions")]
    public record SetPauseOnExceptionsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("state")]
      string State
    ) : ChromeProtocol.Core.ICommand<SetPauseOnExceptionsRequestResult>
    {
    }
    public record SetPauseOnExceptionsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Changes return value in top frame. Available only at return break position.</summary>
    /// <param name="NewValue">New return value.</param>
    public static ChromeProtocol.Domains.Debugger.SetReturnValueRequest SetReturnValue(ChromeProtocol.Domains.Runtime.CallArgumentType NewValue)
    {
      return new ChromeProtocol.Domains.Debugger.SetReturnValueRequest(NewValue);
    }
    /// <summary>Changes return value in top frame. Available only at return break position.</summary>
    /// <param name="NewValue">New return value.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setReturnValue")]
    public record SetReturnValueRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("newValue")]
      ChromeProtocol.Domains.Runtime.CallArgumentType NewValue
    ) : ChromeProtocol.Core.ICommand<SetReturnValueRequestResult>
    {
    }
    public record SetReturnValueRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Edits JavaScript source live.<br/>
    /// In general, functions that are currently on the stack can not be edited with<br/>
    /// a single exception: If the edited function is the top-most stack frame and<br/>
    /// that is the only activation of that function on the stack. In this case<br/>
    /// the live edit will be successful and a `Debugger.restartFrame` for the<br/>
    /// top-most function is automatically triggered.<br/>
    /// </summary>
    /// <param name="ScriptId">Id of the script to edit.</param>
    /// <param name="ScriptSource">New content of the script.</param>
    /// <param name="DryRun">
    /// If true the change will not actually be applied. Dry run may be used to get result<br/>
    /// description without actually modifying the code.<br/>
    /// </param>
    /// <param name="AllowTopFrameEditing">
    /// If true, then `scriptSource` is allowed to change the function on top of the stack<br/>
    /// as long as the top-most stack frame is the only activation of that function.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Debugger.SetScriptSourceRequest SetScriptSource(ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId, string ScriptSource, bool? DryRun = default, bool? AllowTopFrameEditing = default)
    {
      return new ChromeProtocol.Domains.Debugger.SetScriptSourceRequest(ScriptId, ScriptSource, DryRun, AllowTopFrameEditing);
    }
    /// <summary>
    /// Edits JavaScript source live.<br/>
    /// In general, functions that are currently on the stack can not be edited with<br/>
    /// a single exception: If the edited function is the top-most stack frame and<br/>
    /// that is the only activation of that function on the stack. In this case<br/>
    /// the live edit will be successful and a `Debugger.restartFrame` for the<br/>
    /// top-most function is automatically triggered.<br/>
    /// </summary>
    /// <param name="ScriptId">Id of the script to edit.</param>
    /// <param name="ScriptSource">New content of the script.</param>
    /// <param name="DryRun">
    /// If true the change will not actually be applied. Dry run may be used to get result<br/>
    /// description without actually modifying the code.<br/>
    /// </param>
    /// <param name="AllowTopFrameEditing">
    /// If true, then `scriptSource` is allowed to change the function on top of the stack<br/>
    /// as long as the top-most stack frame is the only activation of that function.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Debugger.setScriptSource")]
    public record SetScriptSourceRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptId")]
      ChromeProtocol.Domains.Runtime.ScriptIdType ScriptId,
      [property: System.Text.Json.Serialization.JsonPropertyName("scriptSource")]
      string ScriptSource,
      [property: System.Text.Json.Serialization.JsonPropertyName("dryRun")]
      bool? DryRun = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("allowTopFrameEditing")]
      bool? AllowTopFrameEditing = default
    ) : ChromeProtocol.Core.ICommand<SetScriptSourceRequestResult>
    {
    }
    /// <param name="Status">
    /// Whether the operation was successful or not. Only `Ok` denotes a<br/>
    /// successful live edit while the other enum variants denote why<br/>
    /// the live edit failed.<br/>
    /// </param>
    /// <param name="CallFrames">New stack trace in case editing has happened while VM was stopped.</param>
    /// <param name="StackChanged">Whether current call stack  was modified after applying the changes.</param>
    /// <param name="AsyncStackTrace">Async stack trace, if any.</param>
    /// <param name="AsyncStackTraceId">Async stack trace, if any.</param>
    /// <param name="ExceptionDetails">Exception details if any. Only present when `status` is `CompileError`.</param>
    public record SetScriptSourceRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("status")]
      string Status,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrames")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.CallFrameType>? CallFrames = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("stackChanged")]
      bool? StackChanged = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncStackTrace")]
      ChromeProtocol.Domains.Runtime.StackTraceType? AsyncStackTrace = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("asyncStackTraceId")]
      ChromeProtocol.Domains.Runtime.StackTraceIdType? AsyncStackTraceId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("exceptionDetails")]
      ChromeProtocol.Domains.Runtime.ExceptionDetailsType? ExceptionDetails = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).</summary>
    /// <param name="Skip">New value for skip pauses state.</param>
    public static ChromeProtocol.Domains.Debugger.SetSkipAllPausesRequest SetSkipAllPauses(bool Skip)
    {
      return new ChromeProtocol.Domains.Debugger.SetSkipAllPausesRequest(Skip);
    }
    /// <summary>Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).</summary>
    /// <param name="Skip">New value for skip pauses state.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setSkipAllPauses")]
    public record SetSkipAllPausesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("skip")]
      bool Skip
    ) : ChromeProtocol.Core.ICommand<SetSkipAllPausesRequestResult>
    {
    }
    public record SetSkipAllPausesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Changes value of variable in a callframe. Object-based scopes are not supported and must be<br/>
    /// mutated manually.<br/>
    /// </summary>
    /// <param name="ScopeNumber">
    /// 0-based number of scope as was listed in scope chain. Only &#39;local&#39;, &#39;closure&#39; and &#39;catch&#39;<br/>
    /// scope types are allowed. Other scopes could be manipulated manually.<br/>
    /// </param>
    /// <param name="VariableName">Variable name.</param>
    /// <param name="NewValue">New variable value.</param>
    /// <param name="CallFrameId">Id of callframe that holds variable.</param>
    public static ChromeProtocol.Domains.Debugger.SetVariableValueRequest SetVariableValue(int ScopeNumber, string VariableName, ChromeProtocol.Domains.Runtime.CallArgumentType NewValue, ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId)
    {
      return new ChromeProtocol.Domains.Debugger.SetVariableValueRequest(ScopeNumber, VariableName, NewValue, CallFrameId);
    }
    /// <summary>
    /// Changes value of variable in a callframe. Object-based scopes are not supported and must be<br/>
    /// mutated manually.<br/>
    /// </summary>
    /// <param name="ScopeNumber">
    /// 0-based number of scope as was listed in scope chain. Only &#39;local&#39;, &#39;closure&#39; and &#39;catch&#39;<br/>
    /// scope types are allowed. Other scopes could be manipulated manually.<br/>
    /// </param>
    /// <param name="VariableName">Variable name.</param>
    /// <param name="NewValue">New variable value.</param>
    /// <param name="CallFrameId">Id of callframe that holds variable.</param>
    [ChromeProtocol.Core.MethodName("Debugger.setVariableValue")]
    public record SetVariableValueRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("scopeNumber")]
      int ScopeNumber,
      [property: System.Text.Json.Serialization.JsonPropertyName("variableName")]
      string VariableName,
      [property: System.Text.Json.Serialization.JsonPropertyName("newValue")]
      ChromeProtocol.Domains.Runtime.CallArgumentType NewValue,
      [property: System.Text.Json.Serialization.JsonPropertyName("callFrameId")]
      ChromeProtocol.Domains.Debugger.CallFrameIdType CallFrameId
    ) : ChromeProtocol.Core.ICommand<SetVariableValueRequestResult>
    {
    }
    public record SetVariableValueRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Steps into the function call.</summary>
    /// <param name="BreakOnAsyncCall">
    /// Debugger will pause on the execution of the first async task which was scheduled<br/>
    /// before next pause.<br/>
    /// </param>
    /// <param name="SkipList">The skipList specifies location ranges that should be skipped on step into.</param>
    public static ChromeProtocol.Domains.Debugger.StepIntoRequest StepInto(bool? BreakOnAsyncCall = default, System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.LocationRangeType>? SkipList = default)
    {
      return new ChromeProtocol.Domains.Debugger.StepIntoRequest(BreakOnAsyncCall, SkipList);
    }
    /// <summary>Steps into the function call.</summary>
    /// <param name="BreakOnAsyncCall">
    /// Debugger will pause on the execution of the first async task which was scheduled<br/>
    /// before next pause.<br/>
    /// </param>
    /// <param name="SkipList">The skipList specifies location ranges that should be skipped on step into.</param>
    [ChromeProtocol.Core.MethodName("Debugger.stepInto")]
    public record StepIntoRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("breakOnAsyncCall")]
      bool? BreakOnAsyncCall = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("skipList")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.LocationRangeType>? SkipList = default
    ) : ChromeProtocol.Core.ICommand<StepIntoRequestResult>
    {
    }
    public record StepIntoRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Steps out of the function call.</summary>
    public static ChromeProtocol.Domains.Debugger.StepOutRequest StepOut()
    {
      return new ChromeProtocol.Domains.Debugger.StepOutRequest();
    }
    /// <summary>Steps out of the function call.</summary>
    [ChromeProtocol.Core.MethodName("Debugger.stepOut")]
    public record StepOutRequest() : ChromeProtocol.Core.ICommand<StepOutRequestResult>
    {
    }
    public record StepOutRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Steps over the statement.</summary>
    /// <param name="SkipList">The skipList specifies location ranges that should be skipped on step over.</param>
    public static ChromeProtocol.Domains.Debugger.StepOverRequest StepOver(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.LocationRangeType>? SkipList = default)
    {
      return new ChromeProtocol.Domains.Debugger.StepOverRequest(SkipList);
    }
    /// <summary>Steps over the statement.</summary>
    /// <param name="SkipList">The skipList specifies location ranges that should be skipped on step over.</param>
    [ChromeProtocol.Core.MethodName("Debugger.stepOver")]
    public record StepOverRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("skipList")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Debugger.LocationRangeType>? SkipList = default
    ) : ChromeProtocol.Core.ICommand<StepOverRequestResult>
    {
    }
    public record StepOverRequestResult() : ChromeProtocol.Core.IType
    {
    }
  }
}
