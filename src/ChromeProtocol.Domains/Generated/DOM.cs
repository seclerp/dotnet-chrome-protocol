// <auto-generated />
#nullable enable

namespace ChromeProtocol.Domains
{
  /// <summary>
  /// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object<br/>
  /// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into<br/>
  /// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the<br/>
  /// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client<br/>
  /// and never sends the same node twice. It is client&#39;s responsibility to collect information about<br/>
  /// the nodes that were sent to the client. Note that `iframe` owner elements will return<br/>
  /// corresponding document elements as their child nodes.<br/>
  /// </summary>
  public static partial class DOM
  {
    /// <summary>Unique DOM node identifier.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record NodeIdType(
      int Value
    ) : ChromeProtocol.Core.PrimitiveType<int>(Value)
    {
    }
    /// <summary>
    /// Unique DOM node identifier used to reference a node that may not have been pushed to the<br/>
    /// front-end.<br/>
    /// </summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record BackendNodeIdType(
      int Value
    ) : ChromeProtocol.Core.PrimitiveType<int>(Value)
    {
    }
    /// <summary>Backend node with a friendly name.</summary>
    /// <param name="NodeType">`Node`&#39;s nodeType.</param>
    /// <param name="NodeName">`Node`&#39;s nodeName.</param>
    public record BackendNodeType(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeType")]
      int NodeType,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeName")]
      string NodeName,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType BackendNodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Pseudo element type.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record PseudoTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Shadow root type.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ShadowRootTypeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Document compatibility mode.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record CompatibilityModeType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>ContainerSelector physical axes</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record PhysicalAxesType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>ContainerSelector logical axes</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record LogicalAxesType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Physical scroll orientation</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]
    public record ScrollOrientationType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>
    /// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.<br/>
    /// DOMNode is a base node mirror type.<br/>
    /// </summary>
    /// <param name="NodeId">
    /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend<br/>
    /// will only push node with given `id` once. It is aware of all requested nodes and will only<br/>
    /// fire DOM events for nodes known to the client.<br/>
    /// </param>
    /// <param name="BackendNodeId">The BackendNodeId for this node.</param>
    /// <param name="NodeTypeProperty">`Node`&#39;s nodeType.</param>
    /// <param name="NodeName">`Node`&#39;s nodeName.</param>
    /// <param name="LocalName">`Node`&#39;s localName.</param>
    /// <param name="NodeValue">`Node`&#39;s nodeValue.</param>
    /// <param name="ParentId">The id of the parent node if any.</param>
    /// <param name="ChildNodeCount">Child count for `Container` nodes.</param>
    /// <param name="Children">Child nodes of this node when requested with children.</param>
    /// <param name="Attributes">Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.</param>
    /// <param name="DocumentURL">Document URL that `Document` or `FrameOwner` node points to.</param>
    /// <param name="BaseURL">Base URL that `Document` or `FrameOwner` node uses for URL completion.</param>
    /// <param name="PublicId">`DocumentType`&#39;s publicId.</param>
    /// <param name="SystemId">`DocumentType`&#39;s systemId.</param>
    /// <param name="InternalSubset">`DocumentType`&#39;s internalSubset.</param>
    /// <param name="XmlVersion">`Document`&#39;s XML version in case of XML documents.</param>
    /// <param name="Name">`Attr`&#39;s name.</param>
    /// <param name="Value">`Attr`&#39;s value.</param>
    /// <param name="PseudoType">Pseudo element type for this node.</param>
    /// <param name="PseudoIdentifier">
    /// Pseudo element identifier for this node. Only present if there is a<br/>
    /// valid pseudoType.<br/>
    /// </param>
    /// <param name="ShadowRootType">Shadow root type.</param>
    /// <param name="FrameId">Frame ID for frame owner elements.</param>
    /// <param name="ContentDocument">Content document for frame owner elements.</param>
    /// <param name="ShadowRoots">Shadow root list for given element host.</param>
    /// <param name="TemplateContent">Content document fragment for template elements.</param>
    /// <param name="PseudoElements">Pseudo elements associated with this node.</param>
    /// <param name="ImportedDocument">
    /// Deprecated, as the HTML Imports API has been removed (crbug.com/937746).<br/>
    /// This property used to return the imported document for the HTMLImport links.<br/>
    /// The property is always undefined now.<br/>
    /// </param>
    /// <param name="DistributedNodes">Distributed nodes for given insertion point.</param>
    /// <param name="IsSVG">Whether the node is SVG.</param>
    public record NodeType(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType BackendNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeType")]
      int NodeTypeProperty,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeName")]
      string NodeName,
      [property: System.Text.Json.Serialization.JsonPropertyName("localName")]
      string LocalName,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeValue")]
      string NodeValue,
      [property: System.Text.Json.Serialization.JsonPropertyName("parentId")]
      ChromeProtocol.Domains.DOM.NodeIdType? ParentId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("childNodeCount")]
      int? ChildNodeCount = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("children")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeType>? Children = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("attributes")]
      System.Collections.Generic.IReadOnlyList<string>? Attributes = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("documentURL")]
      string? DocumentURL = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("baseURL")]
      string? BaseURL = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("publicId")]
      string? PublicId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("systemId")]
      string? SystemId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("internalSubset")]
      string? InternalSubset = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("xmlVersion")]
      string? XmlVersion = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string? Name = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string? Value = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pseudoType")]
      ChromeProtocol.Domains.DOM.PseudoTypeType? PseudoType = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pseudoIdentifier")]
      string? PseudoIdentifier = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("shadowRootType")]
      ChromeProtocol.Domains.DOM.ShadowRootTypeType? ShadowRootType = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType? FrameId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("contentDocument")]
      ChromeProtocol.Domains.DOM.NodeType? ContentDocument = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("shadowRoots")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeType>? ShadowRoots = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("templateContent")]
      ChromeProtocol.Domains.DOM.NodeType? TemplateContent = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pseudoElements")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeType>? PseudoElements = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: System.Text.Json.Serialization.JsonPropertyName("importedDocument")]
      ChromeProtocol.Domains.DOM.NodeType? ImportedDocument = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("distributedNodes")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.BackendNodeType>? DistributedNodes = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isSVG")]
      bool? IsSVG = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("compatibilityMode")]
      ChromeProtocol.Domains.DOM.CompatibilityModeType? CompatibilityMode = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("assignedSlot")]
      ChromeProtocol.Domains.DOM.BackendNodeType? AssignedSlot = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("isScrollable")]
      bool? IsScrollable = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>A structure to hold the top-level node of a detached tree and an array of its retained descendants.</summary>
    public record DetachedElementInfoType(
      [property: System.Text.Json.Serialization.JsonPropertyName("treeNode")]
      ChromeProtocol.Domains.DOM.NodeType TreeNode,
      [property: System.Text.Json.Serialization.JsonPropertyName("retainedNodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> RetainedNodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>A structure holding an RGBA color.</summary>
    /// <param name="R">The red component, in the [0-255] range.</param>
    /// <param name="G">The green component, in the [0-255] range.</param>
    /// <param name="B">The blue component, in the [0-255] range.</param>
    /// <param name="A">The alpha component, in the [0-1] range (default: 1).</param>
    public record RGBAType(
      [property: System.Text.Json.Serialization.JsonPropertyName("r")]
      int R,
      [property: System.Text.Json.Serialization.JsonPropertyName("g")]
      int G,
      [property: System.Text.Json.Serialization.JsonPropertyName("b")]
      int B,
      [property: System.Text.Json.Serialization.JsonPropertyName("a")]
      double? A = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>An array of quad vertices, x immediately followed by y for each point, points clock-wise.</summary>
    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.ArrayTypeConverter))]
    public record QuadType(
      System.Collections.Generic.IReadOnlyCollection<System.Text.Json.Nodes.JsonNode> Items
    ) : ChromeProtocol.Core.IArrayType
    {
    }
    /// <summary>Box model.</summary>
    /// <param name="Content">Content box</param>
    /// <param name="Padding">Padding box</param>
    /// <param name="Border">Border box</param>
    /// <param name="Margin">Margin box</param>
    /// <param name="Width">Node width</param>
    /// <param name="Height">Node height</param>
    /// <param name="ShapeOutside">Shape outside coordinates</param>
    public record BoxModelType(
      [property: System.Text.Json.Serialization.JsonPropertyName("content")]
      ChromeProtocol.Domains.DOM.QuadType Content,
      [property: System.Text.Json.Serialization.JsonPropertyName("padding")]
      ChromeProtocol.Domains.DOM.QuadType Padding,
      [property: System.Text.Json.Serialization.JsonPropertyName("border")]
      ChromeProtocol.Domains.DOM.QuadType Border,
      [property: System.Text.Json.Serialization.JsonPropertyName("margin")]
      ChromeProtocol.Domains.DOM.QuadType Margin,
      [property: System.Text.Json.Serialization.JsonPropertyName("width")]
      int Width,
      [property: System.Text.Json.Serialization.JsonPropertyName("height")]
      int Height,
      [property: System.Text.Json.Serialization.JsonPropertyName("shapeOutside")]
      ChromeProtocol.Domains.DOM.ShapeOutsideInfoType? ShapeOutside = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>CSS Shape Outside details.</summary>
    /// <param name="Bounds">Shape bounds</param>
    /// <param name="Shape">Shape coordinate details</param>
    /// <param name="MarginShape">Margin shape bounds</param>
    public record ShapeOutsideInfoType(
      [property: System.Text.Json.Serialization.JsonPropertyName("bounds")]
      ChromeProtocol.Domains.DOM.QuadType Bounds,
      [property: System.Text.Json.Serialization.JsonPropertyName("shape")]
      System.Collections.Generic.IReadOnlyList<System.Text.Json.Nodes.JsonNode> Shape,
      [property: System.Text.Json.Serialization.JsonPropertyName("marginShape")]
      System.Collections.Generic.IReadOnlyList<System.Text.Json.Nodes.JsonNode> MarginShape
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Rectangle.</summary>
    /// <param name="X">X coordinate</param>
    /// <param name="Y">Y coordinate</param>
    /// <param name="Width">Rectangle width</param>
    /// <param name="Height">Rectangle height</param>
    public record RectType(
      [property: System.Text.Json.Serialization.JsonPropertyName("x")]
      double X,
      [property: System.Text.Json.Serialization.JsonPropertyName("y")]
      double Y,
      [property: System.Text.Json.Serialization.JsonPropertyName("width")]
      double Width,
      [property: System.Text.Json.Serialization.JsonPropertyName("height")]
      double Height
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <param name="Name">Computed style property name.</param>
    /// <param name="Value">Computed style property value.</param>
    public record CSSComputedStylePropertyType(
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Fired when `Element`&#39;s attribute is modified.</summary>
    /// <param name="NodeId">Id of the node that has changed.</param>
    /// <param name="Name">Attribute name.</param>
    /// <param name="Value">Attribute value.</param>
    [ChromeProtocol.Core.MethodName("DOM.attributeModified")]
    public record AttributeModified(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when `Element`&#39;s attribute is removed.</summary>
    /// <param name="NodeId">Id of the node that has changed.</param>
    /// <param name="Name">A ttribute name.</param>
    [ChromeProtocol.Core.MethodName("DOM.attributeRemoved")]
    public record AttributeRemoved(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Mirrors `DOMCharacterDataModified` event.</summary>
    /// <param name="NodeId">Id of the node that has changed.</param>
    /// <param name="CharacterData">New text value.</param>
    [ChromeProtocol.Core.MethodName("DOM.characterDataModified")]
    public record CharacterDataModified(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("characterData")]
      string CharacterData
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when `Container`&#39;s child node count has changed.</summary>
    /// <param name="NodeId">Id of the node that has changed.</param>
    /// <param name="ChildNodeCount">New node count.</param>
    [ChromeProtocol.Core.MethodName("DOM.childNodeCountUpdated")]
    public record ChildNodeCountUpdated(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("childNodeCount")]
      int ChildNodeCount
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Mirrors `DOMNodeInserted` event.</summary>
    /// <param name="ParentNodeId">Id of the node that has changed.</param>
    /// <param name="PreviousNodeId">Id of the previous sibling.</param>
    /// <param name="Node">Inserted node data.</param>
    [ChromeProtocol.Core.MethodName("DOM.childNodeInserted")]
    public record ChildNodeInserted(
      [property: System.Text.Json.Serialization.JsonPropertyName("parentNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType ParentNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("previousNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType PreviousNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("node")]
      ChromeProtocol.Domains.DOM.NodeType Node
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Mirrors `DOMNodeRemoved` event.</summary>
    /// <param name="ParentNodeId">Parent id.</param>
    /// <param name="NodeId">Id of the node that has been removed.</param>
    [ChromeProtocol.Core.MethodName("DOM.childNodeRemoved")]
    public record ChildNodeRemoved(
      [property: System.Text.Json.Serialization.JsonPropertyName("parentNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType ParentNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Called when distribution is changed.</summary>
    /// <param name="InsertionPointId">Insertion point where distributed nodes were updated.</param>
    /// <param name="DistributedNodes">Distributed nodes for given insertion point.</param>
    [ChromeProtocol.Core.MethodName("DOM.distributedNodesUpdated")]
    public record DistributedNodesUpdated(
      [property: System.Text.Json.Serialization.JsonPropertyName("insertionPointId")]
      ChromeProtocol.Domains.DOM.NodeIdType InsertionPointId,
      [property: System.Text.Json.Serialization.JsonPropertyName("distributedNodes")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.BackendNodeType> DistributedNodes
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when `Document` has been totally updated. Node ids are no longer valid.</summary>
    [ChromeProtocol.Core.MethodName("DOM.documentUpdated")]
    public record DocumentUpdated() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when `Element`&#39;s inline style is modified via a CSS property modification.</summary>
    /// <param name="NodeIds">Ids of the nodes for which the inline styles have been invalidated.</param>
    [ChromeProtocol.Core.MethodName("DOM.inlineStyleInvalidated")]
    public record InlineStyleInvalidated(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Called when a pseudo element is added to an element.</summary>
    /// <param name="ParentId">Pseudo element&#39;s parent element id.</param>
    /// <param name="PseudoElement">The added pseudo element.</param>
    [ChromeProtocol.Core.MethodName("DOM.pseudoElementAdded")]
    public record PseudoElementAdded(
      [property: System.Text.Json.Serialization.JsonPropertyName("parentId")]
      ChromeProtocol.Domains.DOM.NodeIdType ParentId,
      [property: System.Text.Json.Serialization.JsonPropertyName("pseudoElement")]
      ChromeProtocol.Domains.DOM.NodeType PseudoElement
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Called when top layer elements are changed.</summary>
    [ChromeProtocol.Core.MethodName("DOM.topLayerElementsUpdated")]
    public record TopLayerElementsUpdated() : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Fired when a node&#39;s scrollability state changes.</summary>
    /// <param name="NodeId">The id of the node.</param>
    /// <param name="IsScrollable">If the node is scrollable.</param>
    [ChromeProtocol.Core.MethodName("DOM.scrollableFlagUpdated")]
    public record ScrollableFlagUpdated(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("isScrollable")]
      bool IsScrollable
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Called when a pseudo element is removed from an element.</summary>
    /// <param name="ParentId">Pseudo element&#39;s parent element id.</param>
    /// <param name="PseudoElementId">The removed pseudo element id.</param>
    [ChromeProtocol.Core.MethodName("DOM.pseudoElementRemoved")]
    public record PseudoElementRemoved(
      [property: System.Text.Json.Serialization.JsonPropertyName("parentId")]
      ChromeProtocol.Domains.DOM.NodeIdType ParentId,
      [property: System.Text.Json.Serialization.JsonPropertyName("pseudoElementId")]
      ChromeProtocol.Domains.DOM.NodeIdType PseudoElementId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Fired when backend wants to provide client with the missing DOM structure. This happens upon<br/>
    /// most of the calls requesting node ids.<br/>
    /// </summary>
    /// <param name="ParentId">Parent node id to populate with children.</param>
    /// <param name="Nodes">Child nodes array.</param>
    [ChromeProtocol.Core.MethodName("DOM.setChildNodes")]
    public record SetChildNodes(
      [property: System.Text.Json.Serialization.JsonPropertyName("parentId")]
      ChromeProtocol.Domains.DOM.NodeIdType ParentId,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodes")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeType> Nodes
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Called when shadow root is popped from the element.</summary>
    /// <param name="HostId">Host element id.</param>
    /// <param name="RootId">Shadow root id.</param>
    [ChromeProtocol.Core.MethodName("DOM.shadowRootPopped")]
    public record ShadowRootPopped(
      [property: System.Text.Json.Serialization.JsonPropertyName("hostId")]
      ChromeProtocol.Domains.DOM.NodeIdType HostId,
      [property: System.Text.Json.Serialization.JsonPropertyName("rootId")]
      ChromeProtocol.Domains.DOM.NodeIdType RootId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Called when shadow root is pushed into the element.</summary>
    /// <param name="HostId">Host element id.</param>
    /// <param name="Root">Shadow root.</param>
    [ChromeProtocol.Core.MethodName("DOM.shadowRootPushed")]
    public record ShadowRootPushed(
      [property: System.Text.Json.Serialization.JsonPropertyName("hostId")]
      ChromeProtocol.Domains.DOM.NodeIdType HostId,
      [property: System.Text.Json.Serialization.JsonPropertyName("root")]
      ChromeProtocol.Domains.DOM.NodeType Root
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Collects class names for the node with given id and all of it&#39;s child nodes.</summary>
    /// <param name="NodeId">Id of the node to collect class names.</param>
    public static ChromeProtocol.Domains.DOM.CollectClassNamesFromSubtreeRequest CollectClassNamesFromSubtree(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.CollectClassNamesFromSubtreeRequest(NodeId);
    }
    /// <summary>Collects class names for the node with given id and all of it&#39;s child nodes.</summary>
    /// <param name="NodeId">Id of the node to collect class names.</param>
    [ChromeProtocol.Core.MethodName("DOM.collectClassNamesFromSubtree")]
    public record CollectClassNamesFromSubtreeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<CollectClassNamesFromSubtreeRequestResult>
    {
    }
    /// <param name="ClassNames">Class name list.</param>
    public record CollectClassNamesFromSubtreeRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("classNames")]
      System.Collections.Generic.IReadOnlyList<string> ClassNames
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Creates a deep copy of the specified node and places it into the target container before the<br/>
    /// given anchor.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the node to copy.</param>
    /// <param name="TargetNodeId">Id of the element to drop the copy into.</param>
    /// <param name="InsertBeforeNodeId">
    /// Drop the copy before this node (if absent, the copy becomes the last child of<br/>
    /// `targetNodeId`).<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.CopyToRequest CopyTo(ChromeProtocol.Domains.DOM.NodeIdType NodeId, ChromeProtocol.Domains.DOM.NodeIdType TargetNodeId, ChromeProtocol.Domains.DOM.NodeIdType? InsertBeforeNodeId = default)    
    {
      return new ChromeProtocol.Domains.DOM.CopyToRequest(NodeId, TargetNodeId, InsertBeforeNodeId);
    }
    /// <summary>
    /// Creates a deep copy of the specified node and places it into the target container before the<br/>
    /// given anchor.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the node to copy.</param>
    /// <param name="TargetNodeId">Id of the element to drop the copy into.</param>
    /// <param name="InsertBeforeNodeId">
    /// Drop the copy before this node (if absent, the copy becomes the last child of<br/>
    /// `targetNodeId`).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.copyTo")]
    public record CopyToRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("targetNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType TargetNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("insertBeforeNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? InsertBeforeNodeId = default
    ) : ChromeProtocol.Core.ICommand<CopyToRequestResult>
    {
    }
    /// <param name="NodeId">Id of the node clone.</param>
    public record CopyToRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Describes node given its id, does not require domain to be enabled. Does not start tracking any<br/>
    /// objects, can be used for automation.<br/>
    /// </summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the subtree<br/>
    /// (default is false).<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.DescribeNodeRequest DescribeNode(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default, int? Depth = default, bool? Pierce = default)    
    {
      return new ChromeProtocol.Domains.DOM.DescribeNodeRequest(NodeId, BackendNodeId, ObjectId, Depth, Pierce);
    }
    /// <summary>
    /// Describes node given its id, does not require domain to be enabled. Does not start tracking any<br/>
    /// objects, can be used for automation.<br/>
    /// </summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the subtree<br/>
    /// (default is false).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.describeNode")]
    public record DescribeNodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("depth")]
      int? Depth = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pierce")]
      bool? Pierce = default
    ) : ChromeProtocol.Core.ICommand<DescribeNodeRequestResult>
    {
    }
    /// <param name="Node">Node description.</param>
    public record DescribeNodeRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("node")]
      ChromeProtocol.Domains.DOM.NodeType Node
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Scrolls the specified rect of the given node into view if not already visible.<br/>
    /// Note: exactly one between nodeId, backendNodeId and objectId should be passed<br/>
    /// to identify the node.<br/>
    /// </summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    /// <param name="Rect">
    /// The rect to be scrolled into view, relative to the node&#39;s border box, in CSS pixels.<br/>
    /// When omitted, center of the node will be used, similar to Element.scrollIntoView.<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.ScrollIntoViewIfNeededRequest ScrollIntoViewIfNeeded(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default, ChromeProtocol.Domains.DOM.RectType? Rect = default)    
    {
      return new ChromeProtocol.Domains.DOM.ScrollIntoViewIfNeededRequest(NodeId, BackendNodeId, ObjectId, Rect);
    }
    /// <summary>
    /// Scrolls the specified rect of the given node into view if not already visible.<br/>
    /// Note: exactly one between nodeId, backendNodeId and objectId should be passed<br/>
    /// to identify the node.<br/>
    /// </summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    /// <param name="Rect">
    /// The rect to be scrolled into view, relative to the node&#39;s border box, in CSS pixels.<br/>
    /// When omitted, center of the node will be used, similar to Element.scrollIntoView.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.scrollIntoViewIfNeeded")]
    public record ScrollIntoViewIfNeededRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("rect")]
      ChromeProtocol.Domains.DOM.RectType? Rect = default
    ) : ChromeProtocol.Core.ICommand<ScrollIntoViewIfNeededRequestResult>
    {
    }
    public record ScrollIntoViewIfNeededRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Disables DOM agent for the given page.</summary>
    public static ChromeProtocol.Domains.DOM.DisableRequest Disable()    
    {
      return new ChromeProtocol.Domains.DOM.DisableRequest();
    }
    /// <summary>Disables DOM agent for the given page.</summary>
    [ChromeProtocol.Core.MethodName("DOM.disable")]
    public record DisableRequest() : ChromeProtocol.Core.ICommand<DisableRequestResult>
    {
    }
    public record DisableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Discards search results from the session with the given id. `getSearchResults` should no longer<br/>
    /// be called for that search.<br/>
    /// </summary>
    /// <param name="SearchId">Unique search session identifier.</param>
    public static ChromeProtocol.Domains.DOM.DiscardSearchResultsRequest DiscardSearchResults(string SearchId)    
    {
      return new ChromeProtocol.Domains.DOM.DiscardSearchResultsRequest(SearchId);
    }
    /// <summary>
    /// Discards search results from the session with the given id. `getSearchResults` should no longer<br/>
    /// be called for that search.<br/>
    /// </summary>
    /// <param name="SearchId">Unique search session identifier.</param>
    [ChromeProtocol.Core.MethodName("DOM.discardSearchResults")]
    public record DiscardSearchResultsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("searchId")]
      string SearchId
    ) : ChromeProtocol.Core.ICommand<DiscardSearchResultsRequestResult>
    {
    }
    public record DiscardSearchResultsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Enables DOM agent for the given page.</summary>
    /// <param name="IncludeWhitespace">Whether to include whitespaces in the children array of returned Nodes.</param>
    public static ChromeProtocol.Domains.DOM.EnableRequest Enable(string? IncludeWhitespace = default)    
    {
      return new ChromeProtocol.Domains.DOM.EnableRequest(IncludeWhitespace);
    }
    /// <summary>Enables DOM agent for the given page.</summary>
    /// <param name="IncludeWhitespace">Whether to include whitespaces in the children array of returned Nodes.</param>
    [ChromeProtocol.Core.MethodName("DOM.enable")]
    public record EnableRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("includeWhitespace")]
      string? IncludeWhitespace = default
    ) : ChromeProtocol.Core.ICommand<EnableRequestResult>
    {
    }
    public record EnableRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Focuses the given element.</summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    public static ChromeProtocol.Domains.DOM.FocusRequest Focus(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default)    
    {
      return new ChromeProtocol.Domains.DOM.FocusRequest(NodeId, BackendNodeId, ObjectId);
    }
    /// <summary>Focuses the given element.</summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    [ChromeProtocol.Core.MethodName("DOM.focus")]
    public record FocusRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default
    ) : ChromeProtocol.Core.ICommand<FocusRequestResult>
    {
    }
    public record FocusRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns attributes for the specified node.</summary>
    /// <param name="NodeId">Id of the node to retrieve attributes for.</param>
    public static ChromeProtocol.Domains.DOM.GetAttributesRequest GetAttributes(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.GetAttributesRequest(NodeId);
    }
    /// <summary>Returns attributes for the specified node.</summary>
    /// <param name="NodeId">Id of the node to retrieve attributes for.</param>
    [ChromeProtocol.Core.MethodName("DOM.getAttributes")]
    public record GetAttributesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<GetAttributesRequestResult>
    {
    }
    /// <param name="Attributes">An interleaved array of node attribute names and values.</param>
    public record GetAttributesRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("attributes")]
      System.Collections.Generic.IReadOnlyList<string> Attributes
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns boxes for the given node.</summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    public static ChromeProtocol.Domains.DOM.GetBoxModelRequest GetBoxModel(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetBoxModelRequest(NodeId, BackendNodeId, ObjectId);
    }
    /// <summary>Returns boxes for the given node.</summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    [ChromeProtocol.Core.MethodName("DOM.getBoxModel")]
    public record GetBoxModelRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default
    ) : ChromeProtocol.Core.ICommand<GetBoxModelRequestResult>
    {
    }
    /// <param name="Model">Box model for the node.</param>
    public record GetBoxModelRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("model")]
      ChromeProtocol.Domains.DOM.BoxModelType Model
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns quads that describe node position on the page. This method<br/>
    /// might return multiple quads for inline nodes.<br/>
    /// </summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    public static ChromeProtocol.Domains.DOM.GetContentQuadsRequest GetContentQuads(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetContentQuadsRequest(NodeId, BackendNodeId, ObjectId);
    }
    /// <summary>
    /// Returns quads that describe node position on the page. This method<br/>
    /// might return multiple quads for inline nodes.<br/>
    /// </summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    [ChromeProtocol.Core.MethodName("DOM.getContentQuads")]
    public record GetContentQuadsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default
    ) : ChromeProtocol.Core.ICommand<GetContentQuadsRequestResult>
    {
    }
    /// <param name="Quads">Quads that describe node layout relative to viewport.</param>
    public record GetContentQuadsRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("quads")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.QuadType> Quads
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the root DOM node (and optionally the subtree) to the caller.<br/>
    /// Implicitly enables the DOM domain events for the current target.<br/>
    /// </summary>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the subtree<br/>
    /// (default is false).<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.GetDocumentRequest GetDocument(int? Depth = default, bool? Pierce = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetDocumentRequest(Depth, Pierce);
    }
    /// <summary>
    /// Returns the root DOM node (and optionally the subtree) to the caller.<br/>
    /// Implicitly enables the DOM domain events for the current target.<br/>
    /// </summary>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the subtree<br/>
    /// (default is false).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.getDocument")]
    public record GetDocumentRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("depth")]
      int? Depth = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pierce")]
      bool? Pierce = default
    ) : ChromeProtocol.Core.ICommand<GetDocumentRequestResult>
    {
    }
    /// <param name="Root">Resulting node.</param>
    public record GetDocumentRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("root")]
      ChromeProtocol.Domains.DOM.NodeType Root
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the root DOM node (and optionally the subtree) to the caller.<br/>
    /// Deprecated, as it is not designed to work well with the rest of the DOM agent.<br/>
    /// Use DOMSnapshot.captureSnapshot instead.<br/>
    /// </summary>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the subtree<br/>
    /// (default is false).<br/>
    /// </param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.DOM.GetFlattenedDocumentRequest GetFlattenedDocument(int? Depth = default, bool? Pierce = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetFlattenedDocumentRequest(Depth, Pierce);
    }
    /// <summary>
    /// Returns the root DOM node (and optionally the subtree) to the caller.<br/>
    /// Deprecated, as it is not designed to work well with the rest of the DOM agent.<br/>
    /// Use DOMSnapshot.captureSnapshot instead.<br/>
    /// </summary>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the subtree<br/>
    /// (default is false).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.getFlattenedDocument")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetFlattenedDocumentRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("depth")]
      int? Depth = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pierce")]
      bool? Pierce = default
    ) : ChromeProtocol.Core.ICommand<GetFlattenedDocumentRequestResult>
    {
    }
    /// <param name="Nodes">Resulting node.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record GetFlattenedDocumentRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodes")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeType> Nodes
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Finds nodes with a given computed style in a subtree.</summary>
    /// <param name="NodeId">Node ID pointing to the root of a subtree.</param>
    /// <param name="ComputedStyles">The style to filter nodes by (includes nodes if any of properties matches).</param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots in the same target should be traversed when returning the<br/>
    /// results (default is false).<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.GetNodesForSubtreeByStyleRequest GetNodesForSubtreeByStyle(ChromeProtocol.Domains.DOM.NodeIdType NodeId, System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.CSSComputedStylePropertyType> ComputedStyles, bool? Pierce = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetNodesForSubtreeByStyleRequest(NodeId, ComputedStyles, Pierce);
    }
    /// <summary>Finds nodes with a given computed style in a subtree.</summary>
    /// <param name="NodeId">Node ID pointing to the root of a subtree.</param>
    /// <param name="ComputedStyles">The style to filter nodes by (includes nodes if any of properties matches).</param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots in the same target should be traversed when returning the<br/>
    /// results (default is false).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.getNodesForSubtreeByStyle")]
    public record GetNodesForSubtreeByStyleRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("computedStyles")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.CSSComputedStylePropertyType> ComputedStyles,
      [property: System.Text.Json.Serialization.JsonPropertyName("pierce")]
      bool? Pierce = default
    ) : ChromeProtocol.Core.ICommand<GetNodesForSubtreeByStyleRequestResult>
    {
    }
    /// <param name="NodeIds">Resulting nodes.</param>
    public record GetNodesForSubtreeByStyleRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is<br/>
    /// either returned or not.<br/>
    /// </summary>
    /// <param name="X">X coordinate.</param>
    /// <param name="Y">Y coordinate.</param>
    /// <param name="IncludeUserAgentShadowDOM">False to skip to the nearest non-UA shadow root ancestor (default: false).</param>
    /// <param name="IgnorePointerEventsNone">Whether to ignore pointer-events: none on elements and hit test them.</param>
    public static ChromeProtocol.Domains.DOM.GetNodeForLocationRequest GetNodeForLocation(int X, int Y, bool? IncludeUserAgentShadowDOM = default, bool? IgnorePointerEventsNone = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetNodeForLocationRequest(X, Y, IncludeUserAgentShadowDOM, IgnorePointerEventsNone);
    }
    /// <summary>
    /// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is<br/>
    /// either returned or not.<br/>
    /// </summary>
    /// <param name="X">X coordinate.</param>
    /// <param name="Y">Y coordinate.</param>
    /// <param name="IncludeUserAgentShadowDOM">False to skip to the nearest non-UA shadow root ancestor (default: false).</param>
    /// <param name="IgnorePointerEventsNone">Whether to ignore pointer-events: none on elements and hit test them.</param>
    [ChromeProtocol.Core.MethodName("DOM.getNodeForLocation")]
    public record GetNodeForLocationRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("x")]
      int X,
      [property: System.Text.Json.Serialization.JsonPropertyName("y")]
      int Y,
      [property: System.Text.Json.Serialization.JsonPropertyName("includeUserAgentShadowDOM")]
      bool? IncludeUserAgentShadowDOM = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("ignorePointerEventsNone")]
      bool? IgnorePointerEventsNone = default
    ) : ChromeProtocol.Core.ICommand<GetNodeForLocationRequestResult>
    {
    }
    /// <param name="BackendNodeId">Resulting node.</param>
    /// <param name="FrameId">Frame this node belongs to.</param>
    /// <param name="NodeId">Id of the node at given coordinates, only when enabled and requested document.</param>
    public record GetNodeForLocationRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType BackendNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns node&#39;s HTML markup.</summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    public static ChromeProtocol.Domains.DOM.GetOuterHTMLRequest GetOuterHTML(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetOuterHTMLRequest(NodeId, BackendNodeId, ObjectId);
    }
    /// <summary>Returns node&#39;s HTML markup.</summary>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    [ChromeProtocol.Core.MethodName("DOM.getOuterHTML")]
    public record GetOuterHTMLRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default
    ) : ChromeProtocol.Core.ICommand<GetOuterHTMLRequestResult>
    {
    }
    /// <param name="OuterHTML">Outer HTML markup.</param>
    public record GetOuterHTMLRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("outerHTML")]
      string OuterHTML
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns the id of the nearest ancestor that is a relayout boundary.</summary>
    /// <param name="NodeId">Id of the node.</param>
    public static ChromeProtocol.Domains.DOM.GetRelayoutBoundaryRequest GetRelayoutBoundary(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.GetRelayoutBoundaryRequest(NodeId);
    }
    /// <summary>Returns the id of the nearest ancestor that is a relayout boundary.</summary>
    /// <param name="NodeId">Id of the node.</param>
    [ChromeProtocol.Core.MethodName("DOM.getRelayoutBoundary")]
    public record GetRelayoutBoundaryRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<GetRelayoutBoundaryRequestResult>
    {
    }
    /// <param name="NodeId">Relayout boundary node id for the given node.</param>
    public record GetRelayoutBoundaryRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns search results from given `fromIndex` to given `toIndex` from the search with the given<br/>
    /// identifier.<br/>
    /// </summary>
    /// <param name="SearchId">Unique search session identifier.</param>
    /// <param name="FromIndex">Start index of the search result to be returned.</param>
    /// <param name="ToIndex">End index of the search result to be returned.</param>
    public static ChromeProtocol.Domains.DOM.GetSearchResultsRequest GetSearchResults(string SearchId, int FromIndex, int ToIndex)    
    {
      return new ChromeProtocol.Domains.DOM.GetSearchResultsRequest(SearchId, FromIndex, ToIndex);
    }
    /// <summary>
    /// Returns search results from given `fromIndex` to given `toIndex` from the search with the given<br/>
    /// identifier.<br/>
    /// </summary>
    /// <param name="SearchId">Unique search session identifier.</param>
    /// <param name="FromIndex">Start index of the search result to be returned.</param>
    /// <param name="ToIndex">End index of the search result to be returned.</param>
    [ChromeProtocol.Core.MethodName("DOM.getSearchResults")]
    public record GetSearchResultsRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("searchId")]
      string SearchId,
      [property: System.Text.Json.Serialization.JsonPropertyName("fromIndex")]
      int FromIndex,
      [property: System.Text.Json.Serialization.JsonPropertyName("toIndex")]
      int ToIndex
    ) : ChromeProtocol.Core.ICommand<GetSearchResultsRequestResult>
    {
    }
    /// <param name="NodeIds">Ids of the search result nodes.</param>
    public record GetSearchResultsRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Hides any highlight.</summary>
    public static ChromeProtocol.Domains.DOM.HideHighlightRequest HideHighlight()    
    {
      return new ChromeProtocol.Domains.DOM.HideHighlightRequest();
    }
    /// <summary>Hides any highlight.</summary>
    [ChromeProtocol.Core.MethodName("DOM.hideHighlight")]
    public record HideHighlightRequest() : ChromeProtocol.Core.ICommand<HideHighlightRequestResult>
    {
    }
    public record HideHighlightRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Highlights DOM node.</summary>
    public static ChromeProtocol.Domains.DOM.HighlightNodeRequest HighlightNode()    
    {
      return new ChromeProtocol.Domains.DOM.HighlightNodeRequest();
    }
    /// <summary>Highlights DOM node.</summary>
    [ChromeProtocol.Core.MethodName("DOM.highlightNode")]
    public record HighlightNodeRequest() : ChromeProtocol.Core.ICommand<HighlightNodeRequestResult>
    {
    }
    public record HighlightNodeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Highlights given rectangle.</summary>
    public static ChromeProtocol.Domains.DOM.HighlightRectRequest HighlightRect()    
    {
      return new ChromeProtocol.Domains.DOM.HighlightRectRequest();
    }
    /// <summary>Highlights given rectangle.</summary>
    [ChromeProtocol.Core.MethodName("DOM.highlightRect")]
    public record HighlightRectRequest() : ChromeProtocol.Core.ICommand<HighlightRectRequestResult>
    {
    }
    public record HighlightRectRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Marks last undoable state.</summary>
    public static ChromeProtocol.Domains.DOM.MarkUndoableStateRequest MarkUndoableState()    
    {
      return new ChromeProtocol.Domains.DOM.MarkUndoableStateRequest();
    }
    /// <summary>Marks last undoable state.</summary>
    [ChromeProtocol.Core.MethodName("DOM.markUndoableState")]
    public record MarkUndoableStateRequest() : ChromeProtocol.Core.ICommand<MarkUndoableStateRequestResult>
    {
    }
    public record MarkUndoableStateRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Moves node into the new container, places it before the given anchor.</summary>
    /// <param name="NodeId">Id of the node to move.</param>
    /// <param name="TargetNodeId">Id of the element to drop the moved node into.</param>
    /// <param name="InsertBeforeNodeId">
    /// Drop node before this one (if absent, the moved node becomes the last child of<br/>
    /// `targetNodeId`).<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.MoveToRequest MoveTo(ChromeProtocol.Domains.DOM.NodeIdType NodeId, ChromeProtocol.Domains.DOM.NodeIdType TargetNodeId, ChromeProtocol.Domains.DOM.NodeIdType? InsertBeforeNodeId = default)    
    {
      return new ChromeProtocol.Domains.DOM.MoveToRequest(NodeId, TargetNodeId, InsertBeforeNodeId);
    }
    /// <summary>Moves node into the new container, places it before the given anchor.</summary>
    /// <param name="NodeId">Id of the node to move.</param>
    /// <param name="TargetNodeId">Id of the element to drop the moved node into.</param>
    /// <param name="InsertBeforeNodeId">
    /// Drop node before this one (if absent, the moved node becomes the last child of<br/>
    /// `targetNodeId`).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.moveTo")]
    public record MoveToRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("targetNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType TargetNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("insertBeforeNodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? InsertBeforeNodeId = default
    ) : ChromeProtocol.Core.ICommand<MoveToRequestResult>
    {
    }
    /// <param name="NodeId">New id of the moved node.</param>
    public record MoveToRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or<br/>
    /// `cancelSearch` to end this search session.<br/>
    /// </summary>
    /// <param name="Query">Plain text or query selector or XPath search query.</param>
    /// <param name="IncludeUserAgentShadowDOM">True to search in user agent shadow DOM.</param>
    public static ChromeProtocol.Domains.DOM.PerformSearchRequest PerformSearch(string Query, bool? IncludeUserAgentShadowDOM = default)    
    {
      return new ChromeProtocol.Domains.DOM.PerformSearchRequest(Query, IncludeUserAgentShadowDOM);
    }
    /// <summary>
    /// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or<br/>
    /// `cancelSearch` to end this search session.<br/>
    /// </summary>
    /// <param name="Query">Plain text or query selector or XPath search query.</param>
    /// <param name="IncludeUserAgentShadowDOM">True to search in user agent shadow DOM.</param>
    [ChromeProtocol.Core.MethodName("DOM.performSearch")]
    public record PerformSearchRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("query")]
      string Query,
      [property: System.Text.Json.Serialization.JsonPropertyName("includeUserAgentShadowDOM")]
      bool? IncludeUserAgentShadowDOM = default
    ) : ChromeProtocol.Core.ICommand<PerformSearchRequestResult>
    {
    }
    /// <param name="SearchId">Unique search session identifier.</param>
    /// <param name="ResultCount">Number of search results.</param>
    public record PerformSearchRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("searchId")]
      string SearchId,
      [property: System.Text.Json.Serialization.JsonPropertyName("resultCount")]
      int ResultCount
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Requests that the node is sent to the caller given its path. // FIXME, use XPath</summary>
    /// <param name="Path">Path to node in the proprietary format.</param>
    public static ChromeProtocol.Domains.DOM.PushNodeByPathToFrontendRequest PushNodeByPathToFrontend(string Path)    
    {
      return new ChromeProtocol.Domains.DOM.PushNodeByPathToFrontendRequest(Path);
    }
    /// <summary>Requests that the node is sent to the caller given its path. // FIXME, use XPath</summary>
    /// <param name="Path">Path to node in the proprietary format.</param>
    [ChromeProtocol.Core.MethodName("DOM.pushNodeByPathToFrontend")]
    public record PushNodeByPathToFrontendRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("path")]
      string Path
    ) : ChromeProtocol.Core.ICommand<PushNodeByPathToFrontendRequestResult>
    {
    }
    /// <param name="NodeId">Id of the node for given path.</param>
    public record PushNodeByPathToFrontendRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Requests that a batch of nodes is sent to the caller given their backend node ids.</summary>
    /// <param name="BackendNodeIds">The array of backend node ids.</param>
    public static ChromeProtocol.Domains.DOM.PushNodesByBackendIdsToFrontendRequest PushNodesByBackendIdsToFrontend(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.BackendNodeIdType> BackendNodeIds)    
    {
      return new ChromeProtocol.Domains.DOM.PushNodesByBackendIdsToFrontendRequest(BackendNodeIds);
    }
    /// <summary>Requests that a batch of nodes is sent to the caller given their backend node ids.</summary>
    /// <param name="BackendNodeIds">The array of backend node ids.</param>
    [ChromeProtocol.Core.MethodName("DOM.pushNodesByBackendIdsToFrontend")]
    public record PushNodesByBackendIdsToFrontendRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.BackendNodeIdType> BackendNodeIds
    ) : ChromeProtocol.Core.ICommand<PushNodesByBackendIdsToFrontendRequestResult>
    {
    }
    /// <param name="NodeIds">
    /// The array of ids of pushed nodes that correspond to the backend ids specified in<br/>
    /// backendNodeIds.<br/>
    /// </param>
    public record PushNodesByBackendIdsToFrontendRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Executes `querySelector` on a given node.</summary>
    /// <param name="NodeId">Id of the node to query upon.</param>
    /// <param name="Selector">Selector string.</param>
    public static ChromeProtocol.Domains.DOM.QuerySelectorRequest QuerySelector(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Selector)    
    {
      return new ChromeProtocol.Domains.DOM.QuerySelectorRequest(NodeId, Selector);
    }
    /// <summary>Executes `querySelector` on a given node.</summary>
    /// <param name="NodeId">Id of the node to query upon.</param>
    /// <param name="Selector">Selector string.</param>
    [ChromeProtocol.Core.MethodName("DOM.querySelector")]
    public record QuerySelectorRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("selector")]
      string Selector
    ) : ChromeProtocol.Core.ICommand<QuerySelectorRequestResult>
    {
    }
    /// <param name="NodeId">Query selector result.</param>
    public record QuerySelectorRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Executes `querySelectorAll` on a given node.</summary>
    /// <param name="NodeId">Id of the node to query upon.</param>
    /// <param name="Selector">Selector string.</param>
    public static ChromeProtocol.Domains.DOM.QuerySelectorAllRequest QuerySelectorAll(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Selector)    
    {
      return new ChromeProtocol.Domains.DOM.QuerySelectorAllRequest(NodeId, Selector);
    }
    /// <summary>Executes `querySelectorAll` on a given node.</summary>
    /// <param name="NodeId">Id of the node to query upon.</param>
    /// <param name="Selector">Selector string.</param>
    [ChromeProtocol.Core.MethodName("DOM.querySelectorAll")]
    public record QuerySelectorAllRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("selector")]
      string Selector
    ) : ChromeProtocol.Core.ICommand<QuerySelectorAllRequestResult>
    {
    }
    /// <param name="NodeIds">Query selector result.</param>
    public record QuerySelectorAllRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns NodeIds of current top layer elements.<br/>
    /// Top layer is rendered closest to the user within a viewport, therefore its elements always<br/>
    /// appear on top of all other content.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.DOM.GetTopLayerElementsRequest GetTopLayerElements()    
    {
      return new ChromeProtocol.Domains.DOM.GetTopLayerElementsRequest();
    }
    /// <summary>
    /// Returns NodeIds of current top layer elements.<br/>
    /// Top layer is rendered closest to the user within a viewport, therefore its elements always<br/>
    /// appear on top of all other content.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("DOM.getTopLayerElements")]
    public record GetTopLayerElementsRequest() : ChromeProtocol.Core.ICommand<GetTopLayerElementsRequestResult>
    {
    }
    /// <param name="NodeIds">NodeIds of top layer elements</param>
    public record GetTopLayerElementsRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns the NodeId of the matched element according to certain relations.</summary>
    /// <param name="NodeId">Id of the node from which to query the relation.</param>
    /// <param name="Relation">Type of relation to get.</param>
    public static ChromeProtocol.Domains.DOM.GetElementByRelationRequest GetElementByRelation(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Relation)    
    {
      return new ChromeProtocol.Domains.DOM.GetElementByRelationRequest(NodeId, Relation);
    }
    /// <summary>Returns the NodeId of the matched element according to certain relations.</summary>
    /// <param name="NodeId">Id of the node from which to query the relation.</param>
    /// <param name="Relation">Type of relation to get.</param>
    [ChromeProtocol.Core.MethodName("DOM.getElementByRelation")]
    public record GetElementByRelationRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("relation")]
      string Relation
    ) : ChromeProtocol.Core.ICommand<GetElementByRelationRequestResult>
    {
    }
    /// <param name="NodeId">NodeId of the element matching the queried relation.</param>
    public record GetElementByRelationRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Re-does the last undone action.</summary>
    public static ChromeProtocol.Domains.DOM.RedoRequest Redo()    
    {
      return new ChromeProtocol.Domains.DOM.RedoRequest();
    }
    /// <summary>Re-does the last undone action.</summary>
    [ChromeProtocol.Core.MethodName("DOM.redo")]
    public record RedoRequest() : ChromeProtocol.Core.ICommand<RedoRequestResult>
    {
    }
    public record RedoRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Removes attribute with given name from an element with given id.</summary>
    /// <param name="NodeId">Id of the element to remove attribute from.</param>
    /// <param name="Name">Name of the attribute to remove.</param>
    public static ChromeProtocol.Domains.DOM.RemoveAttributeRequest RemoveAttribute(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Name)    
    {
      return new ChromeProtocol.Domains.DOM.RemoveAttributeRequest(NodeId, Name);
    }
    /// <summary>Removes attribute with given name from an element with given id.</summary>
    /// <param name="NodeId">Id of the element to remove attribute from.</param>
    /// <param name="Name">Name of the attribute to remove.</param>
    [ChromeProtocol.Core.MethodName("DOM.removeAttribute")]
    public record RemoveAttributeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name
    ) : ChromeProtocol.Core.ICommand<RemoveAttributeRequestResult>
    {
    }
    public record RemoveAttributeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Removes node with given id.</summary>
    /// <param name="NodeId">Id of the node to remove.</param>
    public static ChromeProtocol.Domains.DOM.RemoveNodeRequest RemoveNode(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.RemoveNodeRequest(NodeId);
    }
    /// <summary>Removes node with given id.</summary>
    /// <param name="NodeId">Id of the node to remove.</param>
    [ChromeProtocol.Core.MethodName("DOM.removeNode")]
    public record RemoveNodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<RemoveNodeRequestResult>
    {
    }
    public record RemoveNodeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Requests that children of the node with given id are returned to the caller in form of<br/>
    /// `setChildNodes` events where not only immediate children are retrieved, but all children down to<br/>
    /// the specified depth.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the node to get children for.</param>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the sub-tree<br/>
    /// (default is false).<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.RequestChildNodesRequest RequestChildNodes(ChromeProtocol.Domains.DOM.NodeIdType NodeId, int? Depth = default, bool? Pierce = default)    
    {
      return new ChromeProtocol.Domains.DOM.RequestChildNodesRequest(NodeId, Depth, Pierce);
    }
    /// <summary>
    /// Requests that children of the node with given id are returned to the caller in form of<br/>
    /// `setChildNodes` events where not only immediate children are retrieved, but all children down to<br/>
    /// the specified depth.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the node to get children for.</param>
    /// <param name="Depth">
    /// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the<br/>
    /// entire subtree or provide an integer larger than 0.<br/>
    /// </param>
    /// <param name="Pierce">
    /// Whether or not iframes and shadow roots should be traversed when returning the sub-tree<br/>
    /// (default is false).<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.requestChildNodes")]
    public record RequestChildNodesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("depth")]
      int? Depth = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("pierce")]
      bool? Pierce = default
    ) : ChromeProtocol.Core.ICommand<RequestChildNodesRequestResult>
    {
    }
    public record RequestChildNodesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Requests that the node is sent to the caller given the JavaScript node object reference. All<br/>
    /// nodes that form the path from the node to the root are also sent to the client as a series of<br/>
    /// `setChildNodes` notifications.<br/>
    /// </summary>
    /// <param name="ObjectId">JavaScript object id to convert into node.</param>
    public static ChromeProtocol.Domains.DOM.RequestNodeRequest RequestNode(ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId)    
    {
      return new ChromeProtocol.Domains.DOM.RequestNodeRequest(ObjectId);
    }
    /// <summary>
    /// Requests that the node is sent to the caller given the JavaScript node object reference. All<br/>
    /// nodes that form the path from the node to the root are also sent to the client as a series of<br/>
    /// `setChildNodes` notifications.<br/>
    /// </summary>
    /// <param name="ObjectId">JavaScript object id to convert into node.</param>
    [ChromeProtocol.Core.MethodName("DOM.requestNode")]
    public record RequestNodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId
    ) : ChromeProtocol.Core.ICommand<RequestNodeRequestResult>
    {
    }
    /// <param name="NodeId">Node id for given object.</param>
    public record RequestNodeRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Resolves the JavaScript node object for a given NodeId or BackendNodeId.</summary>
    /// <param name="NodeId">Id of the node to resolve.</param>
    /// <param name="BackendNodeId">Backend identifier of the node to resolve.</param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release multiple objects.</param>
    /// <param name="ExecutionContextId">Execution context in which to resolve the node.</param>
    public static ChromeProtocol.Domains.DOM.ResolveNodeRequest ResolveNode(ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, string? ObjectGroup = default, ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default)    
    {
      return new ChromeProtocol.Domains.DOM.ResolveNodeRequest(NodeId, BackendNodeId, ObjectGroup, ExecutionContextId);
    }
    /// <summary>Resolves the JavaScript node object for a given NodeId or BackendNodeId.</summary>
    /// <param name="NodeId">Id of the node to resolve.</param>
    /// <param name="BackendNodeId">Backend identifier of the node to resolve.</param>
    /// <param name="ObjectGroup">Symbolic group name that can be used to release multiple objects.</param>
    /// <param name="ExecutionContextId">Execution context in which to resolve the node.</param>
    [ChromeProtocol.Core.MethodName("DOM.resolveNode")]
    public record ResolveNodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectGroup")]
      string? ObjectGroup = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("executionContextId")]
      ChromeProtocol.Domains.Runtime.ExecutionContextIdType? ExecutionContextId = default
    ) : ChromeProtocol.Core.ICommand<ResolveNodeRequestResult>
    {
    }
    /// <param name="Object">JavaScript object wrapper for given node.</param>
    public record ResolveNodeRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("object")]
      ChromeProtocol.Domains.Runtime.RemoteObjectType Object
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets attribute for an element with given id.</summary>
    /// <param name="NodeId">Id of the element to set attribute for.</param>
    /// <param name="Name">Attribute name.</param>
    /// <param name="Value">Attribute value.</param>
    public static ChromeProtocol.Domains.DOM.SetAttributeValueRequest SetAttributeValue(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Name, string Value)    
    {
      return new ChromeProtocol.Domains.DOM.SetAttributeValueRequest(NodeId, Name, Value);
    }
    /// <summary>Sets attribute for an element with given id.</summary>
    /// <param name="NodeId">Id of the element to set attribute for.</param>
    /// <param name="Name">Attribute name.</param>
    /// <param name="Value">Attribute value.</param>
    [ChromeProtocol.Core.MethodName("DOM.setAttributeValue")]
    public record SetAttributeValueRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value
    ) : ChromeProtocol.Core.ICommand<SetAttributeValueRequestResult>
    {
    }
    public record SetAttributeValueRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Sets attributes on element with given id. This method is useful when user edits some existing<br/>
    /// attribute value and types in several attribute name/value pairs.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the element to set attributes for.</param>
    /// <param name="Text">Text with a number of attributes. Will parse this text using HTML parser.</param>
    /// <param name="Name">
    /// Attribute name to replace with new attributes derived from text in case text parsed<br/>
    /// successfully.<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.SetAttributesAsTextRequest SetAttributesAsText(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Text, string? Name = default)    
    {
      return new ChromeProtocol.Domains.DOM.SetAttributesAsTextRequest(NodeId, Text, Name);
    }
    /// <summary>
    /// Sets attributes on element with given id. This method is useful when user edits some existing<br/>
    /// attribute value and types in several attribute name/value pairs.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the element to set attributes for.</param>
    /// <param name="Text">Text with a number of attributes. Will parse this text using HTML parser.</param>
    /// <param name="Name">
    /// Attribute name to replace with new attributes derived from text in case text parsed<br/>
    /// successfully.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.setAttributesAsText")]
    public record SetAttributesAsTextRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("text")]
      string Text,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string? Name = default
    ) : ChromeProtocol.Core.ICommand<SetAttributesAsTextRequestResult>
    {
    }
    public record SetAttributesAsTextRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets files for the given file input element.</summary>
    /// <param name="Files">Array of file paths to set.</param>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    public static ChromeProtocol.Domains.DOM.SetFileInputFilesRequest SetFileInputFiles(System.Collections.Generic.IReadOnlyList<string> Files, ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default, ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default, ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default)    
    {
      return new ChromeProtocol.Domains.DOM.SetFileInputFilesRequest(Files, NodeId, BackendNodeId, ObjectId);
    }
    /// <summary>Sets files for the given file input element.</summary>
    /// <param name="Files">Array of file paths to set.</param>
    /// <param name="NodeId">Identifier of the node.</param>
    /// <param name="BackendNodeId">Identifier of the backend node.</param>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    [ChromeProtocol.Core.MethodName("DOM.setFileInputFiles")]
    public record SetFileInputFilesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("files")]
      System.Collections.Generic.IReadOnlyList<string> Files,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType? BackendNodeId = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType? ObjectId = default
    ) : ChromeProtocol.Core.ICommand<SetFileInputFilesRequestResult>
    {
    }
    public record SetFileInputFilesRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.</summary>
    /// <param name="Enable">Enable or disable.</param>
    public static ChromeProtocol.Domains.DOM.SetNodeStackTracesEnabledRequest SetNodeStackTracesEnabled(bool Enable)    
    {
      return new ChromeProtocol.Domains.DOM.SetNodeStackTracesEnabledRequest(Enable);
    }
    /// <summary>Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.</summary>
    /// <param name="Enable">Enable or disable.</param>
    [ChromeProtocol.Core.MethodName("DOM.setNodeStackTracesEnabled")]
    public record SetNodeStackTracesEnabledRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("enable")]
      bool Enable
    ) : ChromeProtocol.Core.ICommand<SetNodeStackTracesEnabledRequestResult>
    {
    }
    public record SetNodeStackTracesEnabledRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.</summary>
    /// <param name="NodeId">Id of the node to get stack traces for.</param>
    public static ChromeProtocol.Domains.DOM.GetNodeStackTracesRequest GetNodeStackTraces(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.GetNodeStackTracesRequest(NodeId);
    }
    /// <summary>Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.</summary>
    /// <param name="NodeId">Id of the node to get stack traces for.</param>
    [ChromeProtocol.Core.MethodName("DOM.getNodeStackTraces")]
    public record GetNodeStackTracesRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<GetNodeStackTracesRequestResult>
    {
    }
    /// <param name="Creation">Creation stack trace, if available.</param>
    public record GetNodeStackTracesRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("creation")]
      ChromeProtocol.Domains.Runtime.StackTraceType? Creation = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns file information for the given<br/>
    /// File wrapper.<br/>
    /// </summary>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    public static ChromeProtocol.Domains.DOM.GetFileInfoRequest GetFileInfo(ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId)    
    {
      return new ChromeProtocol.Domains.DOM.GetFileInfoRequest(ObjectId);
    }
    /// <summary>
    /// Returns file information for the given<br/>
    /// File wrapper.<br/>
    /// </summary>
    /// <param name="ObjectId">JavaScript object id of the node wrapper.</param>
    [ChromeProtocol.Core.MethodName("DOM.getFileInfo")]
    public record GetFileInfoRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("objectId")]
      ChromeProtocol.Domains.Runtime.RemoteObjectIdType ObjectId
    ) : ChromeProtocol.Core.ICommand<GetFileInfoRequestResult>
    {
    }
    public record GetFileInfoRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("path")]
      string Path
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns list of detached nodes</summary>
    public static ChromeProtocol.Domains.DOM.GetDetachedDomNodesRequest GetDetachedDomNodes()    
    {
      return new ChromeProtocol.Domains.DOM.GetDetachedDomNodesRequest();
    }
    /// <summary>Returns list of detached nodes</summary>
    [ChromeProtocol.Core.MethodName("DOM.getDetachedDomNodes")]
    public record GetDetachedDomNodesRequest() : ChromeProtocol.Core.ICommand<GetDetachedDomNodesRequestResult>
    {
    }
    /// <param name="DetachedNodes">The list of detached nodes</param>
    public record GetDetachedDomNodesRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("detachedNodes")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.DetachedElementInfoType> DetachedNodes
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enables console to refer to the node with given id via $x (see Command Line API for more details<br/>
    /// $x functions).<br/>
    /// </summary>
    /// <param name="NodeId">DOM node id to be accessible by means of $x command line API.</param>
    public static ChromeProtocol.Domains.DOM.SetInspectedNodeRequest SetInspectedNode(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.SetInspectedNodeRequest(NodeId);
    }
    /// <summary>
    /// Enables console to refer to the node with given id via $x (see Command Line API for more details<br/>
    /// $x functions).<br/>
    /// </summary>
    /// <param name="NodeId">DOM node id to be accessible by means of $x command line API.</param>
    [ChromeProtocol.Core.MethodName("DOM.setInspectedNode")]
    public record SetInspectedNodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<SetInspectedNodeRequestResult>
    {
    }
    public record SetInspectedNodeRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets node name for a node with given id.</summary>
    /// <param name="NodeId">Id of the node to set name for.</param>
    /// <param name="Name">New node&#39;s name.</param>
    public static ChromeProtocol.Domains.DOM.SetNodeNameRequest SetNodeName(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Name)    
    {
      return new ChromeProtocol.Domains.DOM.SetNodeNameRequest(NodeId, Name);
    }
    /// <summary>Sets node name for a node with given id.</summary>
    /// <param name="NodeId">Id of the node to set name for.</param>
    /// <param name="Name">New node&#39;s name.</param>
    [ChromeProtocol.Core.MethodName("DOM.setNodeName")]
    public record SetNodeNameRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("name")]
      string Name
    ) : ChromeProtocol.Core.ICommand<SetNodeNameRequestResult>
    {
    }
    /// <param name="NodeId">New node&#39;s id.</param>
    public record SetNodeNameRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets node value for a node with given id.</summary>
    /// <param name="NodeId">Id of the node to set value for.</param>
    /// <param name="Value">New node&#39;s value.</param>
    public static ChromeProtocol.Domains.DOM.SetNodeValueRequest SetNodeValue(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string Value)    
    {
      return new ChromeProtocol.Domains.DOM.SetNodeValueRequest(NodeId, Value);
    }
    /// <summary>Sets node value for a node with given id.</summary>
    /// <param name="NodeId">Id of the node to set value for.</param>
    /// <param name="Value">New node&#39;s value.</param>
    [ChromeProtocol.Core.MethodName("DOM.setNodeValue")]
    public record SetNodeValueRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("value")]
      string Value
    ) : ChromeProtocol.Core.ICommand<SetNodeValueRequestResult>
    {
    }
    public record SetNodeValueRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Sets node HTML markup, returns new node id.</summary>
    /// <param name="NodeId">Id of the node to set markup for.</param>
    /// <param name="OuterHTML">Outer HTML markup to set.</param>
    public static ChromeProtocol.Domains.DOM.SetOuterHTMLRequest SetOuterHTML(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string OuterHTML)    
    {
      return new ChromeProtocol.Domains.DOM.SetOuterHTMLRequest(NodeId, OuterHTML);
    }
    /// <summary>Sets node HTML markup, returns new node id.</summary>
    /// <param name="NodeId">Id of the node to set markup for.</param>
    /// <param name="OuterHTML">Outer HTML markup to set.</param>
    [ChromeProtocol.Core.MethodName("DOM.setOuterHTML")]
    public record SetOuterHTMLRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("outerHTML")]
      string OuterHTML
    ) : ChromeProtocol.Core.ICommand<SetOuterHTMLRequestResult>
    {
    }
    public record SetOuterHTMLRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Undoes the last performed action.</summary>
    public static ChromeProtocol.Domains.DOM.UndoRequest Undo()    
    {
      return new ChromeProtocol.Domains.DOM.UndoRequest();
    }
    /// <summary>Undoes the last performed action.</summary>
    [ChromeProtocol.Core.MethodName("DOM.undo")]
    public record UndoRequest() : ChromeProtocol.Core.ICommand<UndoRequestResult>
    {
    }
    public record UndoRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns iframe node that owns iframe with the given domain.</summary>
    public static ChromeProtocol.Domains.DOM.GetFrameOwnerRequest GetFrameOwner(ChromeProtocol.Domains.Page.FrameIdType FrameId)    
    {
      return new ChromeProtocol.Domains.DOM.GetFrameOwnerRequest(FrameId);
    }
    /// <summary>Returns iframe node that owns iframe with the given domain.</summary>
    [ChromeProtocol.Core.MethodName("DOM.getFrameOwner")]
    public record GetFrameOwnerRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("frameId")]
      ChromeProtocol.Domains.Page.FrameIdType FrameId
    ) : ChromeProtocol.Core.ICommand<GetFrameOwnerRequestResult>
    {
    }
    /// <param name="BackendNodeId">Resulting node.</param>
    /// <param name="NodeId">Id of the node at given coordinates, only when enabled and requested document.</param>
    public record GetFrameOwnerRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("backendNodeId")]
      ChromeProtocol.Domains.DOM.BackendNodeIdType BackendNodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the query container of the given node based on container query<br/>
    /// conditions: containerName, physical, and logical axes. If no axes are<br/>
    /// provided, the style container is returned, which is the direct parent or the<br/>
    /// closest element with a matching container-name.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.DOM.GetContainerForNodeRequest GetContainerForNode(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string? ContainerName = default, ChromeProtocol.Domains.DOM.PhysicalAxesType? PhysicalAxes = default, ChromeProtocol.Domains.DOM.LogicalAxesType? LogicalAxes = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetContainerForNodeRequest(NodeId, ContainerName, PhysicalAxes, LogicalAxes);
    }
    /// <summary>
    /// Returns the query container of the given node based on container query<br/>
    /// conditions: containerName, physical, and logical axes. If no axes are<br/>
    /// provided, the style container is returned, which is the direct parent or the<br/>
    /// closest element with a matching container-name.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("DOM.getContainerForNode")]
    public record GetContainerForNodeRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("containerName")]
      string? ContainerName = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("physicalAxes")]
      ChromeProtocol.Domains.DOM.PhysicalAxesType? PhysicalAxes = default,
      [property: System.Text.Json.Serialization.JsonPropertyName("logicalAxes")]
      ChromeProtocol.Domains.DOM.LogicalAxesType? LogicalAxes = default
    ) : ChromeProtocol.Core.ICommand<GetContainerForNodeRequestResult>
    {
    }
    /// <param name="NodeId">The container node for the given node, or null if not found.</param>
    public record GetContainerForNodeRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType? NodeId = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the descendants of a container query container that have<br/>
    /// container queries against this container.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the container node to find querying descendants from.</param>
    public static ChromeProtocol.Domains.DOM.GetQueryingDescendantsForContainerRequest GetQueryingDescendantsForContainer(ChromeProtocol.Domains.DOM.NodeIdType NodeId)    
    {
      return new ChromeProtocol.Domains.DOM.GetQueryingDescendantsForContainerRequest(NodeId);
    }
    /// <summary>
    /// Returns the descendants of a container query container that have<br/>
    /// container queries against this container.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the container node to find querying descendants from.</param>
    [ChromeProtocol.Core.MethodName("DOM.getQueryingDescendantsForContainer")]
    public record GetQueryingDescendantsForContainerRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.ICommand<GetQueryingDescendantsForContainerRequestResult>
    {
    }
    /// <param name="NodeIds">Descendant nodes with container queries against the given container.</param>
    public record GetQueryingDescendantsForContainerRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.DOM.NodeIdType> NodeIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Returns the target anchor element of the given anchor query according to<br/>
    /// https://www.w3.org/TR/css-anchor-position-1/#target.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the positioned element from which to find the anchor.</param>
    /// <param name="AnchorSpecifier">
    /// An optional anchor specifier, as defined in<br/>
    /// https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier.<br/>
    /// If not provided, it will return the implicit anchor element for<br/>
    /// the given positioned element.<br/>
    /// </param>
    public static ChromeProtocol.Domains.DOM.GetAnchorElementRequest GetAnchorElement(ChromeProtocol.Domains.DOM.NodeIdType NodeId, string? AnchorSpecifier = default)    
    {
      return new ChromeProtocol.Domains.DOM.GetAnchorElementRequest(NodeId, AnchorSpecifier);
    }
    /// <summary>
    /// Returns the target anchor element of the given anchor query according to<br/>
    /// https://www.w3.org/TR/css-anchor-position-1/#target.<br/>
    /// </summary>
    /// <param name="NodeId">Id of the positioned element from which to find the anchor.</param>
    /// <param name="AnchorSpecifier">
    /// An optional anchor specifier, as defined in<br/>
    /// https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier.<br/>
    /// If not provided, it will return the implicit anchor element for<br/>
    /// the given positioned element.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("DOM.getAnchorElement")]
    public record GetAnchorElementRequest(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId,
      [property: System.Text.Json.Serialization.JsonPropertyName("anchorSpecifier")]
      string? AnchorSpecifier = default
    ) : ChromeProtocol.Core.ICommand<GetAnchorElementRequestResult>
    {
    }
    /// <param name="NodeId">The anchor element of the given anchor query.</param>
    public record GetAnchorElementRequestResult(
      [property: System.Text.Json.Serialization.JsonPropertyName("nodeId")]
      ChromeProtocol.Domains.DOM.NodeIdType NodeId
    ) : ChromeProtocol.Core.IType
    {
    }
  }
}
