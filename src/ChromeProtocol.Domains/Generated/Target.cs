// <auto-generated />
#nullable enable

using ChromeProtocol.Core;

namespace ChromeProtocol.Domains
{
  /// <summary>Supports additional targets discovery and allows to attach to them.</summary>
  public static partial class Target
  {
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record TargetIDType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <summary>Unique identifier of attached debugging session.</summary>
    [Newtonsoft.Json.JsonConverter(typeof(PrimitiveTypeConverter))]
    public record SessionIDType(
      string Value
    ) : ChromeProtocol.Core.PrimitiveType<string>(Value)
    {
    }
    /// <param name="Attached">Whether the target has an attached client.</param>
    /// <param name="CanAccessOpener">Whether the target has access to the originating window.</param>
    /// <param name="OpenerId">Opener target Id</param>
    /// <param name="OpenerFrameId">Frame id of originating window (is only set if target has an opener).</param>
    /// <param name="Subtype">
    /// Provides additional details for specific target types. For example, for<br/>
    /// the type of &quot;page&quot;, this may be set to &quot;portal&quot; or &quot;prerender&quot;.<br/>
    /// </param>
    public record TargetInfoType(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId,
      [property: Newtonsoft.Json.JsonProperty("type")]
      string Type,
      [property: Newtonsoft.Json.JsonProperty("title")]
      string Title,
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("attached")]
      bool Attached,
      [property: Newtonsoft.Json.JsonProperty("canAccessOpener")]
      bool CanAccessOpener,
      [property: Newtonsoft.Json.JsonProperty("openerId")]
      ChromeProtocol.Domains.Target.TargetIDType? OpenerId = default,
      [property: Newtonsoft.Json.JsonProperty("openerFrameId")]
      ChromeProtocol.Domains.Page.FrameIdType? OpenerFrameId = default,
      [property: Newtonsoft.Json.JsonProperty("browserContextId")]
      ChromeProtocol.Domains.Browser.BrowserContextIDType? BrowserContextId = default,
      [property: Newtonsoft.Json.JsonProperty("subtype")]
      string? Subtype = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>A filter used by target query/discovery/auto-attach operations.</summary>
    /// <param name="Exclude">If set, causes exclusion of mathcing targets from the list.</param>
    /// <param name="Type">If not present, matches any type.</param>
    public record FilterEntryType(
      [property: Newtonsoft.Json.JsonProperty("exclude")]
      bool? Exclude = default,
      [property: Newtonsoft.Json.JsonProperty("type")]
      string? Type = default
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// The entries in TargetFilter are matched sequentially against targets and<br/>
    /// the first entry that matches determines if the target is included or not,<br/>
    /// depending on the value of `exclude` field in the entry.<br/>
    /// If filter is not specified, the one assumed is<br/>
    /// [{type: &quot;browser&quot;, exclude: true}, {type: &quot;tab&quot;, exclude: true}, {}]<br/>
    /// (i.e. include everything but `browser` and `tab`).<br/>
    /// </summary>
    public record TargetFilterType() : ChromeProtocol.Core.IType
    {
    }
    public record RemoteLocationType(
      [property: Newtonsoft.Json.JsonProperty("host")]
      string Host,
      [property: Newtonsoft.Json.JsonProperty("port")]
      int Port
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Issued when attached to target because of auto-attach or `attachToTarget` command.</summary>
    /// <param name="SessionId">Identifier assigned to the session used to send/receive messages.</param>
    [ChromeProtocol.Core.MethodName("Target.attachedToTarget")]
    public record AttachedToTarget(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType SessionId,
      [property: Newtonsoft.Json.JsonProperty("targetInfo")]
      ChromeProtocol.Domains.Target.TargetInfoType TargetInfo,
      [property: Newtonsoft.Json.JsonProperty("waitingForDebugger")]
      bool WaitingForDebugger
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Issued when detached from target for any reason (including `detachFromTarget` command). Can be<br/>
    /// issued multiple times per target if multiple sessions have been attached to it.<br/>
    /// </summary>
    /// <param name="SessionId">Detached session identifier.</param>
    /// <param name="TargetId">Deprecated.</param>
    [ChromeProtocol.Core.MethodName("Target.detachedFromTarget")]
    public record DetachedFromTarget(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType SessionId,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType? TargetId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Notifies about a new protocol message received from the session (as reported in<br/>
    /// `attachedToTarget` event).<br/>
    /// </summary>
    /// <param name="SessionId">Identifier of a session which sends a message.</param>
    /// <param name="TargetId">Deprecated.</param>
    [ChromeProtocol.Core.MethodName("Target.receivedMessageFromTarget")]
    public record ReceivedMessageFromTarget(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType SessionId,
      [property: Newtonsoft.Json.JsonProperty("message")]
      string Message,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType? TargetId = default
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when a possible inspection target is created.</summary>
    [ChromeProtocol.Core.MethodName("Target.targetCreated")]
    public record TargetCreated(
      [property: Newtonsoft.Json.JsonProperty("targetInfo")]
      ChromeProtocol.Domains.Target.TargetInfoType TargetInfo
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when a target is destroyed.</summary>
    [ChromeProtocol.Core.MethodName("Target.targetDestroyed")]
    public record TargetDestroyed(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Issued when a target has crashed.</summary>
    /// <param name="Status">Termination status type.</param>
    /// <param name="ErrorCode">Termination error code.</param>
    [ChromeProtocol.Core.MethodName("Target.targetCrashed")]
    public record TargetCrashed(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId,
      [property: Newtonsoft.Json.JsonProperty("status")]
      string Status,
      [property: Newtonsoft.Json.JsonProperty("errorCode")]
      int ErrorCode
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>
    /// Issued when some information about a target has changed. This only happens between<br/>
    /// `targetCreated` and `targetDestroyed`.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Target.targetInfoChanged")]
    public record TargetInfoChanged(
      [property: Newtonsoft.Json.JsonProperty("targetInfo")]
      ChromeProtocol.Domains.Target.TargetInfoType TargetInfo
    ) : ChromeProtocol.Core.IEvent
    {
    }
    /// <summary>Activates (focuses) the target.</summary>
    public static ChromeProtocol.Domains.Target.ActivateTargetRequest ActivateTarget(ChromeProtocol.Domains.Target.TargetIDType TargetId)    
    {
      return new ChromeProtocol.Domains.Target.ActivateTargetRequest(TargetId);
    }
    /// <summary>Activates (focuses) the target.</summary>
    [ChromeProtocol.Core.MethodName("Target.activateTarget")]
    public record ActivateTargetRequest(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId
    ) : ChromeProtocol.Core.ICommand<ActivateTargetRequestResult>
    {
    }
    public record ActivateTargetRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Attaches to the target with given id.</summary>
    /// <param name="Flatten">
    /// Enables &quot;flat&quot; access to the session via specifying sessionId attribute in the commands.<br/>
    /// We plan to make this the default, deprecate non-flattened mode,<br/>
    /// and eventually retire it. See crbug.com/991325.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Target.AttachToTargetRequest AttachToTarget(ChromeProtocol.Domains.Target.TargetIDType TargetId, bool? Flatten = default)    
    {
      return new ChromeProtocol.Domains.Target.AttachToTargetRequest(TargetId, Flatten);
    }
    /// <summary>Attaches to the target with given id.</summary>
    /// <param name="Flatten">
    /// Enables &quot;flat&quot; access to the session via specifying sessionId attribute in the commands.<br/>
    /// We plan to make this the default, deprecate non-flattened mode,<br/>
    /// and eventually retire it. See crbug.com/991325.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Target.attachToTarget")]
    public record AttachToTargetRequest(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId,
      [property: Newtonsoft.Json.JsonProperty("flatten")]
      bool? Flatten = default
    ) : ChromeProtocol.Core.ICommand<AttachToTargetRequestResult>
    {
    }
    /// <param name="SessionId">Id assigned to the session.</param>
    public record AttachToTargetRequestResult(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType SessionId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Attaches to the browser target, only uses flat sessionId mode.</summary>
    public static ChromeProtocol.Domains.Target.AttachToBrowserTargetRequest AttachToBrowserTarget()    
    {
      return new ChromeProtocol.Domains.Target.AttachToBrowserTargetRequest();
    }
    /// <summary>Attaches to the browser target, only uses flat sessionId mode.</summary>
    [ChromeProtocol.Core.MethodName("Target.attachToBrowserTarget")]
    public record AttachToBrowserTargetRequest() : ChromeProtocol.Core.ICommand<AttachToBrowserTargetRequestResult>
    {
    }
    /// <param name="SessionId">Id assigned to the session.</param>
    public record AttachToBrowserTargetRequestResult(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType SessionId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Closes the target. If the target is a page that gets closed too.</summary>
    public static ChromeProtocol.Domains.Target.CloseTargetRequest CloseTarget(ChromeProtocol.Domains.Target.TargetIDType TargetId)    
    {
      return new ChromeProtocol.Domains.Target.CloseTargetRequest(TargetId);
    }
    /// <summary>Closes the target. If the target is a page that gets closed too.</summary>
    [ChromeProtocol.Core.MethodName("Target.closeTarget")]
    public record CloseTargetRequest(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId
    ) : ChromeProtocol.Core.ICommand<CloseTargetRequestResult>
    {
    }
    /// <param name="Success">Always set to true. If an error occurs, the response indicates protocol error.</param>
    public record CloseTargetRequestResult(
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("success")]
      bool Success
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Inject object to the target&#39;s main frame that provides a communication<br/>
    /// channel with browser target.<br/>
    /// Injected object will be available as `window[bindingName]`.<br/>
    /// The object has the follwing API:<br/>
    /// - `binding.send(json)` - a method to send messages over the remote debugging protocol<br/>
    /// - `binding.onmessage = json =&gt; handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.<br/>
    /// </summary>
    /// <param name="BindingName">Binding name, &#39;cdp&#39; if not specified.</param>
    public static ChromeProtocol.Domains.Target.ExposeDevToolsProtocolRequest ExposeDevToolsProtocol(ChromeProtocol.Domains.Target.TargetIDType TargetId, string? BindingName = default)    
    {
      return new ChromeProtocol.Domains.Target.ExposeDevToolsProtocolRequest(TargetId, BindingName);
    }
    /// <summary>
    /// Inject object to the target&#39;s main frame that provides a communication<br/>
    /// channel with browser target.<br/>
    /// Injected object will be available as `window[bindingName]`.<br/>
    /// The object has the follwing API:<br/>
    /// - `binding.send(json)` - a method to send messages over the remote debugging protocol<br/>
    /// - `binding.onmessage = json =&gt; handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.<br/>
    /// </summary>
    /// <param name="BindingName">Binding name, &#39;cdp&#39; if not specified.</param>
    [ChromeProtocol.Core.MethodName("Target.exposeDevToolsProtocol")]
    public record ExposeDevToolsProtocolRequest(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId,
      [property: Newtonsoft.Json.JsonProperty("bindingName")]
      string? BindingName = default
    ) : ChromeProtocol.Core.ICommand<ExposeDevToolsProtocolRequestResult>
    {
    }
    public record ExposeDevToolsProtocolRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than<br/>
    /// one.<br/>
    /// </summary>
    /// <param name="DisposeOnDetach">If specified, disposes this context when debugging session disconnects.</param>
    /// <param name="ProxyServer">Proxy server, similar to the one passed to --proxy-server</param>
    /// <param name="ProxyBypassList">Proxy bypass list, similar to the one passed to --proxy-bypass-list</param>
    /// <param name="OriginsWithUniversalNetworkAccess">
    /// An optional list of origins to grant unlimited cross-origin access to.<br/>
    /// Parts of the URL other than those constituting origin are ignored.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Target.CreateBrowserContextRequest CreateBrowserContext(bool? DisposeOnDetach = default, string? ProxyServer = default, string? ProxyBypassList = default, System.Collections.Generic.IReadOnlyList<string>? OriginsWithUniversalNetworkAccess = default)    
    {
      return new ChromeProtocol.Domains.Target.CreateBrowserContextRequest(DisposeOnDetach, ProxyServer, ProxyBypassList, OriginsWithUniversalNetworkAccess);
    }
    /// <summary>
    /// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than<br/>
    /// one.<br/>
    /// </summary>
    /// <param name="DisposeOnDetach">If specified, disposes this context when debugging session disconnects.</param>
    /// <param name="ProxyServer">Proxy server, similar to the one passed to --proxy-server</param>
    /// <param name="ProxyBypassList">Proxy bypass list, similar to the one passed to --proxy-bypass-list</param>
    /// <param name="OriginsWithUniversalNetworkAccess">
    /// An optional list of origins to grant unlimited cross-origin access to.<br/>
    /// Parts of the URL other than those constituting origin are ignored.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Target.createBrowserContext")]
    public record CreateBrowserContextRequest(
      [property: Newtonsoft.Json.JsonProperty("disposeOnDetach")]
      bool? DisposeOnDetach = default,
      [property: Newtonsoft.Json.JsonProperty("proxyServer")]
      string? ProxyServer = default,
      [property: Newtonsoft.Json.JsonProperty("proxyBypassList")]
      string? ProxyBypassList = default,
      [property: Newtonsoft.Json.JsonProperty("originsWithUniversalNetworkAccess")]
      System.Collections.Generic.IReadOnlyList<string>? OriginsWithUniversalNetworkAccess = default
    ) : ChromeProtocol.Core.ICommand<CreateBrowserContextRequestResult>
    {
    }
    /// <param name="BrowserContextId">The id of the context created.</param>
    public record CreateBrowserContextRequestResult(
      [property: Newtonsoft.Json.JsonProperty("browserContextId")]
      ChromeProtocol.Domains.Browser.BrowserContextIDType BrowserContextId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns all browser contexts created with `Target.createBrowserContext` method.</summary>
    public static ChromeProtocol.Domains.Target.GetBrowserContextsRequest GetBrowserContexts()    
    {
      return new ChromeProtocol.Domains.Target.GetBrowserContextsRequest();
    }
    /// <summary>Returns all browser contexts created with `Target.createBrowserContext` method.</summary>
    [ChromeProtocol.Core.MethodName("Target.getBrowserContexts")]
    public record GetBrowserContextsRequest() : ChromeProtocol.Core.ICommand<GetBrowserContextsRequestResult>
    {
    }
    /// <param name="BrowserContextIds">An array of browser context ids.</param>
    public record GetBrowserContextsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("browserContextIds")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Browser.BrowserContextIDType> BrowserContextIds
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Creates a new page.</summary>
    /// <param name="Url">The initial URL the page will be navigated to. An empty string indicates about:blank.</param>
    /// <param name="Width">Frame width in DIP (headless chrome only).</param>
    /// <param name="Height">Frame height in DIP (headless chrome only).</param>
    /// <param name="BrowserContextId">The browser context to create the page in.</param>
    /// <param name="EnableBeginFrameControl">
    /// Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,<br/>
    /// not supported on MacOS yet, false by default).<br/>
    /// </param>
    /// <param name="NewWindow">Whether to create a new Window or Tab (chrome-only, false by default).</param>
    /// <param name="Background">
    /// Whether to create the target in background or foreground (chrome-only,<br/>
    /// false by default).<br/>
    /// </param>
    /// <param name="ForTab">Whether to create the target of type &quot;tab&quot;.</param>
    public static ChromeProtocol.Domains.Target.CreateTargetRequest CreateTarget(string Url, int? Width = default, int? Height = default, ChromeProtocol.Domains.Browser.BrowserContextIDType? BrowserContextId = default, bool? EnableBeginFrameControl = default, bool? NewWindow = default, bool? Background = default, bool? ForTab = default)    
    {
      return new ChromeProtocol.Domains.Target.CreateTargetRequest(Url, Width, Height, BrowserContextId, EnableBeginFrameControl, NewWindow, Background, ForTab);
    }
    /// <summary>Creates a new page.</summary>
    /// <param name="Url">The initial URL the page will be navigated to. An empty string indicates about:blank.</param>
    /// <param name="Width">Frame width in DIP (headless chrome only).</param>
    /// <param name="Height">Frame height in DIP (headless chrome only).</param>
    /// <param name="BrowserContextId">The browser context to create the page in.</param>
    /// <param name="EnableBeginFrameControl">
    /// Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,<br/>
    /// not supported on MacOS yet, false by default).<br/>
    /// </param>
    /// <param name="NewWindow">Whether to create a new Window or Tab (chrome-only, false by default).</param>
    /// <param name="Background">
    /// Whether to create the target in background or foreground (chrome-only,<br/>
    /// false by default).<br/>
    /// </param>
    /// <param name="ForTab">Whether to create the target of type &quot;tab&quot;.</param>
    [ChromeProtocol.Core.MethodName("Target.createTarget")]
    public record CreateTargetRequest(
      [property: Newtonsoft.Json.JsonProperty("url")]
      string Url,
      [property: Newtonsoft.Json.JsonProperty("width")]
      int? Width = default,
      [property: Newtonsoft.Json.JsonProperty("height")]
      int? Height = default,
      [property: Newtonsoft.Json.JsonProperty("browserContextId")]
      ChromeProtocol.Domains.Browser.BrowserContextIDType? BrowserContextId = default,
      [property: Newtonsoft.Json.JsonProperty("enableBeginFrameControl")]
      bool? EnableBeginFrameControl = default,
      [property: Newtonsoft.Json.JsonProperty("newWindow")]
      bool? NewWindow = default,
      [property: Newtonsoft.Json.JsonProperty("background")]
      bool? Background = default,
      [property: Newtonsoft.Json.JsonProperty("forTab")]
      bool? ForTab = default
    ) : ChromeProtocol.Core.ICommand<CreateTargetRequestResult>
    {
    }
    /// <param name="TargetId">The id of the page opened.</param>
    public record CreateTargetRequestResult(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Detaches session with given id.</summary>
    /// <param name="SessionId">Session to detach.</param>
    /// <param name="TargetId">Deprecated.</param>
    public static ChromeProtocol.Domains.Target.DetachFromTargetRequest DetachFromTarget(ChromeProtocol.Domains.Target.SessionIDType? SessionId = default, ChromeProtocol.Domains.Target.TargetIDType? TargetId = default)    
    {
      return new ChromeProtocol.Domains.Target.DetachFromTargetRequest(SessionId, TargetId);
    }
    /// <summary>Detaches session with given id.</summary>
    /// <param name="SessionId">Session to detach.</param>
    /// <param name="TargetId">Deprecated.</param>
    [ChromeProtocol.Core.MethodName("Target.detachFromTarget")]
    public record DetachFromTargetRequest(
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType? SessionId = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType? TargetId = default
    ) : ChromeProtocol.Core.ICommand<DetachFromTargetRequestResult>
    {
    }
    public record DetachFromTargetRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Deletes a BrowserContext. All the belonging pages will be closed without calling their<br/>
    /// beforeunload hooks.<br/>
    /// </summary>
    public static ChromeProtocol.Domains.Target.DisposeBrowserContextRequest DisposeBrowserContext(ChromeProtocol.Domains.Browser.BrowserContextIDType BrowserContextId)    
    {
      return new ChromeProtocol.Domains.Target.DisposeBrowserContextRequest(BrowserContextId);
    }
    /// <summary>
    /// Deletes a BrowserContext. All the belonging pages will be closed without calling their<br/>
    /// beforeunload hooks.<br/>
    /// </summary>
    [ChromeProtocol.Core.MethodName("Target.disposeBrowserContext")]
    public record DisposeBrowserContextRequest(
      [property: Newtonsoft.Json.JsonProperty("browserContextId")]
      ChromeProtocol.Domains.Browser.BrowserContextIDType BrowserContextId
    ) : ChromeProtocol.Core.ICommand<DisposeBrowserContextRequestResult>
    {
    }
    public record DisposeBrowserContextRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Returns information about a target.</summary>
    public static ChromeProtocol.Domains.Target.GetTargetInfoRequest GetTargetInfo(ChromeProtocol.Domains.Target.TargetIDType? TargetId = default)    
    {
      return new ChromeProtocol.Domains.Target.GetTargetInfoRequest(TargetId);
    }
    /// <summary>Returns information about a target.</summary>
    [ChromeProtocol.Core.MethodName("Target.getTargetInfo")]
    public record GetTargetInfoRequest(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType? TargetId = default
    ) : ChromeProtocol.Core.ICommand<GetTargetInfoRequestResult>
    {
    }
    public record GetTargetInfoRequestResult(
      [property: Newtonsoft.Json.JsonProperty("targetInfo")]
      ChromeProtocol.Domains.Target.TargetInfoType TargetInfo
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>Retrieves a list of available targets.</summary>
    /// <param name="Filter">
    /// Only targets matching filter will be reported. If filter is not specified<br/>
    /// and target discovery is currently enabled, a filter used for target discovery<br/>
    /// is used for consistency.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Target.GetTargetsRequest GetTargets(ChromeProtocol.Domains.Target.TargetFilterType? Filter = default)    
    {
      return new ChromeProtocol.Domains.Target.GetTargetsRequest(Filter);
    }
    /// <summary>Retrieves a list of available targets.</summary>
    /// <param name="Filter">
    /// Only targets matching filter will be reported. If filter is not specified<br/>
    /// and target discovery is currently enabled, a filter used for target discovery<br/>
    /// is used for consistency.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Target.getTargets")]
    public record GetTargetsRequest(
      [property: Newtonsoft.Json.JsonProperty("filter")]
      ChromeProtocol.Domains.Target.TargetFilterType? Filter = default
    ) : ChromeProtocol.Core.ICommand<GetTargetsRequestResult>
    {
    }
    /// <param name="TargetInfos">The list of targets.</param>
    public record GetTargetsRequestResult(
      [property: Newtonsoft.Json.JsonProperty("targetInfos")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Target.TargetInfoType> TargetInfos
    ) : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Sends protocol message over session with given id.<br/>
    /// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,<br/>
    /// and crbug.com/991325.<br/>
    /// </summary>
    /// <param name="SessionId">Identifier of the session.</param>
    /// <param name="TargetId">Deprecated.</param>
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public static ChromeProtocol.Domains.Target.SendMessageToTargetRequest SendMessageToTarget(string Message, ChromeProtocol.Domains.Target.SessionIDType? SessionId = default, ChromeProtocol.Domains.Target.TargetIDType? TargetId = default)    
    {
      return new ChromeProtocol.Domains.Target.SendMessageToTargetRequest(Message, SessionId, TargetId);
    }
    /// <summary>
    /// Sends protocol message over session with given id.<br/>
    /// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,<br/>
    /// and crbug.com/991325.<br/>
    /// </summary>
    /// <param name="SessionId">Identifier of the session.</param>
    /// <param name="TargetId">Deprecated.</param>
    [ChromeProtocol.Core.MethodName("Target.sendMessageToTarget")]
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SendMessageToTargetRequest(
      [property: Newtonsoft.Json.JsonProperty("message")]
      string Message,
      [property: Newtonsoft.Json.JsonProperty("sessionId")]
      ChromeProtocol.Domains.Target.SessionIDType? SessionId = default,
      [property: System.Obsolete("This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType? TargetId = default
    ) : ChromeProtocol.Core.ICommand<SendMessageToTargetRequestResult>
    {
    }
    [System.Obsolete("This command marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.", false)]
    public record SendMessageToTargetRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Controls whether to automatically attach to new targets which are considered to be related to<br/>
    /// this one. When turned on, attaches to all existing related targets as well. When turned off,<br/>
    /// automatically detaches from all currently attached targets.<br/>
    /// This also clears all targets added by `autoAttachRelated` from the list of targets to watch<br/>
    /// for creation of related targets.<br/>
    /// </summary>
    /// <param name="AutoAttach">Whether to auto-attach to related targets.</param>
    /// <param name="WaitForDebuggerOnStart">
    /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`<br/>
    /// to run paused targets.<br/>
    /// </param>
    /// <param name="Flatten">
    /// Enables &quot;flat&quot; access to the session via specifying sessionId attribute in the commands.<br/>
    /// We plan to make this the default, deprecate non-flattened mode,<br/>
    /// and eventually retire it. See crbug.com/991325.<br/>
    /// </param>
    /// <param name="Filter">Only targets matching filter will be attached.</param>
    public static ChromeProtocol.Domains.Target.SetAutoAttachRequest SetAutoAttach(bool AutoAttach, bool WaitForDebuggerOnStart, bool? Flatten = default, ChromeProtocol.Domains.Target.TargetFilterType? Filter = default)    
    {
      return new ChromeProtocol.Domains.Target.SetAutoAttachRequest(AutoAttach, WaitForDebuggerOnStart, Flatten, Filter);
    }
    /// <summary>
    /// Controls whether to automatically attach to new targets which are considered to be related to<br/>
    /// this one. When turned on, attaches to all existing related targets as well. When turned off,<br/>
    /// automatically detaches from all currently attached targets.<br/>
    /// This also clears all targets added by `autoAttachRelated` from the list of targets to watch<br/>
    /// for creation of related targets.<br/>
    /// </summary>
    /// <param name="AutoAttach">Whether to auto-attach to related targets.</param>
    /// <param name="WaitForDebuggerOnStart">
    /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`<br/>
    /// to run paused targets.<br/>
    /// </param>
    /// <param name="Flatten">
    /// Enables &quot;flat&quot; access to the session via specifying sessionId attribute in the commands.<br/>
    /// We plan to make this the default, deprecate non-flattened mode,<br/>
    /// and eventually retire it. See crbug.com/991325.<br/>
    /// </param>
    /// <param name="Filter">Only targets matching filter will be attached.</param>
    [ChromeProtocol.Core.MethodName("Target.setAutoAttach")]
    public record SetAutoAttachRequest(
      [property: Newtonsoft.Json.JsonProperty("autoAttach")]
      bool AutoAttach,
      [property: Newtonsoft.Json.JsonProperty("waitForDebuggerOnStart")]
      bool WaitForDebuggerOnStart,
      [property: Newtonsoft.Json.JsonProperty("flatten")]
      bool? Flatten = default,
      [property: Newtonsoft.Json.JsonProperty("filter")]
      ChromeProtocol.Domains.Target.TargetFilterType? Filter = default
    ) : ChromeProtocol.Core.ICommand<SetAutoAttachRequestResult>
    {
    }
    public record SetAutoAttachRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Adds the specified target to the list of targets that will be monitored for any related target<br/>
    /// creation (such as child frames, child workers and new versions of service worker) and reported<br/>
    /// through `attachedToTarget`. The specified target is also auto-attached.<br/>
    /// This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent<br/>
    /// `setAutoAttach`. Only available at the Browser target.<br/>
    /// </summary>
    /// <param name="WaitForDebuggerOnStart">
    /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`<br/>
    /// to run paused targets.<br/>
    /// </param>
    /// <param name="Filter">Only targets matching filter will be attached.</param>
    public static ChromeProtocol.Domains.Target.AutoAttachRelatedRequest AutoAttachRelated(ChromeProtocol.Domains.Target.TargetIDType TargetId, bool WaitForDebuggerOnStart, ChromeProtocol.Domains.Target.TargetFilterType? Filter = default)    
    {
      return new ChromeProtocol.Domains.Target.AutoAttachRelatedRequest(TargetId, WaitForDebuggerOnStart, Filter);
    }
    /// <summary>
    /// Adds the specified target to the list of targets that will be monitored for any related target<br/>
    /// creation (such as child frames, child workers and new versions of service worker) and reported<br/>
    /// through `attachedToTarget`. The specified target is also auto-attached.<br/>
    /// This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent<br/>
    /// `setAutoAttach`. Only available at the Browser target.<br/>
    /// </summary>
    /// <param name="WaitForDebuggerOnStart">
    /// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`<br/>
    /// to run paused targets.<br/>
    /// </param>
    /// <param name="Filter">Only targets matching filter will be attached.</param>
    [ChromeProtocol.Core.MethodName("Target.autoAttachRelated")]
    public record AutoAttachRelatedRequest(
      [property: Newtonsoft.Json.JsonProperty("targetId")]
      ChromeProtocol.Domains.Target.TargetIDType TargetId,
      [property: Newtonsoft.Json.JsonProperty("waitForDebuggerOnStart")]
      bool WaitForDebuggerOnStart,
      [property: Newtonsoft.Json.JsonProperty("filter")]
      ChromeProtocol.Domains.Target.TargetFilterType? Filter = default
    ) : ChromeProtocol.Core.ICommand<AutoAttachRelatedRequestResult>
    {
    }
    public record AutoAttachRelatedRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Controls whether to discover available targets and notify via<br/>
    /// `targetCreated/targetInfoChanged/targetDestroyed` events.<br/>
    /// </summary>
    /// <param name="Discover">Whether to discover available targets.</param>
    /// <param name="Filter">
    /// Only targets matching filter will be attached. If `discover` is false,<br/>
    /// `filter` must be omitted or empty.<br/>
    /// </param>
    public static ChromeProtocol.Domains.Target.SetDiscoverTargetsRequest SetDiscoverTargets(bool Discover, ChromeProtocol.Domains.Target.TargetFilterType? Filter = default)    
    {
      return new ChromeProtocol.Domains.Target.SetDiscoverTargetsRequest(Discover, Filter);
    }
    /// <summary>
    /// Controls whether to discover available targets and notify via<br/>
    /// `targetCreated/targetInfoChanged/targetDestroyed` events.<br/>
    /// </summary>
    /// <param name="Discover">Whether to discover available targets.</param>
    /// <param name="Filter">
    /// Only targets matching filter will be attached. If `discover` is false,<br/>
    /// `filter` must be omitted or empty.<br/>
    /// </param>
    [ChromeProtocol.Core.MethodName("Target.setDiscoverTargets")]
    public record SetDiscoverTargetsRequest(
      [property: Newtonsoft.Json.JsonProperty("discover")]
      bool Discover,
      [property: Newtonsoft.Json.JsonProperty("filter")]
      ChromeProtocol.Domains.Target.TargetFilterType? Filter = default
    ) : ChromeProtocol.Core.ICommand<SetDiscoverTargetsRequestResult>
    {
    }
    public record SetDiscoverTargetsRequestResult() : ChromeProtocol.Core.IType
    {
    }
    /// <summary>
    /// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to<br/>
    /// `true`.<br/>
    /// </summary>
    /// <param name="Locations">List of remote locations.</param>
    public static ChromeProtocol.Domains.Target.SetRemoteLocationsRequest SetRemoteLocations(System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Target.RemoteLocationType> Locations)    
    {
      return new ChromeProtocol.Domains.Target.SetRemoteLocationsRequest(Locations);
    }
    /// <summary>
    /// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to<br/>
    /// `true`.<br/>
    /// </summary>
    /// <param name="Locations">List of remote locations.</param>
    [ChromeProtocol.Core.MethodName("Target.setRemoteLocations")]
    public record SetRemoteLocationsRequest(
      [property: Newtonsoft.Json.JsonProperty("locations")]
      System.Collections.Generic.IReadOnlyList<ChromeProtocol.Domains.Target.RemoteLocationType> Locations
    ) : ChromeProtocol.Core.ICommand<SetRemoteLocationsRequestResult>
    {
    }
    public record SetRemoteLocationsRequestResult() : ChromeProtocol.Core.IType
    {
    }
  }
}
